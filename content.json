{"meta":{"title":"K A I","subtitle":"","description":"","author":"Kaillliu","url":"http://kaillliu.github.io","root":"/"},"pages":[{"title":"","date":"2022-03-28T10:54:00.479Z","updated":"2022-03-28T10:54:00.479Z","comments":true,"path":"manifest.json","permalink":"http://kaillliu.github.io/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"404","date":"2022-03-27T10:04:11.081Z","updated":"2022-03-27T10:04:11.081Z","comments":true,"path":"404/index.html","permalink":"http://kaillliu.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2022-03-27T10:02:17.000Z","updated":"2022-03-29T05:26:19.360Z","comments":true,"path":"about/index.html","permalink":"http://kaillliu.github.io/about/index.html","excerpt":"","text":"不知道这一页该放些啥，就放个邮箱吧，有啥事可以发邮件联系我😄 邮箱：kaillliu@163.com"},{"title":"标签","date":"2022-03-27T09:44:50.000Z","updated":"2022-03-28T06:10:24.448Z","comments":true,"path":"tags/index.html","permalink":"http://kaillliu.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-27T09:43:43.000Z","updated":"2022-03-28T06:10:42.758Z","comments":true,"path":"categories/index.html","permalink":"http://kaillliu.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-03-27T10:13:42.000Z","updated":"2022-03-27T10:13:54.674Z","comments":true,"path":"contact/index.html","permalink":"http://kaillliu.github.io/contact/index.html","excerpt":"","text":""},{"title":"站外链接","date":"2022-03-28T06:11:16.000Z","updated":"2022-03-28T06:14:09.815Z","comments":true,"path":"link/index.html","permalink":"http://kaillliu.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式笔记之Adapter（适配器）模式","slug":"设计模式笔记之Adapter（适配器）模式","date":"2022-04-02T05:36:59.000Z","updated":"2022-04-02T09:23:21.390Z","comments":true,"path":"2022/04/02/设计模式笔记之Adapter（适配器）模式/","link":"","permalink":"http://kaillliu.github.io/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BAdapter%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"书本网盘链接😀 链接：https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye 提取码：rlye Adapter（适配器）模式 意图 将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 注：适配器模式在详细设计阶段不需要考虑它，它是为了对现有系统或产品接口兼容时，也就是既成事实的情况下的补救措施。 适用性 你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 结构 类适配器模式 对象适配器模式 登场角色 **Target (目标角色 对象，要用的接口) ** 定义Client所需的方法。 **Client (使用场景 请求者) ** 与符合Target接口的对象协同，使用Target角色定义的方法进行具体处理。 **Adaptee (被适配) ** 定义一个已经存在的接角色，这个角色需要适配。 Adapter (适配器，把Adaptee接口转换为Target可用的接口) 对Adaptee的接口与Target接口进行适配 优点 可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。 增加了类的透明性 提高了类的复用度 灵活性非常好","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式笔记之Iterator（迭代器）模式","slug":"设计模式笔记之Iterator（迭代器）模式","date":"2022-04-02T05:36:59.000Z","updated":"2022-04-02T09:05:50.916Z","comments":true,"path":"2022/04/02/设计模式笔记之Iterator（迭代器）模式/","link":"","permalink":"http://kaillliu.github.io/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"书本网盘链接😀 链接：https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye 提取码：rlye Iterator（迭代器）模式 意图 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，即为遍历和实现可以分离开来。 适用性 访问一个聚合对象的内容而无需暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。 结构 登场角色 Iterator 迭代器 负责定义访问和遍历元素的接口（API）。 Concretelterator 具体的迭代器 负责实现Iterator角色所定义的接口（API）。 Aggregate 集合 集合定义创建Iterator角色的接口，在示例程序中，由Aggregate接口扮演此角色，里面定义了Iterator方法。 ConcreteAggregate 具体的集合 负责实现Aggregate角色所定义的接口。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Leetcode-084,085-单调栈-数组中的最大矩阵,最大矩阵","slug":"leetcode-42-数组中的最大矩形","date":"2022-03-29T13:28:00.000Z","updated":"2022-03-31T12:00:14.287Z","comments":true,"path":"2022/03/29/leetcode-42-数组中的最大矩形/","link":"","permalink":"http://kaillliu.github.io/2022/03/29/leetcode-42-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","excerpt":"","text":"题目链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ ​ ：https://leetcode-cn.com/problems/maximal-rectangle/ 84. 解法一：暴力求解 123456789101112131415161718192021222324252627//时间复杂度为o(N^2)，提交结果超时class Solution &#123; public int largestRectangleArea(int[] heights) &#123; //定义长度，返回值 int area = 0, n = heights.length; for(int i = 0; i &lt; n; i++)&#123; //确定宽 int left = i; int right = i; //确定左边 for(; left&gt;=0; left--)&#123; if(heights[left] &lt; heights[i])&#123; break; &#125; &#125; //确定右边 for(; right&lt;n; right++)&#123; if(heights[right] &lt; heights[i])&#123; break; &#125; &#125; //计算面积 area = Math.max(area,(heights[i] * (right - left -1))); &#125; return area; &#125;&#125; 解法二：单调栈，用Deque数据结构（来自评论区大佬，太妙了） 1234567891011121314151617181920212223public int largestRectangleArea(int[] heights) &#123; // 这里为了代码简便，在柱体数组的头和尾加了两个高度为 0 的柱体。 // arraycopy(源，起始，目标，目标起始，源长度) int[] tmp = new int[heights.length + 2]; System.arraycopy(heights, 0, tmp, 1, heights.length); Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); int area = 0; for (int i = 0; i &lt; tmp.length; i++) &#123; // 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」； // 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。 // i是右边界 // 因此以栈顶柱体为高的矩形的左右宽度边界就确定了，可以计算面积～ //stack.peek()获得栈顶元素，stack.pop()获取栈顶元素并删除 while (!stack.isEmpty() &amp;&amp; tmp[i] &lt; tmp[stack.peek()]) &#123; int h = tmp[stack.pop()]; area = Math.max(area, (i - stack.peek() - 1) * h); &#125; stack.push(i); &#125; return area; &#125; 85. 解法 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 思路：转化为84中的求矩阵中的最大矩形，遍历，对每一行求高 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; //85-最大矩阵 public int maximalRectangle(char[][] matrix) &#123; if(matrix.length == 0 || matrix[0].length == 0)&#123; return 0; &#125; int col = matrix.length; int row = matrix[0].length; int[] heights = new int[row]; int result = 0; //遍历行 for(int i = 0; i &lt; col; i++)&#123; //遍历列，求高 for (int j = 0; j &lt; row; j++) &#123; if(matrix[i][j] == &#x27;1&#x27;) &#123; heights[j] += 1; &#125; else &#123; heights[j] = 0; &#125; &#125; result = Math.max(result,max(heights)); &#125; return result; &#125; //84 public int max(int[] heights)&#123; int[] temp = new int[heights.length + 2]; System.arraycopy(heights, 0, temp, 1, heights.length); Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); int area = 0; for(int i = 0; i &lt; temp.length; i++)&#123; while(!stack.isEmpty() &amp;&amp; temp[i] &lt; temp[stack.peek()] )&#123; int h = temp[stack.pop()]; area = Math.max(area,(i - stack.peek() - 1) * h); &#125; stack.push(i); &#125; return area; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/categories/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kaillliu.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/tags/LeetCode/"},{"name":"单调栈","slug":"单调栈","permalink":"http://kaillliu.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"Hexo配合Github Pages搭建个人博客","slug":"HI","date":"2022-03-27T08:21:26.000Z","updated":"2022-03-29T05:05:06.146Z","comments":true,"path":"2022/03/27/HI/","link":"","permalink":"http://kaillliu.github.io/2022/03/27/HI/","excerpt":"","text":"前言 目前市面上有成熟的知识分享平台，例如CSDN、掘金等等，也可以被搜索引擎检索到。除此之外也可以自己搭建一个个人博客网站，主要使用的就是 Hexo + GitPage 的方式，本站主要使用 GitHub Page + Hexo搭建静态博客网站。 GitHub Pages 是什么？ What is GitHub Pages? - GitHub Help GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。 Hexo是什么？ 官网：hexo.io Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。 为什么使用Hexo + GitHub Pages 优点： 主要是 Hexo 完全免费，静态，轻量快速，并且可以托管在GitHub，当然也可以托管在国内的Gitee里面，但是会麻烦一点。 缺点： 在国内GitHub访问速度一般，前期搭建和发布文章有点点麻烦。 搭建步骤 安装准备 在搭建博客之前，需要确认电脑上已经安装好了 Git 和 Node.js ，然后再安装Hexo。 ​ Node.js 官网 ​ Git 官网 ​ Git 安装教程 ​ Node.js 安装教程 12# 安装Node.js之后使用国内的淘宝镜像源加速，安装之后可以用 cnpm 代替 npmnpm install -g cnpm --registry=https://registry.npm.taobao.org 链接GitHub 需要一个GitHub账号，使用邮箱注册。 配置GitHub账号 123# 配置用户名和邮箱git config --global user.name &quot;github的用户名&quot;git config --global user.email &quot;github的注册邮箱&quot; 创建SSH密钥 12# 生成 ssh 密钥ssh-keygen -t rsa -C &quot;github的注册邮箱&quot; 添加密匙： 进入 C:\\Users\\用户名\\.ssh 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。 登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。 Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。 验证连接： 打开 Git Bash，输入 ssh -T git@github.com 出现 “Are you sure……”，输入 yes 回车确认。 显示 “Hi xxx! You’ve successfully……” 即连接成功。 新建Github Pages 仓库 GitHub 主页右上角加号 -&gt; New repository： Repository name 中输入 用户名.github.io 勾选 “Initialize this repository with a README” Description 选填 填好后点击 Create repository 创建。 创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io 本地安装Hexo 新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。 安装 Hexo 使用 npm 一键安装 Hexo 博客程序： 1cnpm install -g hexo-cli Hexo 初始化和本地预览 初始化并安装所需组件： 12hexo init # 初始化cnpm install # 安装组件 完成后依次输入下面命令，启动本地服务器进行预览： 1234# hexo clean hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ **Tips：**如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。 Hexo 博客文件夹目录结构如下： 部署Hexo到GitHub Pages 本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。 首先安装 hexo-deployer-git： 1cnpm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 12345# 仓库地址最好是ssh方式，也可以是http格式，可以在github仓库中查找到deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages。 完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 绑定域名（待更新） 开始使用 发布文章 进入博客所在目录，右键打开 Git Bash Here，创建博文： 1hexo new &quot;My New Post&quot; 然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。 写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。 12hexo g # 生成页面hexo d # 部署发布 也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。 12345678910111213---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文 网站设置 包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考官方文档按需要编辑。 注意：冒号后要加一个空格！ 更换主题 在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后修改 _config.yml 中的 theme 为新主题名称 next，发布。（有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。） 常用命令 12345678hexo new &quot;name&quot; # 新建文章hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面hexo d # 部署hexo g -d # 生成页面并部署hexo s # 本地预览hexo clean # 清除缓存和已生成的静态文件hexo help # 帮助 PicGo + Github + CDN 搭建博客图床 创建仓库 新键一个图片仓库 填好相关信息 获取token token token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。 当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。我们通过token来确定GitHub仓库的位置。 点击setting Settings -&gt; Developer settings -&gt; Personal access tokens，最后点击 generate new token； 点击生成token 保存好生成的token(仅显示一次)，因此最好存放到备忘录里面。 下载PicGo 进入picgo官网: https://picgo.github.io/PicGo-Doc/zh/ 点击免费下载，跳转到GitHub界面，选择对应系统的版本进行安装 设置PicGo 选择GitHub图床，根据提示填写，保存图片的库可以更换，只需要把PicGo里面的仓库名对应改掉就行 在picgo设置里面可以设置上传的快捷键，此外，最好打开时间戳重命名功能，防止图片名字重复 CDN加速 CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。 在这里，我们选择了快速免费公有的CDN-jsdelivr 配置方法： 只需要在我们 PicGo 图床配置中添加如下自定义域名即可 https://cdn.jsdelivr.net/gh/用户名/仓库名 到这里，一个图床算是基本搭建好了。通过picgo上传图片，会在GitHub创建的仓库中保存。 Markdown编辑器Typora的设置（可选） Markdown 官网：https://markdown.com.cn/ Markdown是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。 markdown的优点： 专注于文字内容； 纯文本，易读易写，可以方便地纳入版本控制； 语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。 Typora ypora是一个专注于markdown语言的优秀编辑器。 官网：https://typora.io/ 打开Typora的偏好设置，设置好红色方框里面的内容，便可以在Typora里面编写文章的同时上传图片到图床了。 常见问题 设置网站图标 进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：favicon: 图标地址。（不同主题可能略有差别） 修改并部署后没有效果 使用 hexo clean 清理后重新部署。 开启 HTTPS 后访问网站显示连接不安全？ 证书还未部署生效，等待一会儿，清除浏览器缓存再试。 Hexo部署出现错误err: Error: Spawn failed解决方式 https://blog.csdn.net/weixin_41256398/article/details/117994899 Github连接出现ssh: connect to host github.com port 22: Connection timed out 错误 ​ Github连接出现ssh: connect to host github.com port 22: Connection timed out 错误 ​ git commit、merge 如何退出git bash vim编辑器 参考资料 Easy Hexo ：包括Hexo快速开始，推荐主题，插件使用等等 Butterfly：本站使用的主题 搭建教程： https://zhuanlan.zhihu.com/p/60578464 https://blog.csdn.net/github_39655029/article/details/116485386 使用ssh连接Git仓库（Github) https://www.jianshu.com/p/20089411571d PicGo+GitHub图床搭建部分的参考 https://zhuanlan.zhihu.com/p/350598351 https://zhuanlan.zhihu.com/p/138012354 Node.js 使用淘宝 NPM 镜像的相关说明 https://www.twle.cn/l/yufei/nodejs/nodejs-basic-cnpm.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/tags/Hexo/"}]}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/categories/LeetCode/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/categories/Hexo/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"http://kaillliu.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/tags/LeetCode/"},{"name":"单调栈","slug":"单调栈","permalink":"http://kaillliu.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/tags/Hexo/"}]}