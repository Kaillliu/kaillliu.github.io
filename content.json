{"meta":{"title":"K A I","subtitle":"","description":"","author":"Kaillliu","url":"http://kaillliu.github.io","root":"/"},"pages":[{"title":"","date":"2022-03-28T10:54:00.479Z","updated":"2022-03-28T10:54:00.479Z","comments":true,"path":"manifest.json","permalink":"http://kaillliu.github.io/manifest.json","excerpt":"","text":"{\"name\":\"string\",\"short_name\":\"Junzhou\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"about","date":"2022-03-27T10:02:17.000Z","updated":"2022-03-29T05:26:19.360Z","comments":true,"path":"about/index.html","permalink":"http://kaillliu.github.io/about/index.html","excerpt":"","text":"不知道这一页该放些啥，就放个邮箱吧，有啥事可以发邮件联系我😄 邮箱：kaillliu@163.com"},{"title":"404","date":"2022-03-27T10:04:11.081Z","updated":"2022-03-27T10:04:11.081Z","comments":true,"path":"404/index.html","permalink":"http://kaillliu.github.io/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-27T09:43:43.000Z","updated":"2022-03-28T06:10:42.758Z","comments":true,"path":"categories/index.html","permalink":"http://kaillliu.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-03-27T10:13:42.000Z","updated":"2022-03-27T10:13:54.674Z","comments":true,"path":"contact/index.html","permalink":"http://kaillliu.github.io/contact/index.html","excerpt":"","text":""},{"title":"站外链接","date":"2022-03-28T06:11:16.000Z","updated":"2022-03-28T06:14:09.815Z","comments":true,"path":"link/index.html","permalink":"http://kaillliu.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-27T09:44:50.000Z","updated":"2022-03-28T06:10:24.448Z","comments":true,"path":"tags/index.html","permalink":"http://kaillliu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在VMware上安装Centos7系统","slug":"在VMware上安装Centos7系统在VMware上安装Centos7系统","date":"2022-04-19T09:18:13.000Z","updated":"2022-04-19T10:15:48.310Z","comments":true,"path":"2022/04/19/在VMware上安装Centos7系统在VMware上安装Centos7系统/","link":"","permalink":"http://kaillliu.github.io/2022/04/19/%E5%9C%A8VMware%E4%B8%8A%E5%AE%89%E8%A3%85Centos7%E7%B3%BB%E7%BB%9F%E5%9C%A8VMware%E4%B8%8A%E5%AE%89%E8%A3%85Centos7%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"前言 本地虚拟机服务器，使用CentOs7，运维环境是宝塔面板。 工具 VMware Workstation Pro 15.5.5（虚拟机） CentOs7（iso镜像） 阿里云镜像：http://mirrors.aliyun.com/centos/7/isos/x86_64/ Xshell（用于连接虚拟机，方便使用Linux命令，是一个远程工具，右键就可以复制粘贴，还可以拉滚动条。） 虚拟机vmnet8 ip 虚拟机里面的虚拟网络需要设置一下，虚拟机里面的虚拟网络需要处理一下，虚拟机里面的虚拟网络需要编辑一下。 下图标记2的地方，勾勾要去掉，去掉之后点击NAT设置，查看虚拟机的vmnet8 ip，把红框里的子网IP、子网掩码、默认网关用文本记下来，然后点击确定。 记住子网IP、子网掩码、网关 创建虚拟机 点击创建新的虚拟机。 点击自定义，下一步。 选择虚拟机版本，我这里是15.5.5，下一步 点击稍后安装操作系统，下一步。 选择Linux操作系统，现在安装的是entOs7，所以版本选择CentOs7 64位，下一步。 虚拟机名称随意，可以中文，这里我写的是服务器ip名（可以重命名的），为了方便定位，不用我说都懂的啦，从左边栏就可以看出100、101、102没有102，哎？我跳过102了？我是把流程走一遍再码字的，码字的时候，服务器已经ok了，不过问题不大，下一步。。。。 默认（本站的核心是2个，但是我100、101都是1个核心，这里默认1个核心够用了），本地服务器，也就自己一个人访问，而且这里配置是跟本机电脑配置有关的，服务器一核心足矣（只要电脑带得动，给八核我也没意见），下一步。 默认（本站的内存是1GB，但是我100、101都是2GB，这里默认1GB够用了），同上（如果在阿里云买服务器，我建议是1核心2GB内存哦），下一步。 点击使用网络地址转换(NAT)，下一步。 默认，下一步。 默认，下一步。 默认，下一步。 默认（磁盘大小自己改，20GB实际上够了，下面选项默认），下一步。 默认，下一步。 点击自定义硬件。 点击打印机，然后点击移除。 跟着数字的步骤走（步骤3：选择下载好的CentOs7镜像，我个人是推荐放在服务器根目录下，看我图中的路径，这里不明白要留言哦）。 点击完成。 安装CentOs7系统 点击开启此虚拟机。 这里说一下，默认选中的是Test this this media &amp; install CentOS 7（白色字体是选中状态），按方向键↑然后回车（如果按键没效果，需要把鼠标点一下虚拟机显示屏）。 中文在最下面，滚下去或者拉到下面才看到（下面的搜索chinese），点击继续。 这里看一下自己的日期和时间是不是亚洲/上海 时区，不是的话自己进去调一下（百度）。 点击软件选择。 把红框里的两个勾勾点上，完成。 点击安装位置。 点击我要配置分区，完成。 点击点这里自动创建他们，完成。 默认，/boot（启动文件），swap（交换分区，类似windows虚拟内存。看内存总大小，如果内存足够大，这个空间就要设置很大，如果内存小于2G，那么这个空间设置成内存的2倍大小。），/（根分区），完成。 点击接受更改。 点击网络和主机名。 打开以太网，修改主机名（也可以使用默认），然后点击应用（点完应用后看看以太网是不是关闭了，如果关闭了再点开），完成。 点击开始安装。 点击ROOT密码。 设置密码，我这里设置123456（本机的，起个好记的就好），完成（点两次）。 等待安装（根据自己的需求去创建用户吧，但是创建后可能某些操作需要root权限，不折腾就不要创了，昨晚搞CentOs8服务器差点崩溃，CentOs8是规定要创建用户的，CentOs7和CentOs8就跟windows7和windows10一样）。 安装完毕，点击重启。 选择第一个。 我的用户名是root，密码123456。 输入用户名root，回车。 输入密码123456（不可见的，输入就行了），回车。 配置服务器静态ip（需要配置服务器动态ip的自己百度一下） 打开目录：cd /etc/sysconfig/network-scripts/（复制粘贴就好，这个复制粘贴有点麻烦，找不到的就手敲，正是这样才要用Xshell工具来远程，得先配置ip，忍一忍吧），回车。 我这里显示的是ifcfg-ens33，这里要说一下，我百度过，有些是32，也有1667777，先用cd /etc/sysconfig/network-scripts/进入目录，然后ll显示列表（ls也可以显示列表，只显示列表名）。 编辑ifcfg-ens33：vi ifcfg-ens33（vi：进入编辑模式，文件名别敲错。），回车。 按 i 字母键进入编辑模式（如果不显示下图的，肯定是vi ifcfg-ens33输入错了，自己检查一下，退出vi方法：按Esc（注意左下角），输入:q!（不保存退出））。 看图 1234#虚拟机IP相同，但是IPADDR后三位在3~240之间选择IPADDR=192.168.157.103NETMASK=255.255.255.0GATEWAY=192.168.157.2 保存并退出：按Esc键，然后输入:wq（必须小写），回车。 重启网络：systemctl restart network，回车。 查看ip：ip addr， 回车。 配置本地的网络（只需要配置一次） 这是本地访问虚拟机要配置的 12#选择使用下面的IP地址,最后一位为 1 ，子网掩码自动生成IP=192.168.157.1 使用Xshell连接虚拟机服务器 新建会话，这里隧道要取消转发X11连接到： 新建会话，输入IPADDR名称192.168.157.103（输入名称后，下面的主机也是同步的。），然后点击连接。 出现这个弹窗就说明99.99%成功了，如果没有就说明本地网络配置出错 输入用户名root。 输入用户名123456。 okay。 安装宝塔面板 宝塔官网：https://www.bt.cn/ 宝塔Linux面板命令大全：https://www.bt.cn/btcode.html（一定要多看） 这里标注几个常用的命令（本文章用到的）：cd、clear（清屏，也可以用Ctrl+L）、ll（当前列表，详细的展示列表），ls（当前列表，简洁的展示列表）、vi 文件名（编辑文件，按Esc：:wq保存并退出、:q（退出）、:q!强制不保存并退出）。 安装 安装脚本：yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh PS：此脚本从官方复制过来的时间为2020年6月19日，仅限CentOs系统，如果距离已久，请到官网复制。 右键随意复制粘贴，Xshell工具的好处（佛主：https://www.kancloud.cn/jiangguowu/kfjsdkfjskd/1076752）。 DO you want to install Bt Panel tothe /www directory now?(y/n):（现在是否要将Bt面板安装到/www目录？（是/否）：）。 按y，回车。 宝塔面板访问地址：http://192.168.157.103:8888/7a81976f，119.137.3.117换成192.168.157.103自己设置的服务器ip（别傻了，只有本地才能访问）。 username: yq0g4uxd password: c937d4a9 点击一键安装（也可以不选择，然后自己去左边的软件商店自己选择安装）。 建议设置一下安全入口、面板用户、面板密码（只能设置8位数，为了方便，我强行使用命令行将密码设置为123456，命令：cd /www/server/panel &amp;&amp; python tools.py panel 123456，更多的宝塔命令请到宝塔Linux面板命令大全查看：https://www.bt.cn/btcode.html） 参考链接： 配置步骤： https://www.cnblogs.com/langting/p/13167539.html https://blog.langting.top/archives/117.html 虚拟机网络相关问题的解决 https://blog.csdn.net/weixin_44080445/article/details/110714332","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://kaillliu.github.io/categories/Web%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kaillliu.github.io/tags/Java/"},{"name":"Centos","slug":"Centos","permalink":"http://kaillliu.github.io/tags/Centos/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://kaillliu.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Linux","slug":"Linux","permalink":"http://kaillliu.github.io/tags/Linux/"}]},{"title":"设计模式总览","slug":"设计模式","date":"2022-04-12T09:27:23.000Z","updated":"2022-04-12T11:05:30.789Z","comments":true,"path":"2022/04/12/设计模式/","link":"","permalink":"http://kaillliu.github.io/2022/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"书本网盘链接😀 链接：https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye 提取码：rlye CSDN总结： https://blog.csdn.net/cooldragon/article/details/52164380 范围 创建型 结构型 行为型 类 Factory Method（工厂方法） Adapter(类)（适配器） Interpreter（解释器）Template Method（模版方法） 对象 Abstract Factory（抽象工厂）Builder（建造者）Prototype（原型）Singleton（单例） Adapter(对象)（适配器)Bridge（桥接）Composite（组合）Decorator（装饰者）Façade（外观）Flyweight（享元）Proxy（代理） Chain of Responsibility（职责链）CoMmand（命令）Iterator（迭代器）Mediator（中介者）Memento（备忘录）Observer（观察者）State（状体）Strategy（策略）Visitor（访问者）","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式笔记之Adapter（适配器）模式","slug":"设计模式笔记之Adapter（适配器）模式","date":"2022-04-02T05:36:59.000Z","updated":"2022-04-02T09:23:21.390Z","comments":true,"path":"2022/04/02/设计模式笔记之Adapter（适配器）模式/","link":"","permalink":"http://kaillliu.github.io/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BAdapter%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"书本网盘链接😀 链接：https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye 提取码：rlye Adapter（适配器）模式 意图 将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 注：适配器模式在详细设计阶段不需要考虑它，它是为了对现有系统或产品接口兼容时，也就是既成事实的情况下的补救措施。 适用性 你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 结构 类适配器模式 对象适配器模式 登场角色 **Target (目标角色 对象，要用的接口) ** 定义Client所需的方法。 **Client (使用场景 请求者) ** 与符合Target接口的对象协同，使用Target角色定义的方法进行具体处理。 **Adaptee (被适配) ** 定义一个已经存在的接角色，这个角色需要适配。 Adapter (适配器，把Adaptee接口转换为Target可用的接口) 对Adaptee的接口与Target接口进行适配 优点 可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。 增加了类的透明性 提高了类的复用度 灵活性非常好","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式笔记之Factory Method（工厂方法）模式","slug":"设计模式笔记之Factory（工厂）模式","date":"2022-04-02T05:36:59.000Z","updated":"2022-04-06T06:40:05.962Z","comments":true,"path":"2022/04/02/设计模式笔记之Factory（工厂）模式/","link":"","permalink":"http://kaillliu.github.io/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BFactory%EF%BC%88%E5%B7%A5%E5%8E%82%EF%BC%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"书本网盘链接😀 链接：https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye 提取码：rlye Factory Method（工厂方法）模式 意图 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 适用性 • 当一个类不知道它所必须创建的对象的类的时候。 • 当一个类希望由它的子类来指定它所创建的对象的时候。 • 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 结构 登场角色 Product 产品 定义工厂方法所创建的对象的接口。 Creator 创建者 声明工厂方法,该方法返回一个 Product类型的对象。 Creator也可以定义一个工厂方 法的缺省实现,它返回一个缺省的 ConcreteProduct对象。 ConcreteProduct 具体的产品 决定了具体的产品，实现Product接口。 ConcreteCreator 具体的创建者 负责生成具体的产品，重定义工厂方法以返回一个 ConcreteProduct实例。 优缺点 优点： 首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，可以使用产品子类替换产品父类。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式笔记之Iterator（迭代器）模式","slug":"设计模式笔记之Iterator（迭代器）模式","date":"2022-04-02T05:36:59.000Z","updated":"2022-04-02T09:05:50.916Z","comments":true,"path":"2022/04/02/设计模式笔记之Iterator（迭代器）模式/","link":"","permalink":"http://kaillliu.github.io/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"书本网盘链接😀 链接：https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye 提取码：rlye Iterator（迭代器）模式 意图 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，即为遍历和实现可以分离开来。 适用性 访问一个聚合对象的内容而无需暴露它的内部表示。 支持对聚合对象的多种遍历。 为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。 结构 登场角色 Iterator 迭代器 负责定义访问和遍历元素的接口（API）。 Concretelterator 具体的迭代器 负责实现Iterator角色所定义的接口（API）。 Aggregate 集合 集合定义创建Iterator角色的接口，在示例程序中，由Aggregate接口扮演此角色，里面定义了Iterator方法。 ConcreteAggregate 具体的集合 负责实现Aggregate角色所定义的接口。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式笔记之Template Method（模板方法）模式","slug":"设计模式笔记之Template（模板方法）模式","date":"2022-04-02T05:36:59.000Z","updated":"2022-04-06T06:15:54.509Z","comments":true,"path":"2022/04/02/设计模式笔记之Template（模板方法）模式/","link":"","permalink":"http://kaillliu.github.io/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BTemplate%EF%BC%88%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"书本网盘链接😀 链接：https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye 提取码：rlye Template Method（模板方法）模式 意图 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 适用性 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的 行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有 代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。 控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。 结构 登场角色 **AbstractClass(抽象类) ** 负责实现模板方法，声明在模板方法中所使用到的抽象方法。这些抽象方法由子类ConcreteClass角色负责实现。 **ConcreteClass(具体类) ** 负责具体实现AbstractClass角色中定义的抽象方法。 优点 封装不变部分，扩展可变部分 把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。在悍马模型例子中，是不是就非常容易扩展？例如增加一个H3型号的悍马模型，很容易呀，增加一个子类，实现父类的基本方法就可以了。 提取公共部分代码，便于维护 我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！ 行为由父类控制，子类实现 基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。 思考 习题3-2 123public final void diaplay()&#123; ...&#125; AbstractDisplay类中使用final 表示子类无法重写display方法。 不要重写模板方法 习题3-4 Java为什么不用接口代替抽象类？ 因为此模式下AbstractClass角色必须实现部分处理流程。接口无法实现","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Leetcode-084,085-单调栈-数组中的最大矩阵,最大矩阵","slug":"leetcode-42-数组中的最大矩形","date":"2022-03-29T13:28:00.000Z","updated":"2022-03-31T12:00:14.287Z","comments":true,"path":"2022/03/29/leetcode-42-数组中的最大矩形/","link":"","permalink":"http://kaillliu.github.io/2022/03/29/leetcode-42-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","excerpt":"","text":"题目链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ ​ ：https://leetcode-cn.com/problems/maximal-rectangle/ 84. 解法一：暴力求解 123456789101112131415161718192021222324252627//时间复杂度为o(N^2)，提交结果超时class Solution &#123; public int largestRectangleArea(int[] heights) &#123; //定义长度，返回值 int area = 0, n = heights.length; for(int i = 0; i &lt; n; i++)&#123; //确定宽 int left = i; int right = i; //确定左边 for(; left&gt;=0; left--)&#123; if(heights[left] &lt; heights[i])&#123; break; &#125; &#125; //确定右边 for(; right&lt;n; right++)&#123; if(heights[right] &lt; heights[i])&#123; break; &#125; &#125; //计算面积 area = Math.max(area,(heights[i] * (right - left -1))); &#125; return area; &#125;&#125; 解法二：单调栈，用Deque数据结构（来自评论区大佬，太妙了） 1234567891011121314151617181920212223public int largestRectangleArea(int[] heights) &#123; // 这里为了代码简便，在柱体数组的头和尾加了两个高度为 0 的柱体。 // arraycopy(源，起始，目标，目标起始，源长度) int[] tmp = new int[heights.length + 2]; System.arraycopy(heights, 0, tmp, 1, heights.length); Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); int area = 0; for (int i = 0; i &lt; tmp.length; i++) &#123; // 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」； // 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。 // i是右边界 // 因此以栈顶柱体为高的矩形的左右宽度边界就确定了，可以计算面积～ //stack.peek()获得栈顶元素，stack.pop()获取栈顶元素并删除 while (!stack.isEmpty() &amp;&amp; tmp[i] &lt; tmp[stack.peek()]) &#123; int h = tmp[stack.pop()]; area = Math.max(area, (i - stack.peek() - 1) * h); &#125; stack.push(i); &#125; return area; &#125; 85. 解法 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 思路：转化为84中的求矩阵中的最大矩形，遍历，对每一行求高 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; //85-最大矩阵 public int maximalRectangle(char[][] matrix) &#123; if(matrix.length == 0 || matrix[0].length == 0)&#123; return 0; &#125; int col = matrix.length; int row = matrix[0].length; int[] heights = new int[row]; int result = 0; //遍历行 for(int i = 0; i &lt; col; i++)&#123; //遍历列，求高 for (int j = 0; j &lt; row; j++) &#123; if(matrix[i][j] == &#x27;1&#x27;) &#123; heights[j] += 1; &#125; else &#123; heights[j] = 0; &#125; &#125; result = Math.max(result,max(heights)); &#125; return result; &#125; //84 public int max(int[] heights)&#123; int[] temp = new int[heights.length + 2]; System.arraycopy(heights, 0, temp, 1, heights.length); Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); int area = 0; for(int i = 0; i &lt; temp.length; i++)&#123; while(!stack.isEmpty() &amp;&amp; temp[i] &lt; temp[stack.peek()] )&#123; int h = temp[stack.pop()]; area = Math.max(area,(i - stack.peek() - 1) * h); &#125; stack.push(i); &#125; return area; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/categories/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kaillliu.github.io/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/tags/LeetCode/"},{"name":"单调栈","slug":"单调栈","permalink":"http://kaillliu.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"Hexo配合Github Pages搭建个人博客","slug":"HI","date":"2022-03-27T08:21:26.000Z","updated":"2022-03-29T05:05:06.146Z","comments":true,"path":"2022/03/27/HI/","link":"","permalink":"http://kaillliu.github.io/2022/03/27/HI/","excerpt":"","text":"前言 目前市面上有成熟的知识分享平台，例如CSDN、掘金等等，也可以被搜索引擎检索到。除此之外也可以自己搭建一个个人博客网站，主要使用的就是 Hexo + GitPage 的方式，本站主要使用 GitHub Page + Hexo搭建静态博客网站。 GitHub Pages 是什么？ What is GitHub Pages? - GitHub Help GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。 Hexo是什么？ 官网：hexo.io Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。 为什么使用Hexo + GitHub Pages 优点： 主要是 Hexo 完全免费，静态，轻量快速，并且可以托管在GitHub，当然也可以托管在国内的Gitee里面，但是会麻烦一点。 缺点： 在国内GitHub访问速度一般，前期搭建和发布文章有点点麻烦。 搭建步骤 安装准备 在搭建博客之前，需要确认电脑上已经安装好了 Git 和 Node.js ，然后再安装Hexo。 ​ Node.js 官网 ​ Git 官网 ​ Git 安装教程 ​ Node.js 安装教程 12# 安装Node.js之后使用国内的淘宝镜像源加速，安装之后可以用 cnpm 代替 npmnpm install -g cnpm --registry=https://registry.npm.taobao.org 链接GitHub 需要一个GitHub账号，使用邮箱注册。 配置GitHub账号 123# 配置用户名和邮箱git config --global user.name &quot;github的用户名&quot;git config --global user.email &quot;github的注册邮箱&quot; 创建SSH密钥 12# 生成 ssh 密钥ssh-keygen -t rsa -C &quot;github的注册邮箱&quot; 添加密匙： 进入 C:\\Users\\用户名\\.ssh 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。 登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。 Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。 验证连接： 打开 Git Bash，输入 ssh -T git@github.com 出现 “Are you sure……”，输入 yes 回车确认。 显示 “Hi xxx! You’ve successfully……” 即连接成功。 新建Github Pages 仓库 GitHub 主页右上角加号 -&gt; New repository： Repository name 中输入 用户名.github.io 勾选 “Initialize this repository with a README” Description 选填 填好后点击 Create repository 创建。 创建后默认自动启用 HTTPS，博客地址为：https://用户名.github.io 本地安装Hexo 新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。打开该文件夹，右键 -&gt; Git Bash Here。 安装 Hexo 使用 npm 一键安装 Hexo 博客程序： 1cnpm install -g hexo-cli Hexo 初始化和本地预览 初始化并安装所需组件： 12hexo init # 初始化cnpm install # 安装组件 完成后依次输入下面命令，启动本地服务器进行预览： 1234# hexo clean hexo g # 生成页面hexo s # 启动预览 访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功！ **Tips：**如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。 Hexo 博客文件夹目录结构如下： 部署Hexo到GitHub Pages 本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。 首先安装 hexo-deployer-git： 1cnpm install hexo-deployer-git --save 然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下： 12345# 仓库地址最好是ssh方式，也可以是http格式，可以在github仓库中查找到deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 完成后运行 hexo d 将网站上传部署到 GitHub Pages。 完成！这时访问我们的 GitHub 域名 https://用户名.github.io 就可以看到 Hexo 网站了。 绑定域名（待更新） 开始使用 发布文章 进入博客所在目录，右键打开 Git Bash Here，创建博文： 1hexo new &quot;My New Post&quot; 然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。 写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。以后每次发布文章都是这两条命令。 12hexo g # 生成页面hexo d # 部署发布 也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 hexo g 和 hexo d 发布。 12345678910111213---title: Hello World # 标题date: 2019/3/26 hh:mm:ss # 时间categories: # 分类- Diarytags: # 标签- PS3- Games---摘要&lt;!--more--&gt;正文 网站设置 包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考官方文档按需要编辑。 注意：冒号后要加一个空格！ 更换主题 在 Themes | Hexo 选择一个喜欢的主题，比如 NexT，进入网站目录打开 Git Bash Here 下载主题： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后修改 _config.yml 中的 theme 为新主题名称 next，发布。（有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。） 常用命令 12345678hexo new &quot;name&quot; # 新建文章hexo new page &quot;name&quot; # 新建页面hexo g # 生成页面hexo d # 部署hexo g -d # 生成页面并部署hexo s # 本地预览hexo clean # 清除缓存和已生成的静态文件hexo help # 帮助 PicGo + Github + CDN 搭建博客图床 创建仓库 新键一个图片仓库 填好相关信息 获取token token token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。 当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。我们通过token来确定GitHub仓库的位置。 点击setting Settings -&gt; Developer settings -&gt; Personal access tokens，最后点击 generate new token； 点击生成token 保存好生成的token(仅显示一次)，因此最好存放到备忘录里面。 下载PicGo 进入picgo官网: https://picgo.github.io/PicGo-Doc/zh/ 点击免费下载，跳转到GitHub界面，选择对应系统的版本进行安装 设置PicGo 选择GitHub图床，根据提示填写，保存图片的库可以更换，只需要把PicGo里面的仓库名对应改掉就行 在picgo设置里面可以设置上传的快捷键，此外，最好打开时间戳重命名功能，防止图片名字重复 CDN加速 CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。 在这里，我们选择了快速免费公有的CDN-jsdelivr 配置方法： 只需要在我们 PicGo 图床配置中添加如下自定义域名即可 https://cdn.jsdelivr.net/gh/用户名/仓库名 到这里，一个图床算是基本搭建好了。通过picgo上传图片，会在GitHub创建的仓库中保存。 Markdown编辑器Typora的设置（可选） Markdown 官网：https://markdown.com.cn/ Markdown是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。 markdown的优点： 专注于文字内容； 纯文本，易读易写，可以方便地纳入版本控制； 语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。 Typora ypora是一个专注于markdown语言的优秀编辑器。 官网：https://typora.io/ 打开Typora的偏好设置，设置好红色方框里面的内容，便可以在Typora里面编写文章的同时上传图片到图床了。 常见问题 设置网站图标 进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：favicon: 图标地址。（不同主题可能略有差别） 修改并部署后没有效果 使用 hexo clean 清理后重新部署。 开启 HTTPS 后访问网站显示连接不安全？ 证书还未部署生效，等待一会儿，清除浏览器缓存再试。 Hexo部署出现错误err: Error: Spawn failed解决方式 https://blog.csdn.net/weixin_41256398/article/details/117994899 Github连接出现ssh: connect to host github.com port 22: Connection timed out 错误 ​ Github连接出现ssh: connect to host github.com port 22: Connection timed out 错误 ​ git commit、merge 如何退出git bash vim编辑器 参考资料 Easy Hexo ：包括Hexo快速开始，推荐主题，插件使用等等 Butterfly：本站使用的主题 搭建教程： https://zhuanlan.zhihu.com/p/60578464 https://blog.csdn.net/github_39655029/article/details/116485386 使用ssh连接Git仓库（Github) https://www.jianshu.com/p/20089411571d PicGo+GitHub图床搭建部分的参考 https://zhuanlan.zhihu.com/p/350598351 https://zhuanlan.zhihu.com/p/138012354 Node.js 使用淘宝 NPM 镜像的相关说明 https://www.twle.cn/l/yufei/nodejs/nodejs-basic-cnpm.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/tags/Hexo/"}]}],"categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://kaillliu.github.io/categories/Web%E5%BC%80%E5%8F%91/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/categories/LeetCode/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/categories/Hexo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kaillliu.github.io/tags/Java/"},{"name":"Centos","slug":"Centos","permalink":"http://kaillliu.github.io/tags/Centos/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://kaillliu.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Linux","slug":"Linux","permalink":"http://kaillliu.github.io/tags/Linux/"},{"name":"设计模式","slug":"设计模式","permalink":"http://kaillliu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://kaillliu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://kaillliu.github.io/tags/LeetCode/"},{"name":"单调栈","slug":"单调栈","permalink":"http://kaillliu.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kaillliu.github.io/tags/Hexo/"}]}