<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM 面试题总结回顾 | K A I</title><meta name="author" content="Kaillliu"><meta name="copyright" content="Kaillliu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM 面试题总结回顾"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://kaillliu.github.io/2023/08/12/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#263238","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM 面试题总结回顾',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 12:18:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="K A I"><span class="site-name">K A I</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM 面试题总结回顾</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-12T07:00:00.000Z" title="发表于 2023-08-12 15:00:00">2023-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T04:18:35.029Z" title="更新于 2023-09-08 12:18:35">2023-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A2%98%E5%BA%93/">题库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM 面试题总结回顾"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="堆和栈有什么区别">堆和栈有什么区别?</h2>
<p>首先我们从操作系统的角度上来看,堆和栈在操作系统中的分布:</p>
<p>假设我们的地址空间是<code>0x0~0xffff</code>,那么在这个地址空间中,堆和栈的分配逻辑是不同的</p>
<ul>
<li><strong>堆的内存分配是从小地址到大地址,也就是从0x0向0xfff申请内存分配</strong></li>
<li><strong>栈的内存分配是从大地址到小地址分配,也就是0xfff向0x0申请内存分配</strong></li>
</ul>
<blockquote>
<p>然后堆和栈中间那些还没有使用的内存,就是可以被申请的</p>
</blockquote>
<p>那么栈是如何工作的呢?</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081216105.png" alt="image-20230906233358848"></p>
<p>如上图所示,假设在执行这一段函数,那么它会先将a压栈,将b压栈,然后通过操作数寄存器将a+b的结果压栈,在这个过程中,栈顶指针总是指向下一个写入的位置,这也就是说,栈顶指针指向的位置总是可以写 入的,是还没有申请空间的,然后当要使用这些变量的时候,就会通过CPU上的寄存器,比如说rbp,esp等寄存器的值,加上一个偏移量,就能够得到栈中变量的位置了</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081216106.png" alt="image-20230906233416820"></p>
<p><code>新创建的对象的死亡率高</code>,这意味着这些对象容易频繁地被回收,从而频繁的导致内存整理,而生存下来的对象因为不容易被回收,从而内存整理的频率会更低一些,为了避免在整理内存的过程中,去导致那些存活下来的对象因为新创建的对象的内存整理而频繁移动,因此一个好的办法就是设置一个分区,将对象的存活情况作为指标,界定这些对象应该要放在哪个区域中,从而使得内存整理频率高的分区,能够快速执行内存整理,而不需要惊动那些不需要进行频繁回收的对象</p>
<p>那么这种机制就是一种分代的机制,它将对象分成了若干个分区</p>
<ul>
<li>
<p>新创建的对象被分配到<code>新生代</code>、<code>伊甸园区</code>,这个区域中的对象不是很长命,因此会涉及到频繁的内存整理,因为这个分区中的对象比较短命,因此通常来说他们的内存整理效率比较高</p>
</li>
<li>
<p>而那些长命的对象所在的对象的内存整理频率不高,因此说没必要将长命对象和短命对象放在一起,短命对象被回收,移动的是整个内存区域中的对象,如果把他们放在一起,那么就会导致长命的也跟着一起移动</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081216107.png" alt="image-20230906233429132"></p>
</li>
<li>
<p>如图所示,Java会将新建的对象放入到<code>Eden</code>中,当<code>Eden</code>中触发<code>MinorGC</code>的时候,它此时并不会直接在<code>Eden</code>执行整理,而是将当前的对象复制到<code>Survivor</code>中,</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:SurvivorRatio=8(默认)`,也就说`Eden:Survior = 8 :1</span><br></pre></td></tr></table></figure>
<p><strong>那么Survior的对象去哪里呢?</strong></p>
<p>它会进入到一个称为是老年代的地方,那么如何才能进入到老年代呢?这设计到分代分配和分代回收的机制,详细描述一下这个流程:</p>
<p>首先对象新建之后,就会被分配到<code>Eden</code>,然后当<code>Eden</code>满的时候,就会将对象复制到<code>Survivor0</code>上,此时每次<code>Eden</code>满都会复制到<code>Survior0</code>上,然后当<code>Survivor0</code>满的时候,就会对<code>Survivor0</code>上的对象进行清除,然后将<code>Survivor0</code>上的存活对象复制到<code>Survivor1</code>上,在这个过程就会对存活的对象的头部中的<code>age+1</code>,最终实现了一个老年代的晋升</p>
<p><strong>Java的堆分成哪些部分?</strong></p>
<p>从对象的角度来讲,对象的实例数据是存储在堆中的,为了提高内存分配/回收的效率,不同的虚拟机对堆存储的数据有不同的规定,比如说HotSpot中原来是将对象的元数据,比如说类信息,CodeCache都存储在堆中的永久代分区中,但是在后面使用了元空间,将这个空间从堆中抽离出来了</p>
<p>HotSpot为了提高内存的分配/回收效率,那么它堆的内存分成了以下这几个部分</p>
<ul>
<li><code>Eden区</code>:当对象被新建的时候,就会将这个对象分配到这个区域上</li>
<li><code>S1/S0区</code>:当<code>Eden</code>发生GC的时候,就会将存活的对象复制到<code>S1/S0</code>上,当一个区<code>(S0/S1)</code>发生的时候,就会将对象来回复制,每复制一次,就会使得对象头部的分代年龄字段+1,最终达到一个阈值之后就会晋升到老年代</li>
<li><code>老年代</code>:存储的是比较稳定的对象,只有当老年代的空间不足的时候才会触发GC</li>
</ul>
<h2 id="常见的垃圾收集器">常见的垃圾收集器</h2>
<p><strong>Serial Collector(串行垃圾收集器)</strong></p>
<p>它是一个单线程的垃圾收集器,具体的执行流程:</p>
<p>当触发GC的时候,首先执行<code>Mark</code>,就会触发一个<code>STW</code>,然后基于<code>根追踪+双色标记法</code>来判断对象的存活情况,假设黑色是存活的,白色的是不可达的对象,然后在<code>STW</code>期间就会将白色的对象给<code>sweep</code>掉</p>
<blockquote>
<p>为什么串行收集器不使用三色标记法？</p>
</blockquote>
<p>这是因为串行收集器的<code>Mark&amp;&amp;sweep</code>是一个原子性的动作,也就是说中间不会产生<code>Mutation</code>,因此这样的话就不会出现三色标记法中引入的那个<code>不确定标记</code>,只需要在STW期间完成<code>Mark&amp;&amp;sweep</code>即可</p>
<p>使用场景是:</p>
<ol>
<li>吞吐量小,内存回收工作量不大</li>
<li>容忍延迟,不在意卡顿</li>
<li>单核,内存小:0~100M</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialIGC</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并行垃圾收集器</p>
</blockquote>
<p>并行垃圾收集器是串行垃圾收集器的升级版,它的升级主要体现在它支持多线程垃圾回收,它尽最大努力提供最大的吞吐量,它的执行流程:首先当遇到GC的时候,就会直接触发STW,然后在STW期间完成<code>Mark&amp;Sweep</code>的操作,那么它的吞吐量是要高于串行的吞吐量的,因为在多核环境下,两个线程来处理GC任务要更快一些</p>
<p>它的使用场景是吞吐量的要求要高于延迟的要求的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParalleIGC</span><br></pre></td></tr></table></figure>
<blockquote>
<p>并发标记收集垃圾收集器(CMS)</p>
</blockquote>
<p>这个垃圾收集器优化的宗旨主要是将STW的时间降到最低,<code>Mark</code>的阶段并不是<code>STW</code>的,从而提高了吞吐量,当所有的<code>Mark</code>操作完成了之后,才会执行<code>Sweep Compact Copy</code>,具体的执行流程:</p>
<p>(1)初始标记过程,相当于一个初始化,仅标记一下GCRoots能够直接关联的对象,并且将这些对象加入到不确定状态的集合(灰色集合),</p>
<p>(2)并发标记过程,执行三色标记算法,具体的过程就是:从灰色集合中取出元素,然后将这个元素标记为黑色(原本灰色),然后将取出的元素相连的白色元素放入到灰色集合中,反复这个过程,直到所有元素都被遍历过了一次</p>
<p>(3)remark阶段,由于在标记和<code>mark</code>之间存在一个<code>mutation</code>,因此为了避免诸如在之前标记好的要删除的元素突然产生了关联,因此在这个过程,就要执行remark,这个过程相对来说比较短,为了保证程序的正确性,因此使用了STW,暂停其他线程,然后遍历对象,如果对象有灰色的,那么就继续扫描它的子节点。</p>
<p>(4)在STW的状态下,将标记过的对象删除</p>
<blockquote>
<p>问题:在Mark期间发生了修改,到底是如何操作的?</p>
</blockquote>
<p><strong>条件1：</strong> 白色节点被黑色节点引用(白色节点被挂在了黑色节点下，须知黑色节点是不会重新扫描的)</p>
<p><strong>条件2：</strong> 灰色节点和可达关系的白色对象之间的应用遭到了破坏(删除灰白引用)</p>
<p><strong>增量更新</strong>：所谓的增量就是在并发标记过程中,把复制的这种新增的引用,用一个集合存起来,在重新标记的时候,就会找到集合中的引用,然后重新去扫描,将源头标记为灰色</p>
<p><strong>写屏障</strong>:写屏障是增量更新的实现基础,写屏障具体来说就是在赋值操作的前面加一个方法,赋值的后面做一些操作</p>
<blockquote>
<p>跨带引用会带来什么问题?</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081216108.png" alt="image-20230906233439575"></p>
</blockquote>
<p>比如说我们要对年轻代进行GC,可以断定NSPQ都是存活的,因此可以标记,如果我们不对老年代中的对象进行分析的话,就不知道年轻代的对象V还有被老年代引用的,因此可以看出,当存在跨代引用的时候,需要对其他分区的对象也进行检索,然而为了新生代的GC而去全局遍历老年代,这种做法的效率是很低的,为了避免这种老年代的性能开销,通常的分代垃圾回收期会引入一种记忆集的技术,简单来说,记忆集就是同来记录跨代引用的表</p>
<p>在拥有记忆集的情况下,我们就可以知道年轻代中的哪些对象存在跨带引用了</p>
<blockquote>
<p>在分代GC下的GC分类</p>
</blockquote>
<p><strong>MinorGC</strong>:当新生代无法分配更多的JVM内存了,那么就会触发<code>MinorGC</code>,这个GC会把新生代中的对象进行一次标记,<strong>问题:假设这个新生代的要被回收了,而且老年代中有一个对象,仅有这个新生代对象的引用?这时候要不要回收老年代中的这个对象?</strong></p>
<p><strong>MajorGC</strong>:老年代的垃圾回收</p>
<p><strong>FullGC</strong>:<code>MinorGC</code>和<code>MajorGC</code>同时发生</p>
<blockquote>
<p>什么是浮动垃圾?</p>
</blockquote>
<p>在一次周期有一些垃圾本来要被回收的,但是在本次标记失败了,只能在下一个周期中删除这些垃圾</p>
<blockquote>
<p>G1垃圾收集器</p>
</blockquote>
<p>它的目标是解决大内存的问题,主要的解决思路就是将大内存,也就是原本的伊甸园区/S区/老年代的这些大内存区域,将这些区域再次划分成一个个的小区域,那么就彻底了解决大内存的问题,每次执行垃圾回收,只需要使用一个线程去扫描这一个个小的区域,就能够完成垃圾回收了。</p>
<p>执行流程:</p>
<p>但是比较复杂,里面的对象还有一些引用的关系,比如说一个小区域引用了另外一个小区域中的对象,一个小区域引用了另外一个大区域中的对象</p>
<ul>
<li>解释一下常见的垃圾收集器,以及区别在哪里</li>
<li>如果对延迟要求高,可以考虑哪种GC,优先考虑ZGC,CMS等</li>
<li>内存空间很大的情况下推荐哪种GC?考虑G1</li>
</ul>
<blockquote>
<p>ZGC收集器</p>
</blockquote>
<p>这个收集器的特点是对延迟的容忍度很低,它的最大延迟只能是几个ms,暂停的时间不会随着堆带下,存活的对象数目的增加而增加,通常来说内存大小的适应度约是8MB~16TB</p>
<h2 id="JVM调试工具实操">JVM调试工具实操</h2>
<p><strong>JMeter</strong>:测量性能,一般可以用来做QPS,压力测试等</p>
<p>线程组:</p>
<p><code>Ramp-up</code>:意思说在几秒内到达线程总数</p>
<p><code>Loop Count</code>:每个用户的请求次数</p>
<p>采样器:可以增加参数等</p>
<p>监听器:<code>Graph Result</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocker</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocker</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">//它本质上就是一个文件,这个文件中存储了所有客户端的连接描述符也就是Client fd</span></span><br><span class="line"><span class="comment">//所有连接过来的连接都被存储在了这个文件中了</span></span><br></pre></td></tr></table></figure>
<p><strong>jps</strong></p>
<p>可以通过<code>jps</code>来查看当前系统的Java进程,如何实现远程监控?</p>
<p><code>jstatd 2 &gt; &amp;1 &gt; log.txt &amp;</code>在后台运行,在后台运行的守护进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps 192.168.132.128</span><br></pre></td></tr></table></figure>
<p>可以通过<code>shell</code>脚本,提前输入各个节点的IP地址,如何执行定时的监控</p>
<p><strong>jstat</strong></p>
<p><code>JVM统计监控工具</code>,一般来说可以看GC的维度,class的维度,可以使用gcutils来查看相关的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil PID</span><br></pre></td></tr></table></figure>
<p><code>YGC</code>:产生YGC的次数</p>
<p><code>YGCT</code>:YGC所消耗的时间</p>
<p><code>FGC</code>:产生FullGC的次数</p>
<p><code>FGCT</code>:FullGC消耗的时间</p>
<p><code>CCS</code>:压缩的类,这是说在64位的机器上,因为不需要使用过大的空间来存储这个类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jcmd PID GC.heap_info</span><br><span class="line"><span class="comment"># 可以看到具体的GC内容,比如说每个分区的使用情况</span></span><br><span class="line"><span class="comment"># committed:JVM进程真实使用的内存</span></span><br><span class="line"><span class="comment"># reverved:JVM进程预定的内存大小,类似于一个虚拟内存,在具体使用的时候才申请</span></span><br><span class="line"><span class="comment"># 堆的内存是真实使用的,而不是预定的虚拟内存空间</span></span><br></pre></td></tr></table></figure>
<p><strong>jmap PID</strong></p>
<ul>
<li>dump:整个Java进程的内存情况</li>
<li>clstats:打印类加载器的信息</li>
</ul>
<p><strong>jhat dump之后的文件</strong></p>
<p><strong>jinfo</strong>:查看和修改虚拟机的配置,可以远程操作,它可以避免Java进程的重启而直接修改,注意并不是所有的参数都能够实时更改</p>
<p><strong>jstack</strong>:打印Java的Stack,远程调试就是基于这个工具实现的</p>
<p><strong>jconsole</strong>:图形界面,然后选择进程,是一个实时的监控,实际上是基于其他工具的具体数据来实现的</p>
<h2 id="字节码实战">字节码实战</h2>
<ul>
<li>将<code>.java</code>文件编译为<code>.class</code>文件,这个过程中,<code>.class</code>文件还是存在磁盘上的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac A.java</span><br></pre></td></tr></table></figure>
<ul>
<li>反汇编指令查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c A.class &gt;&gt; A.txt</span><br></pre></td></tr></table></figure>
<p>指令一般来说按照功能可以分为</p>
<ul>
<li>
<pre><code>invoke(调用函数)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - invokespecial:调用构造函数,如super(),init(),private</span><br><span class="line">  - invokedynamic,临时生成的程序,`duck typing`</span><br><span class="line">  - invokestatic</span><br><span class="line">  - invokevirtual:虚函数,可以重写的函数,除了static、private、final修饰之外的方法</span><br><span class="line">  - invokeinterface</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  load(将参数压栈)</span><br></pre></td></tr></table></figure>

,将某个对象压入栈中

- load variable =&gt; stack
- getXXX

</code></pre>
</li>
<li>
<p><code>store(存储)</code>=&gt;<code>ref =&gt; local variable</code>,比如说将已知的值写入到其他地方上</p>
</li>
<li>
<p><code>计算</code> =&gt; <code>add/mul/div/sub</code></p>
</li>
<li>
<p><code>跳转指令</code> =&gt; <code>jsr/jsr_w</code></p>
</li>
</ul>
<h2 id="Java对象在内存中的结构">Java对象在内存中的结构</h2>
<blockquote>
<p>Object是如何初始化的(生命周期)</p>
</blockquote>
<p>(1)<code>类加载</code>:初始化的过程,首先会先将<code>.java</code>文件通过<code>javac</code>指令编译成<code>.class</code>文件,注意此时<code>.class</code>文件还是在磁盘上的,然后经过<code>ClassLoader</code>就会将<code>.class</code>中的内容转换为<code>bytecode</code>,存储到磁盘中。此时类因为是首次加载的,因此就会执行<code>static静态代码块</code>,那么为什么会触发初始化呢?这是因为有线程<code>new/访问静态成员/loader加载</code>这些类了,就会导致初始化,但是这些类在被初始化过一次之后,就不会再执行初始化了,经过这个状态之后就是一个<strong>loaded</strong>了</p>
<p>这个过程是线程安全的吗?是线程安全的,这个过程是基于单线程来完成的</p>
<p>(2)<code>对象的创建过程</code>,第一步,读取类信息,通过类信息确定要给对象分配多大的内存空间,也就是<strong>申请内存空间</strong>,第二步,执行构造函数,也就是一个<code>&lt;init&gt;</code>,注意,在Java中是允许部分初始化的这种情况出现的,经过这个过程就是一个<strong>create</strong>了</p>
<p>这个过程是线程安全的吗?不是线程安全的,它允许部分初始化,也就是说它允许一种情况,就是提前将引用返回了,但是初始化工作没有完成</p>
<p>(3)<code>对象使用中</code>,在生命周期中是这样的<code>被使用=&gt;不可见=&gt;不可达</code></p>
<ul>
<li>被使用:就是通过规定的<code>RootSet</code>就可以找到这个对象,而且这个对象是真真切切的被使用了的</li>
<li>泄漏:就是通过<code>RootSet</code>可以找到,但是没有被使用</li>
<li>不可达:通过<code>RootSet</code>不可以找到</li>
</ul>
<p>(4)<code>对象被回收</code>,<code>标记=&gt;执行finalize=&gt;回收内存空间</code>,这一步的具体过程与垃圾回收算法有关</p>
<blockquote>
<p>Object在内存中是如何存储的</p>
</blockquote>
<p>在HotSpot的Object的格式如下:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Mark Word(ObjectHeader)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">klassOop(ObjectHeader)普通对象指针</td>
</tr>
<tr>
<td style="text-align:left">arraylength(ObjecterHeader),数组特有的字段</td>
</tr>
<tr>
<td style="text-align:left">实例数据(Instance data)</td>
</tr>
<tr>
<td style="text-align:left">padding</td>
</tr>
</tbody>
</table>
<p><strong>MarkWord</strong></p>
<ul>
<li>
<p><code>hashcode</code>:对象的hashcode</p>
</li>
<li>
<p><code>age</code>:分代年龄</p>
</li>
<li>
<pre><code>标志位(3bit)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - unlocked(无锁)</span><br><span class="line">  - light-weight-locked(轻量级锁)</span><br><span class="line">  - heavy-weight-locked(重量级锁)</span><br><span class="line">  - marked for gc(标记了GC)</span><br><span class="line">  - biased(偏向锁)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Lock Record Address</span><br></pre></td></tr></table></figure>

- 轻量级锁(指向栈中的锁记录)
- 检查MarkWord是否指向当前线程的栈

</code></pre>
</li>
<li>
<p><code>Monitor Address</code></p>
</li>
<li>
<p><code>Forwarding Address</code>:gc自己使用,在gc遍历的时候可以用这个</p>
</li>
</ul>
<p><strong>kclass</strong>:类信息指针</p>
<p><strong>padding</strong>:将对象补齐为8个字节的倍数</p>
<p>总结:</p>
<ul>
<li>它有严格的定义</li>
<li>不同的虚拟机可能会不同</li>
<li>分成头部和数据,可能还有padding</li>
</ul>
<p><strong>空Object有多大?</strong></p>
<p>16个字节。在64位下,MarkWord有8个Byte,kclassPointer有8个Byte,因此一共是16</p>
<h2 id="ClassLoader是什么">ClassLoader是什么</h2>
<p><code>ClassLoader</code>是一个运行时组件,它能够将<code>.class</code>文件(磁盘)转成<code>bytecode</code>(内存),然后在运行时将<code>bytecode</code>交给执行引擎进行存储</p>
<p>那么在这个过程中,<code>ClassLoader</code>充当一个加载器的角色,也就是将<code>.class</code>文件转换为在执行过程需要用到的<code>bytecode</code></p>
<blockquote>
<p>只有一个ClassLoader够不够用?</p>
</blockquote>
<p>首先要了解这个问题,<code>.class</code>的来源是多样的,也就是说可以来源于本地文件,可以来源于内存,来源于网络,来源于其他jar包,正是因为这些<code>.class</code>文件的来源多样,那么就意味着处理这些文件可能具有不同的策略</p>
<ul>
<li>不一样的缓存策略:比如说要将<code>.class</code>文件存储在哪里?如果在磁盘上怎么处理,如果在网卡的缓冲区中,怎么处理,如果想要从本地文件中读取<code>.class</code>,那么直接打开IO流即可,如果想要从远程读取<code>.class</code>,那么可能还要建立一个<code>TCP/Socket</code>来进行文件的传输</li>
<li>不一样的安全策略:比如说在第三方的jar包中,开发者不希望使用者看到里面的实现细节,那么如何来实现呢?</li>
<li>不一样的统计策略:这个范围比较广泛,主要说的是在加载不同来源的<code>.class</code>的统计逻辑可能是不一样的</li>
<li>不一样的代理策略:就是说类中的特定字段信息,可以被classLoader进行修改,比如说,在某段字节码之前,夹带私货,在那之前添加一段代码</li>
</ul>
<p><strong>软件设计到遇到多样化的需求的时候,怎么办?</strong></p>
<p>考虑继承、封装、组合,比如说<code>I/O Stream</code>,<code>I/O</code>本质上就是从流中读取字节,但是为了适应不同的需求,比如说从文件中读取,从远程网络读取,读取字符等这些需求,JDK基于<code>I/O Stream</code>实现了不同的流,然后通过这些不同的流来执行相关的代码</p>
<p><strong>版本问题</strong></p>
<p>问题:比如说有一个类A1.0版本依赖了JDK1.7的HashMap,然后类1.1依赖了JDK1.8的HashMap,那么在使用的时候,它的解决思路可以是这样的:就是类A1.0使用一个Loader,由这个Loader去完成类A1.0所需要所有类的加载,然后类1.1也使用一个Loader,然后由这个Loader去完成类1.1所有的类的加载</p>
<p>这样做的好处是边界会很清晰,也就是说能够确保一个Loader中加载类不会和第二个Loaer加载的类冲突掉</p>
<p>但是有个缺点就是相同的类会导致多次加载</p>
<p>在这种情况下,提出了一种树状的<code>Loader</code>,也就是设计一个顶级<code>Loader</code>,然后其他的<code>Loader</code>都基于这个<code>Loader</code>实现基础类的加载</p>
<p>如下图所示,在这个基础上实现不同的<code>ClassLoader</code>之间的依赖传递,这个设计让Foo和Bar之间是不可见的,但是它可以让<code>ClassLoader</code>中的东西可见,<code>Bar</code>也可以让这个<code>ClassLoader</code>中的东西可见</p>
<p>简单来说,就是对于一些通用的类,交给它的父级Loader去加载,设置为可见的</p>
<p>加载之后,会在<code>ClassLoader</code>内部中设置一个缓存,代表这个类已经被加载过了</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081216109.png" alt="image-20230906233712924"></p>
<blockquote>
<p>Java类加载模型?</p>
</blockquote>
<p><strong>树状关系</strong></p>
<ul>
<li>Root Class Loader</li>
<li>Left Class Loader(边缘加载器,比如说加载第三方的jar包等)</li>
</ul>
<p><strong>委托模型</strong></p>
<ul>
<li>子Class Loader委托父Class Loader完成工作</li>
<li>缓存设置在父节点</li>
</ul>
<p><strong>ClassLoader</strong></p>
<ul>
<li>BootStrap Class Loader:加载Java的核心类,比如说JDK中的类</li>
<li>Extensions Class Loader:例如JRE目录下的lib/ext</li>
<li>Application Class Loader:classpth</li>
<li>Custom Class Loader:用户自定义</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081216110.png" alt="image-20230906233528521"></p>
<p>简单来说,<strong>双亲委派模型</strong>可以用下面的实例来进行理解</p>
<p>假设用户指定了一个类加载器,然后试图加载一个类,那么首先用户类加载器会检查自己是否已经加载过了这个类,如果已经加载过了,那么就直接返回加载成功。</p>
<p>如果没有加载过,那么就会价交给系统类加载器,这个加载器会检查自己是否已经加载过了这个类,如果没有加载,那么继续传递依赖上去,直到到达根加载器</p>
<p>然后根加载器就会试图加载这个类,如果根加载失败了,那么就会向下传递任务,直到加载成功或者抛出异常</p>
<h2 id="如何来打破双亲委派模型">如何来打破双亲委派模型</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="string">&quot;hello.go&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//自己生成一个类</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(<span class="string">&quot;hello&quot;</span>,<span class="keyword">new</span> <span class="title class_">byte</span>[],<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义<code>Loader</code>,并且重写<code>findClass()</code></p>
<h1>JVM</h1>
<h2 id="对运行时数据区的理解">对运行时数据区的理解</h2>
<p>对运行时数据区的理解,重点是要放在运行时这个字眼进行理解,由于各个虚拟机之间的实现不同,这里我以最熟悉的<code>HotSpot</code>虚拟机作为一个切入点进行理解</p>
<p>假设JVM进程在运行过程中,执行了一条语句<code>new A()</code>,假设A从来没有被加载过:</p>
<ul>
<li>首先是将<code>A.java</code>文件编译为<code>A.class</code>文件,此时<code>.class</code>文件存储在磁盘上</li>
<li>接着就是<code>.class</code>文件<code>ClassLoadSystem</code>转换为<code>byteCode</code>,然后存储到内存中,注意这个<code>bytecode</code>其实就是机器能够执行运行的机器码,又称为<code>opCode</code>,这个<code>byteCode</code>会被存储到JVM进程中的一个称为<code>元空间</code>的区域</li>
<li>接着完成对象的初始化,此时一般来说会完成两件事情,完成对象A()的初始化<code>①根据对象A的类信息为对象A分配内存②执行构造函数,注意,此时有可能有一种情况,就是说有可能提前返回这个对象的内存引用地址,而此时的构造函数并没有完成</code>,在调用<code>new A()</code>的栈上分配一个引用,这个引用就是实际对象在堆上的地址</li>
<li>上面这个过程涉及到两个区域,第一个区域是调用函数所使用的虚拟机栈,第二个区域就是分配对象内存的堆区域,虚拟机栈区域是私有的,每个线程都有一个自己的栈,这样做的意义是在上下文切换调度的时候,防止各个线程之间互相篡改栈中的数据</li>
<li>接着构造完毕对象后,之前的虚拟机栈就会继续执行,执行过程需要依赖程序计数器,这个程序计数器记录的是下一条指令的地址</li>
<li>注意,Java语言它本身并没有执行程序的权限,也就是说它无法直接使用CPU的资源,而是通过操作系统给出的系统调用函数,通过系统调用函数来执行相关的程序,那么底层的程序在运行也是需要一定的内存区域的,这各区域就称之为<code>本地方法区</code>,也就叫做Nativa Memory,在这个区域中存储了有C/C++语言的堆或者栈</li>
<li>直接内存区域:这个区域比较特殊,通常用来高速传输数据,减少拷贝次数,比如说在Java通过<code>Socket</code>完成数据的传输,那么在这个过程中,网卡缓冲区中的数据通常会通过<code>DMA</code>设备,不需要CPU的干预,通过窃取总线周期,将数据传送到操作系统内核缓冲区中,然后当JVM进程需要使用这个内存的时候,它会有一个映射指针,通过这个指针就能够直接访问到这个内存了</li>
</ul>
<p><strong>堆和栈的本质区别</strong></p>
<p><code>栈</code>是辅助程序执行不可或缺的工具,它的功能主要有:</p>
<p>(1)作为函数执行的备忘录(局部变量表),在函数执行过程中,通常会有大量的变量,当需要使用这些变量的时候,就会将这些变量压栈,然后通过<code>rbp</code>、<code>esp</code>等CPU寄存器的值来存储栈顶指针,然后通过这个指针来获取相关的值,比如说有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a+b;</span><br></pre></td></tr></table></figure>
<p>这时候就可以看到栈中就有5 3 2 这样顺序压下来的栈了</p>
<p>(2)作为函数执行的活动记录,栈中有一个很重要的概念是<code>栈帧</code>,通过栈帧,记录一次函数执行的过程,比如说在即将调用一次函数的时候,首先会将函数返回地址压栈,接着申请一块空间为返回值留空间,在函数执行完毕后就会将返回地址弹出,作为<code>jmp</code>的操作数了</p>
<p>从上面可以看出,栈是用来辅助函数执行用的,没有栈,函数就无法运行,而函数脱离了堆实际上也是可以运行的,但是通常我们会有需求说要<code>让线程可以共享一块区域</code>,那么这一块区域就是堆内存了</p>
<h2 id="方法区和永久代的关系">方法区和永久代的关系</h2>
<p>首先要说的是什么是方法区,在一个<code>.class</code>文件<code>ClassLoader</code>加载之后,这个<code>.class</code>中的信息,例如类名,方法名,字段信息,静态变量、以及JIT编译器编译后产生的OpCode等信息都需要被存储到一个全局可见的位置,这个位置就是方法区</p>
<p>那么在虚拟机规范中,方法区它是一个概念,具体的实现是交给了具体的虚拟机,以HotSpot为例,它的实现有方法区和元空间,它会将解析后的信息存储到元空间/永久代中</p>
<p><strong>问题:为什么要将永久代替换为元空间?</strong></p>
<p>这和堆内存通过年龄分代进行划分的道理是一样的,在过去,如果触发了老年代的垃圾回收,那么也就会触发永久代的垃圾回收,由于永久代中的对象的生命周期远远长于老年代的生命周期,如果每次触发老年代的GC都回去遍历永久代的情况,那么就会极大的降低效率,从这个角度来说:</p>
<p>(1)为了提高GC的效率,根据对象数据的生命周期,更能够能体现分代机制的优势</p>
<p>(2)对于一些常量,这些常量通常来说不会被GC,没有必要将其纳入堆中,受堆的管控</p>
<p>(3)对于一些例如字符串这样的对象,由于会被大量使用,因此最好定期做GC</p>
<p><strong>如何调整元空间的大小?</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX : MaxMetaspacesize:设置最大的元空间的大小</span><br></pre></td></tr></table></figure>
<h2 id="JVM常量池">JVM常量池</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量池 == Class常量池`,`.java文件被编译成.class`文件,Class文件除了包含类的版本,字段,方法,接口等描述信息之外,还有一项就是常量池,常量池是当`Class`文件被Java虚拟机加载进来后放在方法区各种`字面量`和`符号引用</span><br></pre></td></tr></table></figure>
<ul>
<li>字面量:Java语言层面常量的概念,可以理解为魔法值,比如说1(基本数据类型的值),”haha”(文本字符串),声明为<code>final</code>的常量值</li>
<li>符号引用:类的结构和完全限定名,类符号引用,字段符号引用,方法符号引用,接口方法的引用</li>
</ul>
<blockquote>
<p>运行时常量池是什么?</p>
</blockquote>
<p><code>运行时常量池</code>是方法区中的一部分,运行时常量池是当<code>.class</code>文件被加载到内存后,Java虚拟机会将<code>Class</code>文件常量池中的内容转移到运行时常量池中<code>(运行时常量也是每个类都有一个)</code>,在程序的执行过程中,如果产生了常量,那么就有可能将文件常量池中的值放入到运行时常量池</p>
<blockquote>
<p>什么是字符串常量池?</p>
</blockquote>
<p><code>字符串常量池</code>又被称为是字符串池,<code>String Pool</code>,JVM为了提升性能和减少内存的开销,避免字符串的重复创建,维护了一块特殊的内存空间,这个空间由String类来进行维护</p>
<p>说说原理吧,由于Java底层实际上是C++,因此它的底层是一个叫做<code>stringTable.cpp</code>的东西,这个东西其实就是一个<code>HashSet</code>,这个<code>stringTable</code>保存的是这个字符串对象的引用,这个引用是一个指针,指向的是堆中的字符串对象，<code>JDK1.8版本的字符串常量池中存储的是字符串对象以及字符串常量值</code></p>
<p><strong>在JDK1.7之前,字符串常量放在永久代中,在1.7之后,字符串常量和静态变量被移动到了堆中</strong></p>
<p>为什么?这是因为永久代<code>(方法区)</code>的GC回收效率太低了,只有在整堆收集的才会被执行GC,而Java的字符串通常来说也是朝生夕灭的,将这些对象放在堆中,才能被GC执行引擎管辖,否则的话就会在内存中堆积大量没有使用的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s1 == s2?</span><br></pre></td></tr></table></figure>
<p>结论:它输出的是<code>true</code>,采用字面值创建一个字符串的时候,JVM首先去字符串池中查找是否有<code>abc</code>这个对象,如果没有这个对象,那么就会在字符串池中缓存这个<code>abc</code>对象,然后将这个<code>abc</code>的引用对象返回给s1</p>
<p>接着s2的赋值也是如此,它首先回去字符串串池中查找是否有<code>abc</code>这个对象,如果有,那么就直接返回这个引用</p>
<p>由于引用地址相同,因此直接返回<code>true</code>,那么创建了几个对象呢?创建了一个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1 == s2?</span><br></pre></td></tr></table></figure>
<p>结论:首先我们记住,使用new,会在堆上产生一个新的字符串对象</p>
<p>首先第一句,JVM首先会去字符串常量池中看有没有<code>abc</code>这个对象,如果没有则生成并且缓存,否则啥也不干,然后在堆上生成一个值为<code>abc</code>的对象,然后执行第二句,也是在堆上生成一个值为<code>abc</code>的对象</p>
<p>总之,生成了三个对象</p>
<p><strong>关于intern()方法</strong></p>
<p><code>一个初始化为空的字符串池</code>,它由String类独自维护,当调用<code>intern()</code>的时候,如果池中已经包含了一个等于此String对象的字符串的时候,那么就直接返回池中的字符串,否则就将这个String添加到池中,然后返回这个池中的对象的引用</p>
<h2 id="Java对象的创建过程">Java对象的创建过程</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">A</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br></pre></td></tr></table></figure>
<p>执行这两条语句,会发生什么?</p>
<p><strong>执行第一条语句</strong></p>
<p>这是类A被第一次加载到JVM中,要执行下面的流程</p>
<p>(1)类加载流程:当虚拟机遇到一条new指令后,首先会先去检查这个指令的参数是否能够在常量池中定位这个符号的引用,如果缺失了,那么就会触发类的加载流程</p>
<p>(2)对象的内存分配,对象的内存分配通常来说会有两种风格,指针碰撞风格和空闲列表风格</p>
<ul>
<li>指针碰撞风格:常见于堆内存被划分为了规整的区域,这种分配方式会保存一个边界指针,这个边界指针指向了还没有分配的区域和已经分配的区域的边界,每次只要指针向后边移动相关的内存偏移即可,通常用于标记-整理算法</li>
<li>空闲列表风格:常见于堆内存不规整的情况,这种分配方式会保存一个空闲分区表,它会将一个空闲分配分区保存到一个链表中,然后当需要分配内存的时候,就将遍历这个链表,然后基于一定的算法来选择出最佳的空闲分区</li>
</ul>
<p><strong>内存分配是线程安全的吗?</strong></p>
<p>不是,内存分配是多个线程可以同时操作的,并且操作的是每个线程都可见的堆内存区域,JVM在执行这个的时候并没有加锁,而是基于预分配+CAS来实现的</p>
<ul>
<li>预分配TLAB:通过这个TLAB,每个线程都会有自己的一块空间,其他线程无法访问这个TLAB,这样的话在内存大小许可的情况下,就可以一直在这里面分配内存了,只有当内存不足的时候,才会申请其他空间</li>
<li><code>CAS+重试</code>:通过CAS轮询内存区域是否被分配,如果被分配了就重试</li>
</ul>
<p>(3)初始化零值:这个过程就是将对象所得到的内存空间都初始化为0,这一步保证了对象的实例字段在Java代码中不赋值就可以直接使用,程序能够访问到这些字段的数据类型所对应的零值</p>
<p>(4)设置对象头:就是设置<code>Object head</code>,包括有<code>Mark word</code>、<code>hashcode</code>、<code>array_length</code>、<code>age</code></p>
<p>(5)执行方法:执行构造方法</p>
<p><strong>执行第二条语句</strong></p>
<p>(1)发现类已经被加载过了,于是跳过<code>.class</code>的加载</p>
<p>同(2)-(4)</p>
<h2 id="对象访问定位的两种方式-有什么优缺点">对象访问定位的两种方式?有什么优缺点?</h2>
<p><code>句柄模式</code>:是这样描述的,引用指向的是句柄池中的一个句柄,这个句柄包含有一个实际对象在堆中的指针,还有一个对象的类型的指针</p>
<p><code>直接指针模式</code>:是这样描述的,引用指向的就是堆中的实际对象,然后再通过这个实际对象的头部的类信息字段去找到具体的类信息</p>
<p>这两种对象的访问方式各有优势,由于在发生GC的时候,有可能会发生对象的移动,在这个过程中,那么直接指针模式,就需要修改每一个栈上引用的引用地址,这将会带来性能的下降</p>
<p>句柄模式的最大优点就是句柄的地址是稳定的,当对象被移动的时候,只需要修改句柄的引用就可以了</p>
<p>但是句柄模式在查找对象的时候是二次寻址,而直接指针是一次寻址。</p>
<h2 id="分代分配回收算法是什么-什么情况下会进入老年代">分代分配回收算法是什么?什么情况下会进入老年代?</h2>
<p>分代年龄机制的理论是这样描述的:</p>
<ul>
<li>那些新创建出来的对象,往往是朝生夕死的,也就是很快就不会被使用,需要GC,GC大概率会收集掉这些对象</li>
<li>那些经历过多次GC的对象,往往很难被GC掉,因此GC的一般不会收集掉这些对象</li>
</ul>
<p>那么在设计的时候,通常来说就需要做一个分区,也就是将那些容易被GC的放一个区,那些不容易被GC的放一个区。这就是分代分配回收堆内存模型的一个基本思想,在分代分配回收机制下,通常会分为这样的区域</p>
<ul>
<li>伊甸园区(Eden区):新创建的对象都会放在这里</li>
<li>S0/S1区:在伊甸园区经历了GC之后,会基于标记/复制算法,将对象在这来回复制</li>
<li>老年代:当S0/S1的对象经历了足够多次的GC之后,就会晋升为老年代中的对象</li>
</ul>
<p>具体的流程是:</p>
<ul>
<li>当new出来一个对象,就会放入Eden,然后Eden发生<code>MinorGC</code>的时候,就会将那些存活的对象复制到<code>S0</code></li>
<li>当<code>S0</code>满了,就会将<code>S0</code>中存活的对象全部拷贝复制到<code>S1</code>中,循环往复</li>
<li>如果<code>S0/S1</code>中存在有<code>age</code>达到能够晋升到<code>老年代</code>的对象,那么就将这个对象晋升上去</li>
<li>如果老年代满了,那么就会触发一个<code>MajorGC</code>,这个GC会删除那些老年代中死亡的独享</li>
<li>当永久代满了,就会触发<code>FullGC</code></li>
</ul>
<h2 id="如何判断对象是否死亡">如何判断对象是否死亡?</h2>
<p>一般来说,判断对象是否死亡可以通过<code>引用计数法/可达性分析法</code></p>
<p>首先新来讲讲引用计数法,这个方法可以基于对象的头部来做,就是在对象的头部埋下一个字段,称为说是被引用的次数,当有对象引用它了,那么count++,当取消引用了就count–,当count == 0,就可以标记这个对象为可以删除了,但是它有一个致命的问题,就是说这个不能出现循环引用,比如说A B C在程序中没有被使用了,但是A B C相互引用,最终就会导致对象无法被删除掉</p>
<p><strong>可达性分析法</strong>:是一种比较好的方法,它的具体思路是从JVM进程中注册的那些<code>GC Roots</code>出发，向下BFS或者DFS去查询这GCRoots及其子节点,通常来说有双色标记法和三色标记法来实现这个算法,当节点为黑色的,那么就代表不用删除节点,当节点为白色的,那么就需要删除节点</p>
<p><strong>哪些对象可以作为GC Roots?</strong></p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象,比如说有一个线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>本地方法栈<code>(Native 方法)</code>中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p><strong>对象可以被回收,就一定会被回收吗?</strong></p>
<p>不一定,及时在可达性分析法中不可达的对象,也并非是非死不可的,这时候他们暂时处于缓刑的阶段,要真正宣告一个对象死亡,至少要经历两次标记的过程,可达性分析法中不可达的对象被第一次标记并且进行一次过滤,过滤的条件是说这个对象是否有必要执行<code>finalize</code>方法,当对象没有覆盖<code>finalize</code>方法,或者<code>finalize</code>方法已经被虚拟机调用过的时候,虚拟机将这两种情况视为没有必要执行</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记,除非这个对象与引用链上的任何一个对象建立关联,否则就会被真的回收</p>
<p>还有的一个就是在引用类型不同的时候会有不同的情况发生</p>
<p><strong>引用类型总结</strong></p>
<ul>
<li>强引用:如果一个对象具有强引用,那么垃圾回收器就绝对不会回收它的,当内存空间不足,Java虚拟机宁愿抛出OOM错误,也不会回收这些拥有强引用的对象</li>
<li>软引用:如果一个对象只有软引用,那么就类似于可有可无的生活用品,如果内存足够,那么垃圾回收器就不会回收它,如果内存空间不足了,那么就会回收这些对象的内存,软引用可以用来实现一些内存大小敏感的高速缓存</li>
<li>弱引用:如果一个对象只有弱引用,那么也是可有可无的,但是它比软引用的生命周期要更短,一旦遇到垃圾回收,那么无论空间是否充足,都会回收这个对象</li>
<li>虚引用:形同虚设,与其他几种引用都不同,虚引用并不会决定对象的<code>生命周期</code>,如果一个对象只有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收</li>
</ul>
<blockquote>
<p>虚引用主要用来跟踪对象被垃圾回收的活动</p>
</blockquote>
<p>虚引用和弱引用的一个区别在于:虚引用和引用队列必须联合使用,当垃圾回收期准备回收一个对象的时候,如果发现它还有虚引用,那么就会在回收对象的内存之前,把这个虚引用加入到与之关联的引用队列中,程序可以通过判断引用队列中是否加入了虚引用,通过检查队列中是否存在这个对象,来了解这个对象是否被GC了。</p>
<p><code>软引用</code>可以加速JVM对垃圾内存的回收速度,可以维护系统的运行安全,防止OOM等问题的发生</p>
<p><strong>如何判断一个常量是废弃的</strong></p>
<ul>
<li><code>JDK1.7</code>之前的运行时常量池逻辑包含字符串常量池存放在方法区,此时<code>hotspot</code>虚拟机对方法区的实现为永久代</li>
<li><code>JDK1.7</code>字符串常量被从方法区拿到了堆中,这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区,也就是hotspot中的永久代</li>
<li><code>JDK1.8 hotspot</code>移除了永久代用元空间取代,这时候字串常量池还在堆中,运行时常量池还在方法区,只不过方法区的实现从永久代转换成了元空间</li>
</ul>
<blockquote>
<p>假如在字符串常量池中的存在字符串<code>abc</code>,如果当前没有任何<code>String</code>对象引用这个常量的时候,那么就证明废弃了,如果此时发生了内存回收的话而且有必要的话,<code>abc</code>就会被系统清理出常量池了</p>
</blockquote>
<p><strong>如何判断一个类是无用的?</strong></p>
<p>方法区主要回收的是无用的类,那么如何判断一个类是无用的类?</p>
<ul>
<li>该类所有的实例都被回收了,<code>Java堆中不存在该类得到任何实例</code></li>
<li><code>加载这个类的</code>ClassLoader已经被回收了,这也就意味着ClassLoader中没有这个类的缓存了</li>
<li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用,无法通过任何地方通过反射访问这个类的方法</li>
</ul>
<h2 id="可达性分析的流程-哪些对象可以作为GC-Roots">可达性分析的流程?哪些对象可以作为GC Roots?</h2>
<p>可达性分析的流程,首先要从<code>GC Roots</code>的选取说起,它大约是从进程所必须要使用的对象开始向下搜索,这个搜索一般来说来自于:</p>
<p>(1)虚拟机栈中引用的对象,它表示说在函数执行过程中引用了这些对象,不能够轻易解除这些对象</p>
<p>(2)本地方法栈中引用的对象,同理,就是在执行本地方法的时候,如果需要涉及Java堆中的对象的时候,就会将这些对象给保留</p>
<p>(3)方法区中对象,方法区中一般存储的是常量,方法区中类静态属性引用的对象,方法区中常量引用的对象</p>
<p>(4)所有被同步锁持有的对象</p>
<p>那么可达性分析的流程大概是这样的,一般来说有三个过程,<code>Mark=&gt;Mutation=&gt;Sweep</code></p>
<p>那么可达性分析的过程:</p>
<p>(1)首先是初始化标记,它会将<code>GC Roots</code>下的第一个对象给标记起来,然后标记成灰色</p>
<p>(2)并发标记,就是将灰色的对象弹出集合,然后将灰色对象下的子节点全部标记成灰色之后,将父灰色对象标记成黑色,然后不断循环这个过程</p>
<p>(3)由于并发标记的过程中,可能存在一个并发修改的问题,也就是说原本黑色的对象下增加了一个引用,如果不加以修正,那么就会导致对象被误删除,解决这个问题的思路是增量更新,所谓增量更新就是将新增引用,比如说<code>A=&gt;B</code>,将A这个对象加入到一个集合中,然后在<code>remark</code>阶段中,取出这个集合中的元素,然后再次标记子节点</p>
<p>(4)并发标记的过程中,还会存在一个问题,就是一个对象从一个灰色对象的引用被取消了,这种情况下,有导致两种情况的发生<code>这个白色对象接到了一个黑色对象的下面,这样的话就会导致白色对象被删除了</code>,还有一种情况是<code>这个白色对象接到一个灰色对象的下面,这样的话不会出现问题</code>,首先第一种情况非常严重,因此为了避免这种情况,提出了<code>原始快照的方案</code>,这种方案是讲,当从灰色对象下解除一个对象的引用的时候,会记录这一条引用,然后在<code>remark</code>标记的过程中,还是会去扫描这一条引用</p>
<p>这种方式,由于在并发的过程中,看到的对象引用关系和一开始的是一样的,因此称之为原始快照</p>
<blockquote>
<p>跨代引用问题了解吗?怎么解决的?</p>
</blockquote>
<p>首先跨代引用问题说的是:在遍历一个分区的时候,由于涉及到了另外一个分区的引用的情况,从而导致不得不去扫描另外一个分区的现象称为跨代引用问题</p>
<p>假设一下,有一个年轻代对象A引用了老年代对象B,假设我们要回收老年代的对象,扫描的对象都都是基于老年代为根的,由于这个对象无法通过老年代的对象扫描到,因此这个老年代对象B就好像没有被引用到了导致误删。那么怎么解决的呢?</p>
<p>它是通过一张表,我们通常称为是<code>记忆集</code>,这个记忆集记录了所有跨代的引用关系,那么在遍历其中一个代的时候,还会扫描这张表,如果这张表存在老年代中的对象,就会标记,从而避免了又要去遍历另外一个代中的对象。</p>
<h2 id="垃圾回收的算法有哪些-有什么特点">垃圾回收的算法有哪些?有什么特点?</h2>
<p>一般来说,垃圾回收算法有四种模型,这四种模型其实都是基于操作系统中的内存管理来实现的:</p>
<p><strong>标记-清除算法</strong>:这种算法通常来说,还需要配合<code>空闲链表</code>进行实现,因为无法内存区域是不规整的,那么在这样的情况下,无法使用指针碰撞的规则,它的主要思路是,在标记结束后,就会直接删除这个对象,然后将可用的内存空间描述加入到空闲链表中,它的效率很高,因为不需要做额外的操作,但是它会使得内存空间产生大量的不连续碎片</p>
<p><strong>标记-整理算法</strong>:这种算法是基于了第一种<code>标记-清除算法</code>,这种算法致力于使得内存空间变得规整,在这种模式下,不需要空闲链表了,因为在这种算法下,会使得内存空间被严格分成了没有分配的空间和有分配的空间,只要将分配指针向后移动就可以了,这种模式叫做<code>指针碰撞</code></p>
<p><strong>标记-复制算法</strong>:这种算法也是基于了第一种<code>标记-清除算法</code>,这种算法也是致力于使得内存空间变得规整,可以使用指针碰撞来分配内存</p>
<blockquote>
<p>为什么标记整理算法的效率是比较低下的?</p>
</blockquote>
<p>因为复制算法只需要把活的对象拷贝到S区,这个过程中只需要考虑移动堆顶指针,然后按照顺序分配内存即可,实现起来十分简单,运行高效,而标记整理算法,还需要考虑每个对象的大小以及位置,其中涉及的指针计算是比较复杂的,同时在移动对象的时候还需要移动指针的同时,复制内存数据,因此是十分低效的</p>
<p>但是它的内存利用效率是比较低的,因为每次只能使用一部分的内存空间</p>
<p><strong>分代回收算法</strong>:当前虚拟机垃圾收集都是基于分代回收算法实现的,根据分代年龄假说,新生的对象都是朝生夕灭的,因此我们可以为新生的对象设置一个分区,每次回收这个分区,都大概率会有大量的对象被GC,那么选择什么算法呢?可以使用<strong>标记-复制算法</strong>,这是因为每次存活下来的对象都是很少的,因此每次的复制量都会比较低,因此使用这种算法能够取得更高的收益,而老年代的对象因为对象较大,而且每次GC只能回收很少的空间,如果采用复制的话,那么就意味着内存利用率会很低,此时使用<strong>标记-清除/标记-整理</strong></p>
<blockquote>
<p>为什么分为新生代和老年代?</p>
</blockquote>
<p><strong>新生代/老年代</strong>的出现是为了针对不同的年龄的对象执行不同的GC算法,比如说对新生代的GC每次存活下来的对象很少,因此它对内存空间的敏感程度是低于指针计算复杂度的敏感程度的,因此适合使用<strong>标记-复制算法</strong></p>
<p><strong>老年代</strong>由于对象较大,因此它对内存空间的敏感程度是高于指针计算复杂度的敏感程度的,因此适合使用<strong>标记-清除/标记-整理算法</strong></p>
<h2 id="说说常见的垃圾收集器">说说常见的垃圾收集器</h2>
<p><strong>串行收集器</strong></p>
<p>主要的执行流程:在需要GC的时候,此时会触发<code>STW</code>,然后使用一个单线程的垃圾收集线程去执行<code>Mark Sweep</code>直到收集执行,因此在这个过程中,标记算法可以使用<code>双色标记法</code>,因为中间没有线程在做修改</p>
<p>新生代采用的是<strong>标记复制算法</strong>,老年代采用的是<strong>标记整理算法</strong></p>
<ol>
<li>吞吐量小,内存回收工作量不大</li>
<li>容忍延迟,不在意卡顿</li>
<li>单核,内存小:0~100M</li>
</ol>
<p><strong>ParNew收集器</strong></p>
<p><code>ParNew</code>的执行工作量实际上是要大于单线程的执行的,但是由于多核的优势,它可以提高吞吐量<code>(指的是降低GC的时间占比)</code>，它特点就是在触发GC的时候,使用STW,然后启动多线程,用多线程执行GC</p>
<p>它在新生代会使用标记复制算法,在老年代会执行标记整理算法</p>
<p><strong>Parallel Scavenge收集器</strong></p>
<p>这个收集器主要是对于老年代有不同的收集策略</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC <span class="comment">#老年代串行执行</span></span><br><span class="line">-XX:+UseParallelOldGC <span class="comment">#老年代并行执行</span></span><br></pre></td></tr></table></figure>
<p><code>Parallel Scavenge</code>收集器关注的是吞吐量<code>(高效率的利用CPU)</code>,CMS等垃圾收集器的关注点更多的是用户线程的停顿时间,使用了这个垃圾收集器选项,就可以将内存管理优化的工作交给虚拟机去完成</p>
<p><strong>Serial Old收集器</strong><br>
它是串行收集器的老年代版本,意思是在老年代执行STW+Mark+Sweep,其中老年代执行的是标记整理算法</p>
<p><strong>Parallel Old</strong></p>
<p><code>Parallel Scavenge</code>的老年代版本,使用多线程和标记整理算法,在注重吞吐量和CPU资源的场合</p>
<p><strong>CMS收集器</strong></p>
<p><code>CMS(Concurrent Mark Sweep)</code>收集器是一种以获取最短回收停顿时间为目标的收集器,它非常符合在注重用户体验的应用上的使用</p>
<p><code>标记-清除</code>算法,它的运作过程实现了让垃圾收集线程与用户线程基本上同时工作,分为四个步骤:</p>
<p><strong>初始标记</strong>:暂停所有的线程(STW),并且记录下与<code>root</code>相连的对象,速度是很快的</p>
<p><strong>并发标记</strong>:同时开启GC和用户线程,用一个闭包结构去记录那些可达的对象,但是在这个阶段结束之后,这个闭包结构并不能保证当前的标记是正确的,这是因为并发用户线程可能还会删除各自的引用,导致问题的发生</p>
<ul>
<li>增量更新:就是当添加一个白色对象到黑色对象的时候,这时候会将这个对象通过写屏障的方式(代理),将这个对象添加到一个集合中,然后在重新标记过程中处理</li>
<li>原始快照:就是当删除一个灰色对象下的白色对象的时候,会记录下这个引用关系,在重新标记过程中处理</li>
</ul>
<p><strong>重新标记</strong>:STW,重新标记阶段就是为了修正并发标记期间因为用户程序运行而导致标记变动的那一部分的标记记录,这个阶段的停顿时间一般会比初始标记阶段的时间稍长</p>
<p><strong>并发清除</strong>:STW,回收垃圾对象</p>
<ul>
<li>对CPU资源是敏感的</li>
<li>无法处理浮动垃圾</li>
<li>它使用的回收算法,标记清除,将导致大量的外碎片</li>
</ul>
<p><strong>G1收集器</strong></p>
<p>空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于<strong>标记-整理算法</strong>实现的收集器，从局部（两个Region之间）上来看是基于“<strong>复制</strong>”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。<strong>这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。</p>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间</p>
<p>G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。Region的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，JVM会尽量划分2048个左右、同等大小的Region</p>
<p><strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p>
<p><strong>G1收集的运作过程大致如下：</strong></p>
<ul>
<li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>这阶段需要<code>停顿线程</code>，但耗时很短</strong>。</li>
<li><strong>并发标记（Concurrent Marking）</strong>：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，<strong>这阶段耗时较长</strong>，但可与用户程序并发执行。</li>
<li><strong>最终标记（Final Marking）</strong>：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，<strong>这阶段需要<code>停顿线程</code>，但是可并行执行</strong>。</li>
<li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ul>
<p>全局变量和栈中引用的对象是可以列入根集合的，这样在寻找垃圾时，就可以从根集合出发扫描堆空间。在G1中，引入了一种新的能加入根集合的类型，就是<code>记忆集</code>（Remembered Set）。Remembered Sets（也叫RSets）用来跟踪对象引用。G1的很多开源都是源自Remembered Set，例如，它通常约占Heap大小的20%或更高。并且，我们进行对象复制的时候，因为需要扫描和更改Card Table的信息，这个速度影响了复制的速度，进而影响暂停时间。</p>
<p>有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC Roots。那不是得又做全堆扫描？成本太高了吧。</p>
<p>HotSpot给出的解决方案是一项叫做<code>卡表</code>（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。</p>
<p>在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。</p>
<p>想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p>
<h2 id="什么是字节码-类的文件结构的组成是什么">什么是字节码?类的文件结构的组成是什么?</h2>
<p>在Java中,JVM可以理解的代码就叫做字节码<code>(扩展名为.class文件)</code>,它不面向任何特定的处理器,只面向虚拟机,<code>Java</code>语言通过字节码的方式,在一定程度上解决了传统解释型语言执行效率低的问题,同时又保留了解释型可移植的特点,所以Java程序在运行的时候是比较高效的,字节码转换为<code>bytecode</code>的过程实际上是JIT编译器完成的,JIT编译器会根据当前操作系统的底层决定将字节码编译为什么样的指令集</p>
<ul>
<li>魔数(每个Class文件的头4个节点称为是魔数,唯一的作用是确定这个文件是否为一个能被虚拟机接收的Class文件)</li>
<li>Class文件版本号</li>
<li>常量池(Constant Pool),它主要存放的是两大常量,字面量和符号引用</li>
<li>访问标志</li>
<li>当前类</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
<h2 id="类的生命周期-类的加载过程">类的生命周期?类的加载过程?</h2>
<p>类的生命周期是从<code>.class</code>文件被加载到虚拟机内存中开始到被卸载出内存为止,因此它的整个生命周期可以概括为:</p>
<p>(1)加载:通过全类名获取定义此类的二进制字节流,将字节流所代表的静态存储结构转换为方法区的运行时数据结构,在内存中生成bytecode,以及将解析出来的数据存储到方法区中。</p>
<blockquote>
<p>每一个Java类都有一个引用指向加载它的<code>ClassLoader</code>,例如是数组类,数组类的<code>ClassLoader</code>是它的基元类型,这个过程可以控制到底是哪一个类加载器来执行类构造的方法,通过<code>loadClass()</code>方法来执行相关方法</p>
</blockquote>
<p>(2)验证:验证是连接的第一步,它主要是将存储在内存中的<code>bytecode</code>以及<code>class</code>中的字节流中的信息是一个合法的类文件,否则会危害虚拟机甚至是操作系统的安全,主要是要验证<code>.class</code>的文件格式,<code>元数据验证(比如说这个类是否有父类,这个类是否继承了不允许继承的类final)</code>、<code>字节码的验证(程序语义是否正确)</code>、<code>符号引用的验证(类的正确性验证)</code></p>
<p>(3)准备:准备阶段就是说这个类通过了验证,是一个合法的<code>.class</code>文件,准备阶段是正式为类变量分配内存并且设置类变量初始化的节点,这些内存都在方法区中分配</p>
<ul>
<li>此时完成内存分配的变量仅有类变量</li>
<li>在JDK1.7之后,HotSpot就将原本放在永久代中的常量放到堆上了</li>
</ul>
<p>(4)解析,解析阶段就是虚拟机将常量池内的符号引用替换为直接引用的过程,解析的动作针对类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用执行</p>
<p>在程序执行方法的时候,系统明确知道这个方法所在的位置,Java虚拟机为每个类都准备了一张方法表来存放类中的所有方法,当需要调用一个类的方法的时候,只要知道这个方法在方法表中的偏移量就可以直接调用这个方法了,通过解析操作符号引用就就可以直接转变为目标方法在类中方法表的位置,从而使得方法就可以被调用</p>
<p>(5)初始化,执行初始化方法<code>&lt;clinit&gt;()</code>,注意,这个是说类的初始化,这一步才开始真正地执行代码,这个方法是线程安全的,所以在多线程环境下进行类的初始化的话可能会引起多个线程阻塞,并且这种阻塞很难被发现</p>
<p>当遇到 <code>new</code> 、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条直接码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</p>
<ul>
<li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
<p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</p>
<p>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</p>
<p>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</p>
<p><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</p>
<p>(6)使用</p>
<p>(7)卸载,该类的所有的实例对象都已经被GC了,堆中没有这个类的对象,该类没有在其他任何地方被引用,该类的类加载器已经被GC</p>
<p>因此由我们自定义的类加载器的类是可以被卸载的</p>
<h2 id="双亲委派模型是什么-不想用双亲委派模型要怎么破坏">双亲委派模型是什么?不想用双亲委派模型要怎么破坏?</h2>
<blockquote>
<p>类加载的作用是什么?</p>
</blockquote>
<p>类加载的作用是获取类的基本信息,比如说这个类的类名,实现了什么接口,父类是什么,有哪些字段,有哪些方法,是否是公有的,当我们新建一个对象的时候,因为要为这个对象分配内存,那么就需要要提前知道这个对象需要多大的空间,如何来调用这个对象中的方法,如何来执行这个对象的方法,因此加载类的作用就是为了创建对象,一般来说,类的基本信息会被加载到虚拟机中的方法区中,比如说在HotSpot中,就会被加载到元空间</p>
<blockquote>
<p>有哪些类加载器?</p>
</blockquote>
<p><strong>BootstrapClassLoader</strong>:它是最底层的加载类,主要是用来加载Java的核心类库的,它是JVM的一部分,通常是用NULL的表示的,比如说你对String去getClassLoader,得到的是null</p>
<p><strong>ExtentsionClassLoader</strong>:扩展加载器,主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的jar包</p>
<p><strong>AppClassLoader</strong>:应用程序加载类,面向用户的加载类,负责加载当前应用<code>classpath</code>下的所有jar包和类</p>
<p>除此之外,还可以使用自定义的类加载器,通过自定义的类加载器,就可以实现自定义的类加载逻辑,比如说可以通过<code>对字节码文件加密</code>,只有我们自定义的<code>类加载器</code>才能进行解密</p>
<blockquote>
<p>什么是双亲委派模型?</p>
</blockquote>
<p>双亲委派模型描述的是JDK中推荐的一种的加载类的方式,它的核心思想是自底向上查找类是否被加载过,如果被加载过了,那么就无序加载,然后自顶向下去尝试加载类。执行流程可以详细描述为:</p>
<p><strong>在类加载的过程中,系统会先判断这个类是否被加载过了,已经被加载的类会直接返回,否则才会尝试嘉爱这个类,类加载器在进行类加载的时候,它首先不会自己去尝试加载这个类,而是将这个请求向上传递到父级请求,这样的话,基于双亲委派模型的类加载器,最终都会收集到所有的请求</strong>,只有当父加载器无法实现这个加载的时候,子加载器才会尝试去自己加载</p>
<p><strong>如何判定两个Java类是否相同?</strong></p>
<p>JVM不但要判断类的全路径类名是否相同,还要判断此类的加载器是否相同,只有两者都相同的情况下,才能说这两个类相同</p>
<p>自定义类加载器,如果不打破双亲委派模型的话,那么可以:</p>
<ul>
<li>首先继承<code>ClassLoader</code></li>
<li>重写<code>findClass()</code></li>
<li>无法被父类加载的类最终会通过这个方法被加载</li>
</ul>
<p>如果想要打破双亲委派模型,那么就需要重写<code>findClass()</code>方法了</p>
<p>这是因为<code>findClass()</code>定义的是从哪里去加载这个类,如果是默认的话就会向上递归,直到父加载器完成加载</p>
<p>例如说<code>Tomcat</code>服务器为了能够优先加载<code>Web应用目录下</code>的类,然后再通过加载其他目录下的类,就自定义了<code>WebAppClassLoader</code></p>
<h2 id="双亲委派模型有什么好处">双亲委派模型有什么好处?</h2>
<p>双亲委派模型保证了Java程序运行的稳定性,可以避免类的重复加载,<code>JVM</code>区分不同类的方式不仅仅根据类名,想用的类文件被不同的类加载器加载也算作是不同的两个<code>Class</code>,同时,如果保证了双亲委派模型,那么如果有恶意第三方库伪造了一个JDK中的核心类,那么就会导致安全的问题,使用双亲委派模型能够保证使用的核心类是安全的。</p>
<h2 id="默认类加载器">默认类加载器?</h2>
<p>默认的类加载器有三种:</p>
<ul>
<li>BootStrapClassLoader:这个加载器是JVM中的一个组件,它是虚拟机的一部分,本身不是使用Java语言实现的,因此在<code>ClassLoader</code>中<code>getParent</code>的时候就会得到<code>null</code></li>
<li>ExtentsionClassLoader:这个加载器用来加载特定的包,比如说<code>%JRE_HOME%/lib</code>下的jar包,通过这个可以实现第三方库的加载</li>
<li>ApplicationClassLoader:用户类加载器</li>
</ul>
<h2 id="JVM性能监控工具">JVM性能监控工具?</h2>
<p>可以使用<code>jps</code>进行Java进程监控,包括其PID</p>
<p><code>jstat</code>:收集HotSpot虚拟机各方面的数据</p>
<p><code>jinfo</code>:显示虚拟机的配置信息</p>
<p><strong>jmap</strong>:查看Java的堆栈信息</p>
<p><strong>如何排查死锁?</strong><br>
第一步,通过<code>Linux</code>的<code>ps -aux | grep java</code>指令,查看运行中的Java进程,查看运行时间长的进程</p>
<p>第二步,通过<code>jstack PID</code>,就能够打印出哪些线程引发了死锁</p>
<h2 id="重要的参数">重要的参数?</h2>
<p><strong>如何指定堆内存</strong>:指定最大堆和最小堆</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heapSize&gt;[unit]</span><br><span class="line">-Xmx&lt;heapSize&gt;[unit]</span><br></pre></td></tr></table></figure>
<p><strong>如何设定新生代内存</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;youngSize&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;youngSize&gt;[unit]</span><br><span class="line"><span class="comment">#配置新生代的最小内存256m,最大内存1024m</span></span><br><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br><span class="line"><span class="comment">#设置最小和最大一致</span></span><br><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure>
<p><strong>如何调节老年代和新生代的比例?(重要)</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio=1</span><br></pre></td></tr></table></figure>
<p><strong>指定元空间的大小</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N</span><br><span class="line">-XX:MaxPermSize=N</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>
<h2 id="遇到的GC问题如何解决">遇到的GC问题如何解决?</h2>
<p><strong>YoungGC频繁怎么办?</strong></p>
<p>假设有关任务会频繁地调用一个接口,<code>YoungGC</code>的次数在某一个时间点飙升,同时伴随着Old区域内存的快速升高,然后最终会导致一次<code>Full GC</code>,这样的情况一般可以将问题归结于对新生代的管理不当,一般来说有这样的情况:</p>
<ul>
<li>新生代的<code>Eden</code>区的配置太小,导致Eden的频繁GC,服务器的内存配置满足不了现有的业务量,优先对内存进行扩容,可以通过<code>jmap -histo</code>并且结合<code>dump</code>堆文件作进一步分析,查看是哪个对象占用了大量内存不释放。</li>
</ul>
<p><strong>YoungGC和OldGC都很频繁怎么办?</strong></p>
<p>思路:</p>
<ul>
<li>GC样本采集</li>
</ul>
<p>如果是因为FullGC导致的系统卡顿,首先需要对GC情况进行一些数据的采集,下面的指令能够知道发生GC的次数和耗时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat gc -pid 2000 10000</span><br></pre></td></tr></table></figure>
<ul>
<li>结合GC样本和JVM参数配置,分析堆内存中的对象流转情况</li>
</ul>
<p>结合之前的GC次数以及JVM参数中的新生代和老年代中的空间,分析<code>FootPrint</code></p>
<ul>
<li>结合对象挪动到老年代的规则,验证并且调优</li>
</ul>
<p><strong>定位内存突然飙升导致的OOM异常</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行堆栈分析,生成当前的堆栈快照,此时会生成两个文件,分别是.dump和.log文件</span></span><br><span class="line">jmap -dump:format=b,file=A.<span class="built_in">log</span> PID</span><br><span class="line"><span class="comment"># 通过查看导出的dump文件(可以使用jvisualvm进行解析,就可以看到某个实例在内存中的占比,然后根据代码定位即可)</span></span><br></pre></td></tr></table></figure>
<p><strong>CPU飙升怎么办?</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU`飙升是CPU密集型的操作过多,正常操作的时候基本上很少出现,此时就需要快速定位CPU过高的原因并且排除,一般来说有两种情况:`程序中出现了死循环`、`线程数无限增大(比如使用了CachedThreadPool)</span><br></pre></td></tr></table></figure>
<p>一般步骤是</p>
<p>通过<code>top</code>指令查看当前哪个<code>Java</code>进程的CPU占用最高</p>
<p>通过<code>top -H</code>查看这个进程中的线程运行情况,就可以看到哪个线程的占用最高</p>
<p>然后将<code>TID=&gt;十六进制</code>,然后通过<code>jstack PID |grep -A TID </code>就可以从堆栈信息查询到相关的代码了</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><a class="post-meta__tags" href="/tags/%E9%A2%98%E5%BA%93/">题库</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/13/MySQL%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="MySQL 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96167606_p0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL 面试题总结回顾</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/11/JUC%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/" title="JUC 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC 面试题总结回顾</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/11/JUC%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/" title="JUC 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-11</div><div class="title">JUC 面试题总结回顾</div></div></a></div><div><a href="/2023/08/10/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/" title="Java基础面试题回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97052568_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">Java基础面试题回顾</div></div></a></div><div><a href="/2023/08/13/MySQL%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="MySQL 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96167606_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-13</div><div class="title">MySQL 面试题总结回顾</div></div></a></div><div><a href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96887683_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="title">Redis 面试题总结回顾</div></div></a></div><div><a href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-15</div><div class="title">WebSocket 面试题总结回顾</div></div></a></div><div><a href="/2023/08/09/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/" title="三个线程如何交替打印 0 - 100？"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-09</div><div class="title">三个线程如何交替打印 0 - 100？</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kaillliu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/51341210"><i class="fa-brands fa-bilibili"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/51341210" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://weibo.com/u/5412952403" target="_blank" title="weibo"><i class="fa-brands fa-weibo"></i></a><a class="social-icon" href="mailto:kaillliu@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">堆和栈有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">常见的垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%AE%9E%E6%93%8D"><span class="toc-number">3.</span> <span class="toc-text">JVM调试工具实操</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%AE%9E%E6%88%98"><span class="toc-number">4.</span> <span class="toc-text">字节码实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">Java对象在内存中的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.</span> <span class="toc-text">ClassLoader是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9D%A5%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">如何来打破双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">对运行时数据区的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">方法区和永久代的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.</span> <span class="toc-text">JVM常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">Java对象的创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">对象访问定位的两种方式?有什么优缺点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%88%86%E9%85%8D%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">6.</span> <span class="toc-text">分代分配回收算法是什么?什么情况下会进入老年代?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1"><span class="toc-number">7.</span> <span class="toc-text">如何判断对象是否死亡?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%9A%84%E6%B5%81%E7%A8%8B-%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Roots"><span class="toc-number">8.</span> <span class="toc-text">可达性分析的流程?哪些对象可以作为GC Roots?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text">垃圾回收的算法有哪些?有什么特点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">说说常见的垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81-%E7%B1%BB%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%84%E6%88%90%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.</span> <span class="toc-text">什么是字节码?类的文件结构的组成是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">类的生命周期?类的加载过程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%8D%E6%83%B3%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E8%A6%81%E6%80%8E%E4%B9%88%E7%A0%B4%E5%9D%8F"><span class="toc-number">13.</span> <span class="toc-text">双亲委派模型是什么?不想用双亲委派模型要怎么破坏?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">14.</span> <span class="toc-text">双亲委派模型有什么好处?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">15.</span> <span class="toc-text">默认类加载器?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="toc-number">16.</span> <span class="toc-text">JVM性能监控工具?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">重要的参数?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84GC%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">18.</span> <span class="toc-text">遇到的GC问题如何解决?</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97025298_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（2）"/></a><div class="content"><a class="title" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）">计算机网络 面试题 总结回顾（2）</a><time datetime="2023-08-18T07:00:00.000Z" title="发表于 2023-08-18 15:00:00">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94900660_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（1）"/></a><div class="content"><a class="title" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）">计算机网络 面试题 总结回顾（1）</a><time datetime="2023-08-17T07:00:00.000Z" title="发表于 2023-08-17 15:00:00">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96369940_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾">操作系统 面试题总结回顾</a><time datetime="2023-08-16T07:00:00.000Z" title="发表于 2023-08-16 15:00:00">2023-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebSocket 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾">WebSocket 面试题总结回顾</a><time datetime="2023-08-15T07:00:00.000Z" title="发表于 2023-08-15 15:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96887683_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾">Redis 面试题总结回顾</a><time datetime="2023-08-14T07:00:00.000Z" title="发表于 2023-08-14 15:00:00">2023-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Kaillliu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>