<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络 面试题 总结回顾（1） | K A I</title><meta name="author" content="Kaillliu"><meta name="copyright" content="Kaillliu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络 面试题总结回顾"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://kaillliu.github.io/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#263238","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络 面试题 总结回顾（1）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 12:36:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94900660_p0.png')"><nav id="nav"><span id="blog-info"><a href="/" title="K A I"><span class="site-name">K A I</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络 面试题 总结回顾（1）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-17T07:00:00.000Z" title="发表于 2023-08-17 15:00:00">2023-08-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T04:36:17.750Z" title="更新于 2023-09-08 12:36:17">2023-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A2%98%E5%BA%93/">题库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络 面试题 总结回顾（1）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="为什么需要有TCP-IP网络模型">为什么需要有TCP/IP网络模型?</h2>
<p>对于同一台设备上的进程间通信,可以使用:</p>
<p><strong>管道</strong>:其实就是通过<code>fork()</code>指令来创建父子进程,通过父子进程的共享数据的方式来实现进程间数据的共享,通常就是通过共享底层文件系统的fd来实现的。</p>
<p><strong>消息队列</strong>:消息队列就是一个消息结构体,通过封装一个队列,将消息结构体<code>push()</code>到这个队列中,基于先进先出的原则,实现进程间的缓存区通信的功能</p>
<p><strong>共享内存</strong>:就是对于进程独有的内存空间做一个共享,比如说两个进程中的页表地址是一致的,这样的话就可以实现内存之间的相同映射,基于这个相同的映射,就可以实现两个进程同时操作同一个内存</p>
<p><strong>信号量</strong>:信号量机制在底层有两个字段,第一个是一个<code>count</code>计数,假设这个值是n吧,那么当<code>n &gt; 0</code>的时候,那么这时候<code>count</code>就代表可用的资源个数,当<code>n &lt; 0</code>的时候,这时候就代表当前有多少个线程正在被阻塞,这时候会与第二个字段<code>BlockQueue</code>阻塞队列关联,通过这个队列就可以知道哪些线程被阻塞了</p>
<p>既然进程间有这样的<code>IPC</code>通信协议,他们建立起来的基础是这些进程处于同一个操作系统中,通过底层所实现的这些数据结构,就可以实现进程间的通信,但是网络间的通信,这意味着这些主机的操作系统、中间传输设备(如路由器)通常是异构的,所以为了要兼容多种多样的设备,于是就协商出来了一套通用的网络协议。</p>
<blockquote>
<p>为什么<code>网络要进行分层</code>?</p>
</blockquote>
<p>关于这个问题,可以这样进行回答:</p>
<p>首先,<code>网络通信</code>这件事情是十分复杂的,如果要拆解,一次成功的网络通信,要求:</p>
<p><strong>底层的物理设备不出差错,能够以正确的方式解析电磁波</strong></p>
<p><strong>数据包在两个主机之间有一条路径,可寻址</strong></p>
<p><strong>如果数据包在网络上丢失了,这时候要做处理/维护数据包的语义完整性</strong></p>
<p><strong>网络通信要完成用户指定的功能</strong></p>
<p>假设将这些功能全部在一起完成,那么就会导致网络设计的耦合度太强了,比如说我底层使用的物理设备需要更换的时候,这时候就要修改整一套系统,假设你建立了一条TCP连接,理论上来讲,这条TCP连接是在底层的物理设备的支持下完成连接的,如果物理设备更换了,那么就会导致TCP连接直接被重置,甚至需要对TCP相关的代码需要重新编码,这是一件十分不合适的事情,这就无法实现热插拔等相关功能了</p>
<h2 id="TCP-IP的应用层是干什么的">TCP/IP的应用层是干什么的?</h2>
<p><strong>应用层</strong>协议是直接面向用户的,因此它负责完成两个进程之间的通信,一般来说,它就是专门用来完成用户提出的请求的,比如说用户需要完成HTTP传输,那么就需要使用<code>HTTP</code>协议,并且在头部字段定义相关的字段,比如说用来传输普通的文本等,这个协议并不关心底层是如何传输的,它只关心如何将用户的请求翻译成协议的字段</p>
<blockquote>
<p>应用层是工作在操作系统的用户态的,传输层以及以下是工作在内核态中的</p>
</blockquote>
<h2 id="TCP-IP的传输层是干什么的">TCP/IP的传输层是干什么的?</h2>
<p>关于传输层的作用,可以这样说,<code>传输层负责接收来自于上层的应用层的数据包,然后将这些数据包做一些相关的封装</code>,下发到网络层,然后让网络层完成主机间的传递</p>
<p><strong>网络层是负责的是主机间的传输</strong></p>
<p><strong>传输层负责的是主机间进程的传输</strong></p>
<p>也就说网络层负责将一个主机上的数据包发送到另一台主机设备的网络适配器缓冲区上,然后由操作系统的<code>TCP/IP</code>协议栈,负责处理这个数据包,然后将这个数据包头部含有的信息进行解析,也就是一般来说就是通过端口来进行检查,用端口+协议来标识某一个特定的应用</p>
<p>在传输层中,有两个协议,一个是叫做TCP协议,一个是叫做UDP协议,这两个协议的存在是为了适应不同的网络环境下的不同应用的需求,比如说有:</p>
<p><strong>UDP协议</strong>:UDP协议的特点是面向数据报的,面向无连接的,尽最大努力传输的协议,它只负责对上层的应用数据包进行封装,它非常简单,头部的字段只有<code>目的端口、源端口、校验和、包长度</code>,因此在这样的基础上,就可以实现简单的转发功能,适用场景比如说直播,视频通话等这些要求时效性强的场景</p>
<p><strong>TCP协议</strong>:TCP协议的特点是面向字节流的,面向连接的,可靠的传输协议,它的特点主要就是可靠,可以用来做一个网络文件的传输,可以保障数据的完整性,UDP其中的一个特点是面向数据报的,这个特点决定了UDP在收取上层应用数据包的时候,这时候不会将数据进行分片,而是将分片的工作交给了网络层的IP协议</p>
<p>如果TCP采用这样的原则的话,那么就可能导致一个现象,就是一个大的TCP报文段在经过IP协议的分片后,如果其中一个小报文段丢失了,那么最终就可能导致整个TCP报文段的重新传输,这是十分不划算的。</p>
<p>因此TCP<strong>有自己的一套分片规则</strong>,它会根据TCP连接建立的时候协商好的<code>MSS</code>最大报文段,根据这个最大报文段来进行分片,即使中途有一个MSS大小的报文段丢失了,只需要重传这一个报文段即可,不然的话就还需要重传一个TCP报文段。</p>
<h2 id="TCP-IP的网络层是干什么的">TCP/IP的网络层是干什么的?</h2>
<p><strong>传输层的功能主要是为了处理两个进程之间的通信问题</strong>,它的设计理念是只需要负责好上层应用之间的数据传递就可以了,但是它没有完成两个进程之间的数据包,在错综复杂的网络中是如何传输的问题,因此在这样的情况下,还设计了一个网络层,网络层的作用主要可以概括为:</p>
<p><strong>路由选择</strong>、<strong>分组转发</strong>,这也就是路由器的功能,而这其中最关键的一个协议就是IP协议,IP协议的主要作用就是提供了一套规范,通过这个规范来确定IP包的首部字段的功能,功能其实是比较复杂的,首部字段比较重要的有IP源地址,IP目的地址,以及一些例如校验和之类的字段,通过<code>&lt;目的地址,源地址&gt;</code>的这个字段对,就可以实现基本的网络路由寻址。</p>
<p>寻址的过程大致是这样的:一个数据包被发送到一个路由器的缓存队列中,然后路由器中的处理程序取出这个数据包,然后根据内部的<code>iptables</code>来确定这个数据包要发送到哪一个端口,然后沿着端口的这条路径不断传送,直到到达指定的路径即可。</p>
<blockquote>
<p>为什么有了MAC地址还要有IP地址?</p>
</blockquote>
<p><code>MAC</code>地址对于每一个物理设备来讲都是独一无二的,通过MAC地址,在数据链路层就可以实现局域网寻址,局域网可以假设是非常小规模的,因此通信的时候可以使用带载波监听的多路访问技术<code>CSMA/CD</code>,可以通过这个技术来广播一个物理帧,然后这个物理帧上就会带着目标设备的MAC地址,然后对应的设备就会检查这个帧头部的MAC地址是否和本物理设备上的MAC地址是否相同,如果相同,那么就接收</p>
<p><code>MAC</code>地址是物理地址,它的构成是这样的<code>&lt;厂商标识码,厂商自行安排的尾数&gt;</code>,那么如果只有MAC地址的话,那么就意味着这些设备的标识地址都没有规律,在这样的情况下,为了找到网络上的每一台设备,我们需要一个巨大的中央服务器,这个中央服务器要存储所有设备的<code>MAC</code>地址,在当前的网络规模下,是无法想象这样的设计的</p>
<p>因此在这样的情况下,基于<code>MAC</code>地址还开发出来了<code>IP</code>地址,IP地址通过<code>&lt;网络号，主机号&gt;</code>的方式来对网络设备进行划分,这样的话就可以实现这样一种方案,就是知道了对方的IP地址,我就知道要往哪里转发,因为一个设备归属于一个局域网,那么我只需要知道这个局域网的入口路由器是哪个,就可以知道我要将这个数据包转发到哪里了,这个情况下,只需要每个路由器维护自己的一张表,而不需要安排一个巨大的服务器来进行存储。</p>
<blockquote>
<p>为什么有了IP协议还要有UDP协议?</p>
</blockquote>
<p>首先要搞清楚,IP协议是在网络层上工作的,而网络层上的工作是为了实现从主机到主机的寻址,我们说的计算机网络通信通常指的是一个进程到另外一个进程的通信,因此在这样的情况下,我们需要在传输层设计一个尽最大努力传输的协议,来和TCP协议的使用场景进行区分</p>
<h2 id="TCP-IP的网络接口层是干什么的">TCP/IP的网络接口层是干什么的?</h2>
<p>我们说网络层负责的是跨网段的传输,也就是说从一个网段中传输数据包到另外一个网段,那么网络接口层就是负责局域网内的传输,也就是说,当一个数据包完成了跨网段的识别</p>
<p>从一个网络中的路由器发送到另外一个网络上的路由器的时候,这时候就是网络层完成的事情</p>
<p>那么在同一个网络中,路由器和具体设备的通信的时候,实际上是依赖一个叫做<code>数据链路层</code>的层级来完成操作的,也就是说,从这个数据链路层中,它完成的是局域网通信,主要完成网络适配器的识别和数据包的匹配</p>
<p>负责完成底层数字信号的调频调幅调相的相关功能</p>
<blockquote>
<p>什么是局域网?</p>
</blockquote>
<p>一种私有网络,将分布在小范围内的网络设备串联在一起的一种小型网络,通常不经过路由器,而是通过<code>交换机</code>、<code>网桥</code>等设备进行连接</p>
<h2 id="输入一个URL-问你这期间发生了什么">输入一个URL,问你这期间发生了什么?</h2>
<p>这个问题 比较复杂,需要从几个方面进行回答</p>
<h3 id="从B-S应用架构来进行回答">从B/S应用架构来进行回答</h3>
<p>首先浏览器发起了一个HTTP请求,然后这个请求就会被转发到后台服务器上,后台服务器就会解析这个请求的含义,通常来说,HTTP请求的格式是<code>请求行(包括有HTTP版本号,URL,请求方法GetOrPost)|请求头(包含了HTTP协议中规定的应用字段)|空行(其实就是一个cr lf回车,用来分割控制信息的头部)|请求体(具体携带的负荷)</code></p>
<p>然后后端服务器就会解析这个HTTP请求,然后从Web服务器上取出需要相应的资源,然后将资源封装起来原路返回</p>
<p>这个资源被浏览器接收到了之后,然后就会浏览器就会将这个HTTP响应解析出来,然后将数据渲染到浏览器上</p>
<p>HTTP响应的格式是<code>响应行(包括有版本号,状态码,短语(也就是当前状态码所代表的含义是什么))|响应头(包括本次返回响应的数据长度是多少?)|空行(用来分割响应头和响应体)|响应体</code></p>
<h3 id="从计算机网络协议栈的角度来进行回答">从计算机网络协议栈的角度来进行回答</h3>
<p>以上是从<code>B/S</code>架构交互流程来进行说明的,如果要从网络协议栈来说明的话,可以基于<code>TCP/IP</code>四层协议来进行说明,比如说我输入了一个<code>www.baidu.com</code>,那么大致将经过:</p>
<p>首先,第一步,用户输入了这个URL,于是浏览器就需要负责将这个URL的相关信息封装成一个HTTP请求,比如说<code>www.baidu.com</code>,浏览器内置选用了<code>HTTP/1.1</code>的版本的协议,然后使用了<code>Get</code>请求,然后请求体是空的,然后准备交付到下一层,此时就经历一个委托的过程,我们知道<code>TCP/IP</code>四层的通信,主机之间的通信是基于<code>IP</code>协议进行通信的,因此在交付到下层的时候,这时候还缺少一个IP地址,因此在交付之前,还需要查询一下IP地址</p>
<p>于是第二步,就需要执行一个DNS查询,DNS查询是基于一个<code>UDP</code>协议来完成的,具体的流程是:</p>
<ul>
<li>客户端会先向本地域名服务器查询,问它知不知道<code>www.baidu.com</code>的IP地址,如果它知道就直接返回</li>
<li>如果本地域名无法查询到,于是就获取顶级域名服务器的地址,也就是<code>.</code>的地址,这个地址是所有服务器都知道的,这时候本地域名服务器就会向<code>根域名服务器</code>查询<code>www.baidu.com</code>的地址</li>
<li>注意,根域名服务器并不起到一个直接解析的作用,而是起到一个指路的作用,这时候它会告诉<code>顶级域名服务器的地址</code>,也就是<code>.com</code>的地址</li>
<li>然后本地域名服务器就会向<code>.com</code>的域名服务器进行查询,如果<code>.com</code>的域名服务器也没有,它就会告诉他掌管<code>www.baidu.com</code>的权威域名服务器的地址</li>
<li>然后本地域名服务器最终就会向这个域名服务器请求IP地址,这时候就能够查询成功了</li>
</ul>
<p>查询成功之后,这时候就能够将IP地址投入委托使用了</p>
<p>第三步,获取了通信的必要信息,比如说IP地址,端口号等,这时候应用程序就会调用封装好的<code>Socket</code>中的接口,调用这些接口实际上就发起了系统调用,操作系统根据通信需要用到的协议,将消息发送到具体的通信模块中,比如说发送到<code>TCP</code>处理模块中,然后进行一系列的网络传输操作</p>
<p>第五步,建立TCP连接,TCP连接是一个非常复杂的协议,首部字段主要有:</p>
<ul>
<li>源端口号、目的端口号</li>
<li>报文段的序号:用来保证传输过程中不乱序传输,可靠传输的必要条件,传输过程中如果出现了乱序,会根据滑动窗口中的序号限定来确定哪些报文段可以被接收,哪些需要丢弃</li>
<li>确认号:接收方表示从<code>ack-1</code>之前的所有字节都被接收到了</li>
<li>状态位,我们说TCP连接的变化,其实就是一个状态机不断变化的过程,状态转移需要依赖于双方交换的报文段中的状态位,比如说有<code>FIN</code>、<code>ACK</code>、<code>RST</code>、<code>SYN</code>等通过这些状态位来确定当前TCP连接状态</li>
<li>窗口大小,它是TCP的精髓所在,在实现拥塞控制(控制数据包注入网络中的速度),流量控制(控制发送的速率)的时候有很大作用</li>
</ul>
<p>然后执行TCP的三次握手,这时候会经历:</p>
<p><strong>一开始,服务端和客户端都是处在一个CLOSE的状态,然后这时候服务端被动打开连接,客户端主动建立连接,也就</strong>:</p>
<ul>
<li>客户端发送一个<code>SYN+clinet_seq</code>的报文段,请求服务端的连接,进入<code>SYN_SENT</code>的状态</li>
<li>服务端接收到这个报文后,进入<code>SYN_RCVD</code>,返回一个<code>SYN+ACK=1+ack=client_seq+1+server_seq</code>的报文段</li>
<li>客户端接收到这个报文之后,就会发送一个<code>ACK</code>,进入了<code>ESTABLISHED</code>的状态,服务端在接收到这个<code>ACK</code>之后,也就会进入到一个<code>ESTABLISHED</code></li>
</ul>
<p>然后就可以基于这个TCP进行数据的发送了,注意这个过程,建立TCP报文的时候,实际上也是需要底层的IP支持的,因此在第一个报文发出的时候,会经历这样的过程:</p>
<p>第六步,底层的IP协议接收到来自上层的TCP报文段之后,这时候就会将上层的TCP报文段包装成一个IP包,<strong>IP 包的最重要的字段就是源IP地址和目的IP地址</strong></p>
<p>主要的过程是这样的,首先主机拿到这个IP报文,然后它会比对操作系统内核中提供的一个叫做路由表的数据结构,将当前的目标IP地址和每一项的子网掩码进行与运算,如果与运算后的结果和条目表中的IP地址是相同的,那么就选择这个条目中规定的网卡进行数据的发送,这就确定了源IP地址</p>
<p>当匹配到最后一项的时候,这代表着当前主机并不直接和这个网络下的网络设备连接,而是要通过本网络的网关进行转发,具体的格式是<code>0.0.0.0 GateWay </code>,然后主机就将数据转发到网关了</p>
<p>当转发到网关的时候,这时候网关就查询路由表,具体的就是<code>&lt;目标IP地址,子网掩码,转发端口号&gt;</code>,也就是将IP地址和子网掩码进行与运算,如果和目标IP地址吻合,那么就直接通过这个端口转发出去,否则还需要经过默认网关</p>
<p>第七步,经过了大量的路由转发,这时候到了目标主机所在的子网内,这时候就通过<code>ARP</code>协议来进行IP地址和MAC地址的转换,具体来说是这样的:</p>
<p>(1)当ARP缓存中<code>IP地址=&gt;MAC地址</code>的映射的话,这时候就直接取出<code>MAC</code>地址,然后封装<code>MAC</code>帧发送即可</p>
<p>(2)当没有的时候,这时候就需要执行一个广播,也就是说,在局域网内广播<code>谁的IP是&#123;IP&#125;?,请发送你的MAC地址过来</code>,然后这时候收到验证的设备就会回播一个<code>MAC地址</code>,收到这个<code>MAC</code>地址之后,就会在ARP缓存中存下来</p>
<p>在局域网内,就通过<code>CSMA/CD</code>协议发送数据包,然后在发送出去之前,还需要FCS的计算等操作,然后通过调频调幅调相的过程,将数字信号转换为频带信息,这时候就进行真正的网络传输了</p>
<p>当这个数据包到达对方主机后,就会通过<code>数据链路层=&gt;网络层=&gt;传输层=&gt;应用层</code>这样的顺序,不断拆解头部,然后就可以得到实际的数据了</p>
<h2 id="TCP的基本认识">TCP的基本认识</h2>
<h3 id="TCP的头部字段">TCP的头部字段</h3>
<p><code>TCP</code>的头部字段通常有:<code>序列号(在建立连接的时候,由计算机产生的随机数作为初始值,通过SYN包传给接收端的主机,每次发送一个数据,就累加一次该数据字节数的大小,用来解决网络包乱序的问题)</code>、<code>确认应答号(指下一次期望收到的序列号)</code>,控制位,主要是用来沟通两台主机的状态变化</p>
<p><strong>ACK</strong>:当这个位为1的时候,<code>表示是一个确认上一次应答的包,此时ack的值是生效的</code></p>
<p><strong>RST</strong>:当这个位为1的时候,表示检测到当前的TCP环境产生了异常,必须强制断开连接</p>
<p><strong>SYN</strong>:表示希望建立连接,并且在<code>seq</code>字段中进行初始化</p>
<p><strong>FIN</strong>:表示希望关闭这一方的数据传送通道</p>
<h3 id="为什么需要TCP协议">为什么需要TCP协议?</h3>
<p>TCP协议工作在<code>IP</code>协议之上,那么就要谈到<code>IP</code>协议设计的功能了:</p>
<p><strong>路由选择</strong>、<strong>分组转发</strong>,假设没有TCP协议,那么假设传输过程中路由器故障,那么就会导致数据全部丢失,而对于传输双方来说是无法感知的,因此在这样的情况下,就必须要有一个工作在IP层之上的协议,来控制这个IP协议的传输了,IP协议它无法保证网络包的可靠交付,不保证网络包的按序交付,也不保证网络包的数据完整性</p>
<p>因此在这样的情况下,TCP的出现可以使得网络数据包的可靠传输,按序交付,数据报的完整性</p>
<h2 id="TCP是什么">TCP是什么?</h2>
<p><code>TCP</code>叫做传输控制协议,它的特点是:</p>
<p><strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流</strong>的传输协议</p>
<p>所谓面向连接,就是要建立起一条逻辑连接信道之后,才能进行后续的传输,它一定是一对一的通信传输连接,一对多是无法做到的</p>
<p>所谓可靠的,就是无论底层的网络出现了怎么样的变化,它在允许的情况下<code>(超时重传次数允许的情况下,一定能够完成数据报的可靠交付)</code></p>
<p>所谓面向字节流的这个概念,要和面向数据报的概念进行联合讲解,所谓面向数据报,说的是上层应用交付怎么样的数据报,传输层就传输怎么样的数据回去,因此对等端传输地数据总是按照用户的意愿的</p>
<p>但是面向字节流可能会将上层应用交付的一个应用数据包拆分成多个报文段,然后分别发送,如果消息报文段没有规定确切的边界,那么是无法读取出有效的信息的</p>
<h2 id="如何来描述一个TCP连接">如何来描述一个TCP连接</h2>
<p>一个TCP连接是用于保证可靠性和流量控制的某些状态信息,这些信息的组合,包括有<code>Socket</code>、<code>序列号</code>、<code>窗口大小</code>用来描述一个连接</p>
<p><strong>Socket</strong>:ip和端口号</p>
<p><strong>序列号</strong>:用来解决乱序问题的</p>
<p><strong>窗口大小</strong>:做流量控制的</p>
<blockquote>
<p>如何唯一确定一个TCP连接?</p>
</blockquote>
<p>TCP的四元组=&gt;<code>&#123;目的IP地址,目的端口号,源IP地址,源端口号&#125;</code></p>
<blockquote>
<p>有一个IP的服务端监听了一个端口,它的TCP的最大连接数是多少?</p>
</blockquote>
<p>IP数最多有<code>2^32</code>,端口数最多有<code>2^16</code>,因此最多可以维持<code>2^48</code>个连接</p>
<p>连接还会受到系统的其他资源的限制</p>
<p><strong>文件描述限制</strong>:每个TCP连接都是一个文件,如果文件描述符被占满了,那么就会发生<code>TooManyOpenFile</code>的异常</p>
<p><strong>内存限制</strong>:每个TCP连接都要占用一定的内存,操作系统的内存是有限的,如果内存被打满了,那么就会发生OOM</p>
<h2 id="TCP和UDP有什么区别">TCP和UDP有什么区别?</h2>
<p>关于TCP和UDP的区别,可以从以下几个方面进行区分:</p>
<p>(1)连接</p>
<ul>
<li>TCP是面向连接的传输协议,传输数据之前先要建立连接</li>
<li>UDP是面向无连接的传输协议,传输数据之前不需要创建连接</li>
</ul>
<p>(2)数据载体</p>
<ul>
<li>TCP是面向字节流的,消息没有边界,但是可以保障有序性和可靠性</li>
<li>UDP是面向数据报的,可能导致丢包和乱序</li>
</ul>
<p>(3)可靠性</p>
<ul>
<li>TCP基于滑动窗口+序列号+响应机制实现了可靠性</li>
<li>UDP不保证可靠性</li>
</ul>
<p>(4)首部的开销</p>
<ul>
<li>TCP的首部一定要占20个字节,当采用了例如SACK之类的机制的时候,这时候还会占用最多20个字节,因此最多40个字节</li>
<li>UDP首部只有8个字节,四个字段,分别是<code>&#123;目的端口,源端口,校验和,包长度&#125;</code></li>
</ul>
<p>(5)服务对象</p>
<ul>
<li>TCP的服务对象是一对一的</li>
<li>UDP的服务对象可以是多个</li>
</ul>
<p>(6)拥塞控制和流量控制</p>
<ul>
<li>TCP基于响应应答机制+滑动窗口可以实现拥塞控制</li>
<li>UDP无论网络情况如何,都是直接发送数据的</li>
</ul>
<p>(7)分片不同</p>
<ul>
<li>TCP会在传输层实现分片</li>
<li>UDP不会分片,它会将分片的任务交给IP层</li>
</ul>
<h2 id="简述一下TCP三次握手的流程">简述一下TCP三次握手的流程</h2>
<p>(1)初始化的情况下,<code>Client</code>和<code>Server</code>都处于一个<code>CLOSED</code>的状态,然后此时<code>Server</code>被动打开连接,进入到一个<code>LISTEN</code>的状态,然后客户端请求建立连接,也就是进入一个<code>SYN_SEND</code>的状态</p>
<p>这个报文包含有的信息主要有<code>client</code>初始化之后的序列号,以及带有<code>SYN</code>标记的数据包,表示希望和<code>Server</code>建立连接</p>
<p>(2)服务端在收到第一个握手包之后,进入到一个<code>SYN_RCVD</code>的状态,然后此时就要发送回去一个响应,这时候同时会初始化自己的序列号</p>
<p>这个报文包含有的信息主要有<code>server</code>初始化之后的序列号,以及带有<code>SYN</code>标记的数据包,同时会将<code>ACK=1</code>,<code>ack =client_isn+1</code>,表示正在和<code>client</code>建立连接,正确收到了上一次连接请求包</p>
<p>(3)客户端在收到服务端的<code>ACK+SYN</code>之后,这时候就进入了一个<code>ESTABLISHED</code>的状态,这也就代表着可以发送数据了,这时候会对上一次的<code>SYN</code>做一次<code>ACK</code>,也就是:</p>
<p>这个报文包含的信息主要有<code>ACK=1</code>,<code>ack = server_isn+1</code>,表示已经正确收到<code>server</code>的同步连接请求包,注意,由于此时是<code>ESTABLISHED</code>的状态,因此这时候可以携带数据,也可以不携带数据</p>
<p>(4)服务端接收到客户端的<code>ACK = 1,ack = server_isn+1</code>的包之后,这时候就会进入到<code>ESTABLISHED</code>的状态了</p>
<blockquote>
<p>如何查看TCP连接的状态?</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt</span><br></pre></td></tr></table></figure>
<h2 id="为什么TCP的握手需要三次">为什么TCP的握手需要三次?</h2>
<h3 id="从建立全双工连接的角度上来说">从建立全双工连接的角度上来说</h3>
<p>从全双工的角度上来看,三次握手可以实现双方的收发正常,非常好理解</p>
<p>(1)第一次握手报文,什么都确定不了,客户端无法确定自己的报文是否到达服务端,也就是无法确认自己是否有发送能力,同时也无法确认接收方是否有接收能力和发送能力</p>
<p>(2)第二次握手报文,此时客户端可以确定自己的报文到达了服务端,也就是可以确认自己具有发送能力,同时具备接收能力,于是它就进入了<code>ESTABLISHED</code>的状态,但是服务端只可以确认自己具有接收能力,但是不确定具有发送能力,于是只是保持<code>SYN_RCVD</code>的状态,于是客户端此时发送<code>ACK</code></p>
<p>(3)第三次握手报文,此时服务端收到后,进一步确定了发送能力,于是进入了<code>ESTABLISHED</code></p>
<h3 id="从确定一条TCP连接的角度上来说">从确定一条TCP连接的角度上来说</h3>
<p>从这个角度上来看,三次握手的首要原因是为了要排除历史连接的错误</p>
<p>(1)<code>排除历史连接的错误</code>,首先,假设这样一个场景,也就是说,当TCP建立的时候,这时候网络阻塞了,于是TCPSYN报文一直发送不到服务端,然后客户端重置连接,在网络通畅的时候,这时候就会重新发送<code>SYN</code>,这时候就出现了一种情况了:<code>网络中同时存在新的连接报文和旧的连接报文,而且这两个报文什么时候到达服务端是不确定的</code>,因此下面就来讨论一下:假设新的连接报文序号是<code>90</code>,假设旧的连接报文序号是<code>100</code></p>
<ul>
<li><strong>如果新的连接报文比旧的连接报文要先到达</strong></li>
</ul>
<p>这时候新的连接报文到达服务端之后,服务端会返回<code>SYN+ACK+ack = 91</code>,客户端收到这个ACK之后,然后发送<code>ACK</code>,此时<code>TCP</code>连接就建立好了,如果此时旧的连接报文到达的时候,这时候就会触发一个<code>ChallengeACK</code>,这个<code>ACK</code>的作用主要是为了检查当前的<code>SYN</code>是否有效,也就是回复一个<code>SYN+ACK+ack=91</code>的包回去,给客户端检查,如果客户端检查发现和上下文环境不符合,那么就发送<code>RST</code>报文。</p>
<ul>
<li><strong>如果旧的连接报文比新的连接报文要先到达</strong></li>
</ul>
<p>如果旧的连接报文比新的连接要先到达的时候,服务端也会返回<code>SYN+ACK+ack = 100</code>,客户端收到这个ACK,检查上下文环境是<code>91</code>,因此会发送<code>RST</code>报文,此时就会重置连接了,在后续新的报文到达的时候,就可以正常接收连接了</p>
<blockquote>
<p>之所以要三次握手,可以假设只有两次握手会发生什么</p>
</blockquote>
<p>如果只有两次握手,那么就意味着服务端返回了<code>SYN+ACK+ack</code>的话,就直接进入了<code>ESTABLISHED</code>,这实际上是非常草率的过程,也就是说服务端并不能够确认自己具有发送能力的同时,同时无法避免历史报文的影响,如果收到的是历史报文,那么就会建立一个历史连接,然后服务端就会发送数据,这会导致网络资源的浪费</p>
<p>(2)基于三次握手可以实现双方序列号的同步</p>
<p><strong>序列号</strong>是实现TCP的关键数据结构,通过这个字段,可以实现:</p>
<ul>
<li>数据包的有序传输,可以将那些乱序的数据包丢弃</li>
<li>数据包的可靠传输,便于超时重传</li>
<li>可以知道哪些报文是已经被接收的了</li>
</ul>
<p>通过三次握手,第一次握手,告知服务端,客户端的初始化序列号,不确定服务端收到没有</p>
<p>第二次握手,告诉客户端关于服务端的初始化序列号,不确定客户端收到没有,但是可以确定服务端收到了客户端的初始化序列号</p>
<p>第三次握手,告诉服务端,服务端的初始化序列号接收到了</p>
<p>(3)避免资源的浪费</p>
<p>假设只有两次的握手,资源的浪费主要体现在,历史连接导致的无效的数据传输、一个SYN报文就对应一个连接,如果是重传的SYN报文,那么就可能导致大量的无效连接,同时可能导致被不法分子利用,基于泛洪SYN来对服务器进行攻击</p>
<h3 id="总结-3">总结</h3>
<ul>
<li>两次握手:无法防止历史连接的建立,会造成双方资源的浪费,也无法可靠的同步双方的序列号</li>
<li>四次握手:理论上三次握手就可以实现可靠的连接建立了,不需要更多的握手次数</li>
</ul>
<h2 id="初始化的序列号相同该怎么办-会有什么问题">初始化的序列号相同该怎么办?会有什么问题?</h2>
<p>首先假设初始化的序列号相同会发生什么,假设每一次的TCP连接都是从0开始的</p>
<p>假设<code>Server</code>和<code>Client</code>建立了连接,然后从0开始发送数据,然后发送到序号为<code>50</code>的时候,此时发送了大量的超时重传,然后超过了次数限制之后,就发送了<code>RST</code>报文,重置了这个连接,但是注意,序号为<code>50</code>的报文此时还是残留在网络中的,因此在这样的情况下</p>
<p>然后重新建立连接,从0开始发送数据,然后发送到序列号为50的时候,此时发送的数据包和超时数据包混合在一起,这时候就产生了数据异常了</p>
<p>为了解决这个问题,TCP设计的序列号初始化是随机的,尽量来避免历史连接的序列号来影响本次连接,但是要注意,序列号是有回绕现象的,也就是说当序列号到达了<code>2^32-1</code>之后,又会变成0,因此在这样的情况下,就要使用时间戳来实现了,简单来说就是看你这个数据包的时间戳是否是递增的,如果是递增的话那么就接收,否则就关闭</p>
<h2 id="IP层会分片-为什么还需要MSS呢">IP层会分片,为什么还需要MSS呢?</h2>
<p><code>MTU</code>:一个网络包的最大长度,以太网中一般是<code>1500</code>个字节</p>
<p><code>MSS</code>:除去TCP和IP头部之后,一个网络包所能容纳的最大数据长度</p>
<p>假设只有IP的分层的话,那么在这样的情况下,首先对于一个IP报文而言,这个报文的数据部分是由<code>TCP头部和TCP数据段</code>组成的,如果IP包的大小超过了MTU的情况下,那么需要IP就进行分片了,那么在这样的情况下,假设一个IP分片丢失了,那么就会导致整个TCP报文段的重传,为了避免这样的现象影响效率,于是使用了MSS</p>
<p>这个MSS是这样起作用的,简单来说,就是当TCP组装报文段的时候,如果这时候报文段的长度超过了<code>MSS</code>,那么就会在传输层进行分片,如果一个TCP分片丢失了,那么就只需要重传这一个分片就可以了</p>
<h2 id="如果第一次握手报文丢失了-会发生什么">如果第一次握手报文丢失了,会发生什么?</h2>
<p>注意,这种状态的特殊报文段一般的逻辑是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有收到数据报=&gt;触发超时重传=&gt;重传次数到达上限=&gt;断开连接=&gt;客户端单方面断开连接</span><br></pre></td></tr></table></figure>
<p>详细:当第一次握手报文,也就是<code>SYN</code>的报文传出去之后,然后这时候<code>SYN+ACK</code>没有被收到,由于发送的是<code>SYN</code>包,因此在这样的情况下,就会触发重传,第一次超时重传是1s之后,之后就会在*2,也就是<code>1+2+4+8+16+32</code>,当达到了这个上限之后,这时候就不会再重传了,而是操作系统内核将这条连接进行释放</p>
<h2 id="如果第二次握手报文丢失了-会发生什么">如果第二次握手报文丢失了,会发生什么?</h2>
<p>首先明确这时候双方发送数据包的性质:</p>
<p><strong>客户端发送的是SYN数据包,不是纯ACK包,因此当发生了超时的时候需要进行重传</strong></p>
<p><strong>服务端发送的是SYN+ACK数据包,不是纯ACK包,因此当发生了超时的时候需要进行重传</strong></p>
<p>那么在这样的情况下,当第二次握手报文丢失的时候</p>
<p><strong>从客户端的角度上来看,就是没有收到ACK,因此会重传SYN数据包</strong></p>
<p><strong>从服务端的角度上来看,就是没有收到客户端的第三次握手报文,于是会重传SYN+ACK数据包</strong></p>
<p>然后从状态转移来看,如果客户端重传的<code>SYN</code>报文到达了服务端,那么这时候服务端就会重传<code>SYN+ACK</code>,因为是重传,那么无论是<code>ChallangeACK</code>亦或者是<code>正常的ACK</code>,都是原来的序列号</p>
<p>当客户端收到这个<code>SYN+ACK</code>之后就会进入到<code>ESTABLISHED</code>,然后继续后续的传输了</p>
<p>如果后续重传到达了一定的次数的时候,任意一端都会关闭连接</p>
<h2 id="如果第三次握手报文丢失了-会发生什么">如果第三次握手报文丢失了,会发生什么?</h2>
<p>首先先来分析上下文的性质,首先:</p>
<p><strong>第二次握手的报文属于是SYN+ACK,具有重传的义务</strong></p>
<p><strong>第三次握手的报文属于ACK报文,可以携带数据,因此需要分情况讨论</strong></p>
<p>当第三次握手的报文没有携带数据的话,那么客户端就不会重传,这时候服务端就会不断重传<code>SYN+ACK</code>,达到超时的次数之后,就会通知操作系统内核释放这个连接</p>
<p>当第三次握手的报文有携带数据的时候,那么客户端就会重传,这时候断开连接的权利掌握在双方</p>
<h2 id="什么是SYN攻击-如何避免SYN攻击">什么是SYN攻击?如何避免SYN攻击?</h2>
<p>要理解这个问题,你首先要理解一次连接在操作系统内核是如何发生的</p>
<p>以<code>Linux</code>系统为例,它是这样管理的,首先是一个主机的<code>SYN报文</code>发送过来,如何这时候操作系统内核就会将相关的信息封装成一个结构体,然后将这个结构体放入到一个内核中一个叫做<code>SYN连接队列的数据结构</code></p>
<p>然后这时候内核会扫描这个队列,然后发送<code>SYN+ACK</code>给对等端,如果对等端发送一个ACK的时候,这时候就会从<code>SYN连接队列</code>中<code>pop()</code>出来一个数据结构,然后将这个<code>数据结构push()</code>到一个<code>accept队列</code>中,然后操作系统内核就会提供一个系统调用<code>accept()</code>,如果调用<code>accept()</code>就会从这个队列中<code>pop()</code>出来,然后提供操作系统的系统调用来对这个<code>socket</code>进行读写。</p>
<blockquote>
<p>至于如何防范SYN攻击,就需要从半连接队列如何被打满的这个角度来进行分析了</p>
</blockquote>
<p><strong>方法一:设置Linux系统内核中的半连接队列的大小,具体来说有三个参数</strong></p>
<p><strong>方法二分析:当发生了半连接队列被打满的时候,这时候最严重的后果就是后续的报文被丢弃,于是我们可以将保存多余数据包的调大,这时候就可以降低半连接队列被打满的副作用</strong></p>
<p><strong>方法三分析:半连接队列被打满的时候,会导致连接无法建立,那么在这样的情况下,我们可以绕过SYN半连接队列的方法来解决这个问题,具体的流程是这样的:</strong></p>
<ul>
<li>当SYN队列满了之后,后续队列收到新的SYN包的时候,这时候不会创建数据结构并且<code>push()</code>到半连接队列中,这时候它会通过一定的算法,生成一个<code>cookie</code>,这个<code>cookie</code>后续可以通过一定的算法来验证这个<code>Cookie</code>的合法性,如果合法,那么就说明是之前本机生成的<code>cookie</code></li>
<li>如果合法,那么就会将对象放入到<code>accept队列中</code></li>
</ul>
<p><strong>方法四分析,如果可以尽快确认这个SYN报文是无效的,并且将这个连接从内核中删除,那么一定程度上就可以解决这个问题,我们可以通过减少<code>SYN+ACK</code>的重传次数以及重传的间隔时间,就可以让这些SYN来得快,去得也快,最终就可以实现SYN队列的空余</strong></p>
<h2 id="简述TCP四次挥手过程">简述TCP四次挥手过程</h2>
<p>关于<code>TCP四次挥手的流程</code>,可以这样讲述:</p>
<p>第一步,客户端完成了本机的数据传输,因此这时候就会发送一个控制位为<code>FIN = 1</code>的数据包到服务端,这时候客户端进入到一个<code>FIN_WAIT_1</code>的状态,这时候根据全双工的流程,客户端关闭了发送的通道,但是保留了接收的通道</p>
<p>第二步,服务端收到<code>FIN = 1</code>的数据包,这时候服务端因为是被动关闭,有可能还有数据没有发送完毕,因此这时候进入了<code>CLOSE_WAIT</code>,表示等待本机从剩余数据发送完,然后就会发送一个<code>ACK</code>,让对方知道之前<code>FIN = 1</code>的数据包已经收到了</p>
<p>第三步,服务端发送剩余数据</p>
<p>第四步,服务端数据发送完毕,这时候服务端就会发送一个<code>FIN = 1</code>的数据包,表示服务端也关闭发送的通道了,这是会需要等待客户端的最后<code>ACK</code>，因此进入了<code>LAST_ACK</code>的状态</p>
<p>第五步,客户端收到<code>FIN = 1</code>,表示客户端收到了服务端通知关闭发送通道的通知,然后发送<code>ACK</code>,表示确认,然后进入到<code>TIME_WAIT</code></p>
<p>第六步,服务端收到了<code>ACK</code>,于是进入到了<code>CLOSED</code>状态</p>
<p>第七步,客户端<code>TIME_WAIT</code>结束,进入到<code>CLOSED</code>状态</p>
<blockquote>
<p>注意:主动关闭连接的才会有<code>TIME_WAIT</code>的状态</p>
</blockquote>
<h2 id="为什么挥手是四次">为什么挥手是四次?</h2>
<p>首先分析一下,如果只有三次挥手会怎么样?</p>
<p>如果只有三次挥手,客户端发送一个<code>FIN</code>，表示此时关闭发送通道,然后服务端发送一个<code>FIN+ACK</code>,表示服务端关闭发送通道和接收通道,然后客户端收到这个<code>ACK</code>之后,还要回包<code>ACK</code>,表示知道了对方要关闭了</p>
<p>三次挥手在<strong>服务端没有多余的数据的时候,是可以变成三次挥手的</strong>,但是通常来说<code>FIN+ACK</code>是会分开发送的</p>
<h2 id="第一次挥手丢失了会发生什么">第一次挥手丢失了会发生什么?</h2>
<p>第一次挥手是主动关闭者发送<code>FIN</code>报文,如果第一次挥手无法得到对方的<code>ACK</code>,那么就会触发超时重传,因此这时候的逻辑是这样的,会在一段时间内不断重传<code>FIN</code>报文,如果超过了重传的次数,那么就会直接进入到<code>CLOSED</code>的状态,后续的报文处理会基于操作系统内核对这个报文的定义,通常来说会基于<code>RST</code>报文来对这些进行限制</p>
<h2 id="第二次挥手丢失了会发生什么">第二次挥手丢失了会发生什么?</h2>
<p>首先明确,第二次挥手是一个<code>ACK</code>报文,因此在这样的情况下,<code>ACK</code>报文不会重传,只会认为是对等端发送失败了,因此在这样的情况下,就会引发对等端不断重传<code>FIN = 1</code>的报文,当超过了次数之后,这时候客户端就会直接关闭掉了</p>
<p>那么这时候就会问了,那么服务端呢?服务端一旦进入了<code>CLOSE_WAIT</code>的状态之后,这时候关闭的权限不是交给<code>操作系统内核的</code>,而是交给了用户程序,只有在用户程序调用了<code>CLOSE()</code>之后,才会发送第三次的<code>FIN报文</code>,因此这里可能会有死等的风险,这个解决办法需要通过编码来避免,也就是一定要调用<code>close()</code></p>
<h2 id="第三次挥手丢失了会发生什么">第三次挥手丢失了会发生什么?</h2>
<p>上面提到了,如果服务端进入到了<code>CLOSE_WAIT</code>,除了用户程序调用<code>close()</code>,否则一直就卡在这个状态,在数据发送完毕后,这时候就会将<code>FIN</code>报文发送出去,如果发送的时候不断超时,不断重传,无法收到对方的ACK,那么这时候在超过了<code>重传次数</code>之后,就会直接关闭连接</p>
<h2 id="第四次挥手丢失了会发生什么-重要">第四次挥手丢失了会发生什么?(重要)</h2>
<p>第四次挥手错误是TCP处理中最为核心最为复杂的一个过程</p>
<p>当客户端收到了服务端的FIN之后,这时候就会发送第四次挥手,也就是回复一个<code>ACK</code>给上次的<code>FIN</code>,那么如果这个ACK一直没有被收到的话,那么服务端就会不断重传<code>FIN</code>,客户端一直处于一个<code>TIME_WAIT</code>的状态,于是在这样的情况下,会出现的情况是</p>
<p><strong>服务端不断重传FIN直到达到超时的次数,然后断开连接</strong></p>
<p><strong>客户端无感知,它认为是ACK报文到达了,因此在2MSL之后,就会自动关闭连接</strong></p>
<h2 id="为什么TIME-WAIT是2MSL">为什么TIME_WAIT是2MSL?</h2>
<p>首先你要理解什么是<code>MSL</code>,所谓的<code>MSL</code>就是报文最大生存时间,与之相对的有<code>IP</code>协议中的<code>TTL</code>,它表示IP数据报经过的跳数,在Linux设置中,通常是设置TTL是64,MSL是30s,那么在这个时间段内,TCP报文都是有效的,超过这个时间,那么就被认为是无效报文,会被路由转发设备给丢弃,这意味着,一个报文在传输过程中,如果超过了MSL,那么这个报文就会被丢弃。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去最多2个MSL。</p>
<p>如果在2MSL内,都没有再收到这个FIN,那么就认为对方已经收到了这个ACK</p>
<blockquote>
<p>为什么不是4MSL或者8MSL呢?</p>
</blockquote>
<p>这个问题我认为和超时重传的时间设置有关,一般来说,超时重传的时间会被设置为小于MSL,因此在这样的情况下,2MSL完全够用,这里说的够用,说的意思是能够确保服务端收到了这个ACK并且重传FIN能够被客户端感知到</p>
<p>如果大于了<code>MSL</code>,那么这时候就可能需要4MSL或者8MSL了,但是实际上不会这样来设置超时时间</p>
<p>亦或者是<code>触发了超时重传,但是FIN报文阻塞在路由器中无法发出,这时候也会导致超过2MSL</code>,但是这都是小概率事件,忽略这些事件比用复杂的逻辑去处理他们更加有性价比</p>
<h2 id="深入剖析TIME-WAIT的状态">深入剖析TIME_WAIT的状态</h2>
<p>之所以需要<code>TIME_WAIT</code>的状态,主要有两个原因:</p>
<p><strong>防止历史连接中的数据,被后面相同的四元组接收</strong></p>
<p>假设这样一种场景,如果没有<code>TIME_WAIT</code>的话,那么这就意味着直接关闭,网络上可能残留有上一次连接的数据报文,因此在这样的情况下,就可能导致下一次相同连接的四元组,恰好序列号又是也一样的,这样的话就会导致数据被错误接收,因此为了避免这样的情况,因此就可以使得上一次报文全部消失之后再建立下一次连接</p>
<p><strong>保证被动关闭连接的一方,能被正确关闭</strong></p>
<p>被动关闭的一方是我们的服务端,假设没有<code>TIME_WAIT</code>的状态,如果你客户端的ACK直接丢失了,那么服务端发来了FIN之后,虽然也能够被重置的RST报文进行重置,但是这不是一种正常关闭的状态,是不优雅的,因此设置了这个状态来进行过度</p>
<h2 id="TIME-WAIT过多有什么危害">TIME_WAIT过多有什么危害?</h2>
<p><strong>占用系统资源,比如说文件描述符,内存资源,CPU资源,线程资源</strong></p>
<p><strong>占用端口资源</strong></p>
<p>如果客户端的<code>TIME_WAIT</code>状态过多,占满了所有的端口资源,那么就无法对<code>&lt;目的IP,目的端口&gt;</code>发起连接了,但是使用的端口,还是可以继续对另外一个服务端发起连接,这是因为内核在识别数据要转发到哪个进程的时候,会根据定义<code>socket</code>的四元组来进行确定,只要有一个字段不同,就算一条不同的连接,就是一个不同的socket</p>
<p>如果服务端的<code>TIME_WAIT</code>过多,不会导致端口资源受限,因为服务端只监听一个端口,它操作的是连接对象,但是当<code>TIME_WAIT</code>过多的时候,这时候会导致系统资源被浪费</p>
<h2 id="TIME-WAIT如何排查">TIME_WAIT如何排查?</h2>
<blockquote>
<p>出现大量TIME_WAIT有什么原因?</p>
</blockquote>
<p><code>TIME_WAIT</code>只有在主动发起断开连接请求的一方才有,因此要从这个角度来入手</p>
<p><strong>HTTP没有使用长连接</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>客户端禁用了长连接,而服务端开启了长连接,谁来关闭连接?</strong></li>
</ul>
<p>服务端来关闭,这是因为客户端关闭了长连接,这意味者客户端仅发起一次请求就下线了,关闭连接的这件事情要交给服务端来确认,我们将关闭连接这件事情交给本次请求的末端是合理的</p>
<ul>
<li><strong>客户端开启了长连接,而服务端关闭了长连接,谁来关闭连接?</strong></li>
</ul>
<p>服务端来关闭,这个又是需要基于操作系统的开销来考量了</p>
<p>如果是客户端关闭这个长连接,那么意味着服务端需要将这个连接放入到操作系统内核的等待队列中,然后不断监听连接事件,当发生了连接关闭事件之后,这时候就还需要发起系统调用,这时候socket会有不必要的等待时间+；两次系统调用</p>
<p>如果是服务端来关闭这个长连接,那么意味着服务端只需要调用一次close(),然后剩下的交给TCP协议栈处理就可以了</p>
<p><strong>HTTP长连接超时</strong></p>
<p>当超时的时候,这时候服务端就会自动调用close()来关闭连接</p>
<p><strong>HTTP长连接请求到达了上限</strong></p>
<p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100 次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<blockquote>
<p>解决方案?</p>
</blockquote>
<p><strong>方法一:开启TCP连接复用,也就是说,在处于TIME_WAIT状态的TCP连接中抽取连接,然后重置它的状态,使之成为一个新的连接对象,并且为之所用,这样的话就可以减少TIME_WAIT的数量</strong></p>
<p><strong>方法二:强制重置,也就是说当TIME_WAIT超过了一定的阈值之后,这时候会将之后的连接给直接重置</strong></p>
<p><strong>方法三:通过编程,在close()添加一个SO_LINER来绕过TIME_WAIT,直接重置连接即可</strong></p>
<h2 id="什么是CLOSE-WAIT-大量出现了CLOSE-WAIT怎么办">什么是CLOSE_WAIT?大量出现了CLOSE_WAIT怎么办?</h2>
<p>首先这个状态出现服务端收到<code>FIN = 1</code>的报文之后,这个状态的终止需要用户进程调用<code>close()</code>才能解决</p>
<p>一个普通的TCP服务端的流程:</p>
<p><strong>将服务端socket,bind绑定端口,listen监听端口</strong></p>
<p><strong>将服务端socket注册到epoll中</strong></p>
<p><strong>epoll_wait等待连接到来的时候,调用<code>accept()</code>获取连接</strong></p>
<p><strong>epoll_wait等待事件发生</strong></p>
<p><strong>调用close()</strong></p>
<p>第一个原因,没有使用<code>accept()</code>,因此积压了大量的<code>CLOSE_WAIT</code></p>
<p>第二个原因,大量的客户端主动断开了连接,也就是说那种发送了第一个<code>SYN</code>之后,然后就失联的</p>
<p>第三个原因,没有监听socket,没机会调用close</p>
<p>第四个原因,没用close</p>
<h2 id="客户端突然出现了故障怎么办">客户端突然出现了故障怎么办?</h2>
<p>为了解决这个问题,提出了一个保活机制,也就是在一个连接上没有任何的数据传送的时候,这时候就基于保活机制,每隔一个时间间断,就会发送一个探测报文,如果连续好几个报文都没有响应回包,那么这时候就认为这个TCP连接就已经死亡了,系统内核就会将错误信息上报</p>
<p>一般来说,有三种情况:</p>
<p>第一种情况,TCP对等端存活,保活计时器重置</p>
<p>第二种情况,TCP对等端进程重启了,此时对等端会返回一个RST报文,然后重置连接</p>
<p>第三种情况,TCP对等端宕机,探测报文石沉大海,此时直接释放服务器的连接</p>
<h2 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？">如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h2>
<p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p>
<p>我自己做了个实验，使用 kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文与客户端进行四次挥手</strong>。</p>
<h2 id="什么是HTTP协议">什么是HTTP协议?</h2>
<p><code>HTTP协议</code>翻译过来就是<code>超文本传输协议</code>,关键字是如下三个:</p>
<p><strong>超文本</strong>:它是HTTP协议传输数据的数据的格式,具体来说,超文本就是一个超越文本的文本,它是视频、图片、视频等链接的载体,能够从一个超文本跳转到另外一个超文本,这是超文本最重要的特性</p>
<p><strong>传输</strong>:所谓传输,就是提供一个协议,这个协议可以实现一个进程和其他进程的通信,它是一个双向的协议,通过这个协议可以实现两个进程之间的数据传输的约定和规范</p>
<p><strong>协议</strong>:它是HTTP的本质,在相同操作系统之中,可以基于<code>IPC(进程间通信,包括有管道,消息队列,socket,信号量,共享内存)</code>来实现进程间的通信,那么在网络上,由于不同进程之间,他们所在的操作系统可能是异构的,因此为了解决这个问题,提出了协议,所谓的协议,就是将要将网络上传输的这些数据的解析方式做一个限定,因为二进制数据是操作系统之间都可以识别的,通过协议,就可以将这些二进制数据进行正确的解析,然后就可以通过这些数据进行通信了</p>
<p>总而言之,HTTP协议是用来实现网络上两个进程之间的超文本传输的一个网络通信协议</p>
<h2 id="HTTP常见的状态码有哪些">HTTP常见的状态码有哪些?</h2>
<p><strong>1xx</strong>:这一类信息属于一个提示信息,是协议处理中的一个中间状态,实际中用到的比较少,比如说在升级<code>WebSocket</code>协议的时候,就会出现这个状态码,表示将要升级成<code>WebSocket</code>协议</p>
<p><strong>2xx</strong>:这个状态码表示服务器成功处理了客户端的请求</p>
<p><code>200 OK</code>:是最常见的状态码,表示一切正常,如果是非HEAD请求,服务器返回的响应头部会有body的数据</p>
<p><code>204 No Content</code>:是成功的状态码,和200OK是基本相同的,但是响应头中没有body数据</p>
<p><code>206 Partial Content</code>:是应用于HTTP分块下载或者断点续传,表示响应返回的body数据不是资源的全部,而是其中的一部分而已,它也表示服务器的处理是成功的</p>
<p><strong>3xx</strong>:状态码表示客户端请求的资源发生了变动,需要使用新的URL重新发送请求获取资源,也就是<code>重定向</code></p>
<p><code>301 Moved Permanently</code>:表示永久重定向,说明请求的资源已经不存在了,需要使用新的URL再次访问</p>
<p><code>302 Found</code>:表示临时重定向,说明请求的资源还在,但是暂时需要使用另外的一个URL来进行访问</p>
<blockquote>
<p>301和302都会在响应的头部使用字段Location,来指明后续将要跳转的URL,浏览器将会自动重定向到新的URL</p>
</blockquote>
<p><code>304 Not Modified</code>:表示资源没有修改,重定向到已经存在的资源文件,也称为是缓存重定向,也就是告诉客户端可以继续使用缓存,用于做一个缓存的控制</p>
<p><strong>4xx</strong>:表示发送的报文有错误,服务器无法处理,一般来说是前端发送的请求有错误</p>
<p><code>404 Bad Request</code>:表示客户端请求的报文是有错误的,但这是个笼统的错误</p>
<p><code>403 Forbidden</code>:表服务器禁止访问这个资源,不是你的请求有错误</p>
<p><code>404 Not Found</code>:表示资源在服务器上找不到,因此无法提供给用户</p>
<p><strong>5xx</strong>:表示客户端的请求报文是正常的,但是在服务器处理内部的时候发生了错误,属于这个服务器端的错误码</p>
<p><code>500 Internal Server Error</code>:和400是类似的,它是一个笼统的错误码,表示服务器发生了错误,但是具体是啥错误不知道,非常笼统</p>
<p><code>501 Not Implemented</code>:表示客户端请求的功能还不支持,类似于即将开业,敬请期待的意思</p>
<p><code>502 Bad GateWay</code>:通常是服务器作为网关或者代理的时候返回的错误,表示服务器自身的工作是正常的,但是真实的后端服务器访问出错</p>
<p><code>503 Service Unavailable</code>:表示服务器当前很忙,暂时无法响应客户端,请稍后再试</p>
<h2 id="HTTP的头部字段有哪些">HTTP的头部字段有哪些?</h2>
<p><strong>Host</strong>:假设这样一个场景,在一个<code>IP</code>主机上,部署了三个网站(容器),那么这个请求过去,要被哪个服务器来解析呢?这时候就可以基于<code>Host</code>字段来实现了,可以通过这个字段,将请求发送到同一个服务器上的不同网站</p>
<p><strong>Content-Length字段</strong>:服务器在返回数据的时候,会有<code>Content-Length</code>字段,表明本次回应的数据长度,HTTP协议是基于一个<code>TCP</code>协议进行通信的,如果使用了TCP传输协议,就会存在一个粘包的问题,HTTP协议通过在头部设置一个换行符作为头部的边界,通过<code>Content-Length</code>作为单个<code>HTTP Body</code>的边界,这两个方式都是为了解决粘包的问题</p>
<p><strong>Connection字段</strong>:常用于客户端要求服务器使用HTTP长连接机制,长连接就是讲只要任意一端没有明确提出断开连接的请求,就保持TCP的连接</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure>
<p><strong>Content-Type</strong>:用于服务器回应的时候,来告诉本次报文是什么格式,通常来说,这个字段和客户端的<code>Accept:</code>来联合使用的,通过这个字段,客户端就知道以什么样的编解码方式来获取本次的数据</p>
<p><strong>Content-Encoding</strong>字段,说明数据的压缩方法,表示服务器返回的数据使用了什么样的压缩格式</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br></pre></td></tr></table></figure>
<h2 id="Get请求和Post请求有什么区别">Get请求和Post请求有什么区别</h2>
<p>根据<code>RFC</code>规范,<code>GET</code>请求是从服务器中获取资源而不是推送资源,这个语义是只读的,这个资源是静态的文本、页面、图片视频等,GET请求的参数位置一般写在URL中,URL规定只能够支持ASCII,因此GET请求的参数只允许ASCII字符,并且对URL的长度是有限制的</p>
<p>根据<code>RFC</code>规范,<code>POST</code>请求向服务器推送资源,它不是安全的,也不是幂等的,POST请求数据通常写在body中,body中的数据格式是任意的,而且浏览器不会对body大小做限制</p>
<p><strong>GET</strong>的语义是获取指定的资源,Get方法是安全和幂等的,可以被缓存的</p>
<p><strong>Post</strong>的语义是根据请求负荷<code>body</code>中的字段对指定的资源做出处理,具体的处理方式根据资源类型的不同而不同,Post是不安全的,不幂等的,大部分实现是不可以缓存的</p>
<blockquote>
<p>Get请求可以带body吗?</p>
</blockquote>
<p>理论上可以的,因为从本质上来说,Get请求和Post请求都是一个HTTP报文,HTTP报文的格式是<code>首部+报文的主体</code>,同时POST请求中的URL也是可以带有一个参数的</p>
<h2 id="HTTP缓存的实现方式">HTTP缓存的实现方式?</h2>
<p>对于一些具有重复性的HTTP请求,比如说每次请求得到的数据都是一样的,就可以将这一对<code>请求=&gt;响应</code>的数据都缓存在本地,那么下一次就直接读取本地的数据,而不必在网络获取服务器的响应了,这样的话<code>HTTP/1.1</code>的性能就肯定有提升了,一般来说有<strong>强制缓存</strong>和<strong>协商缓存</strong></p>
<h2 id="什么是强制缓存">什么是强制缓存?</h2>
<p>所谓强制缓存,就是只要浏览器判断缓存没有过期,那么就直接使用浏览器的本地缓存,决定是否使用缓存的主动性在于浏览器,通常来说会通过一个状态码<code>200(from disk cache)</code>这个字段来确定,你当前获取的资源是通过缓存来获取的,那么具体来说是怎么实现的呢?它和Redis中的缓存过期时间比较相似</p>
<p><code>Cache-Control</code>:它是一个相对时间</p>
<p><code>Expires</code>:是一个绝对的时间</p>
<p><strong>Cache-Control</strong>:选项更多一些,设置得更加精细,具体的实现如下:</p>
<ul>
<li>当浏览器第一次请求访问服务器资源的时候,服务器会返回这个资源的同时,在请求头的首部加上一个<code>Cache-Control</code>,这个字段中设置了过期时间的大小</li>
<li>浏览器去请求资源的时候,会先访问本地缓存,如果本地缓存的<code>请求=&gt;响应</code>键值对中体现的<code>Cache-Control</code>过期了,那么就向服务器发送<code>HTTP</code>请求(不论资源是否变化,这时候服务器都会返回一份最新的数据),否则的话就走<code>from disk cache</code></li>
<li>服务器再次收到请求之后,会更新本地缓存中的<code>Cache-Control</code></li>
</ul>
<h2 id="什么是协商缓存">什么是协商缓存?</h2>
<p>首先先来理解强制缓存有什么弊端,强制缓存的弊端主要在于:</p>
<p><strong>无论服务器上的资源和本地缓存中的资源是否相同,服务器在收到这个请求之后,都会发送一份最新的数据回来</strong></p>
<p>因此在这样的情况下,可能导致无效的IO,于是就提出了协商缓存,所谓协商缓存,就是在本地缓存过期了之后,这时候会向服务器验证本地缓存和远程服务器资源的一致性,如果是相同的,那么就不会再发送最新的数据,而是发回一个信号,说资源没有改动过,本次不发送最新的数据,请你使用本地的资源就可以了</p>
<p>那么是怎么来实现的呢?一般来说有两种策略</p>
<ul>
<li><strong>根据资源上一次被改动的时间</strong>,这个策略就是<code>if-modified-since =&gt; modified-since</code>来实现的</li>
</ul>
<p>具体来说是这样的,就是当浏览器客户端发现本地资源过期了,然后它发现这个资源的响应头中有<code>modifed-since</code>字段,它就会将这个字段的值给赋值到<code>if-modified-since</code>中,然后在请求头上带上这个字段</p>
<p>然后在服务器的一端,收到这个请求之后,就会比较这个<code>if-modified-since</code>和<code>对应资源的修改时间</code>,如果资源的修改时间更大,那么返回最新的数据,这时候返回的状态码是200 OK</p>
<p>如果是相同的话,那么就说明资源没有被改动过,于是在这样的情况下,返回状态码304 Not Modified,通知客户端走缓存</p>
<ul>
<li><strong>根据资源本身的内容做一个摘要,通过这个摘要来确定资源是否被改动过了</strong></li>
</ul>
<p>具体来说,它的实现是这样的,就是当浏览器客户端发现本地资源过期了,然后它发现这个资源响应头中带有<code>etag</code>的字段,它就会将这个字段的值给赋值到<code>if-none-match</code>中,然后在请求头上带上这个字段</p>
<p>然后在服务器的一段,收到这个请求之后,就会比较这个<code>if-none-match</code>和<code>对应资源的etag</code>,如果资源的<code>etag</code>和对应的<code>if-none-match</code>中的值是不相等的话,那么就返回最新的资源,走<code>200 OK</code>,否则的话走<code>304 Not Modified</code>,如果</p>
<blockquote>
<p>为什么要使用eTAG?</p>
</blockquote>
<p>对应缓存更新频率高的,如果一秒内更新了多次,那么就会造成协商缓存的失效</p>
<p>有时候没有修改文件,只是打开了文件,也可能导致文件修改时间的变化</p>
<p>文件修改时间与操作系统有关,无法很好地做到操作系统异构化下的同质操作</p>
<h2 id="39-HTTP和HTTPS有什么区别">39. HTTP和HTTPS有什么区别?</h2>
<p>具体的区别主要就是安全和不安全的问题,首先从连接建立的过程来说:</p>
<ul>
<li>HTTP协议传输是不安全的,其中数据是明文传输的,而HTTPS通过在HTTP协议和TCP协议的中间引入了SSL/TLS协议,通过这样的方式来实现了数据的加密传输,即使HTTP数据包在网络中被截获了,对方也不知道其中的内容是什么</li>
<li>HTTP协议是基于TCP连接实现的,因此在TCP连接建立完毕后,就可以实现HTTP传输了,而HTTPS因为需要完成TLS/SSL的握手,因此连接建立的速度会更慢一些</li>
<li>HTTPS需要CA证书,来保证服务器的身份是可信的</li>
<li>HTTP的默认端口是80端口,HTTPS的默认端口是443端口</li>
</ul>
<h2 id="HTTPS解决了什么问题">HTTPS解决了什么问题?</h2>
<p>HTTP是明文传输协议,这意味着在公开信道上传输的时候,可能会导致数据包被截获,可能会有三个风险</p>
<p>第一个风险,就是数据明文传输,如果里面存储了敏感信息,那么容易被窃取</p>
<p>第二个风险,数据明文传输,如果被中间人截获并且添加了额外信息,那么信息容易被篡改</p>
<p>第三个风险,数据明文传输,如果没有加以验证对方的身份,对方不断伪造数据包,这样就可能导致用户一直访问的是一个冒牌服务器</p>
<p>而HTTPS通过:</p>
<p><strong>第一个手段,通过加密密钥,通过这个密钥来对数据进行加密,实现了除了传输的双方,其他人都无法获取相关的数据</strong></p>
<p><strong>第二个手段,通过摘要算法+数字签名,基于摘要和数据内容的对比,实现了数据无法被篡改</strong></p>
<p><strong>第三个手段,通过CA证书,来保证服务器是可信的</strong></p>
<h2 id="详细说说三个手段的实现过程">详细说说三个手段的实现过程</h2>
<p><strong>混合加密实现了信息的机密性,即使数据包被截获,没有通信密钥,也无法对数据的查询</strong></p>
<p><strong>摘要算法实现了完整性,它能够为数据生成独一无二的指纹,指纹用来对数据的完整性做一个校验,解决了篡改的风险</strong></p>
<p><strong>将服务器公钥放入到数字证书中,通过权威机构的认证来确定服务器是可信的</strong></p>
<ul>
<li>混合加密:所谓的混合加密,就是非对称加密传输通信密钥,对称加密传输通信报文</li>
</ul>
<p>在建立之前,会在客户端和服务端生成一对公钥和私钥,所谓的公钥和私钥是这样的,首先服务器上有个公钥,这个公钥是大家都知道的,客户端上有一个私钥,这个私钥是由它自己管理的,那么在这样的情况下</p>
<p>服务端对通信密钥用公钥加密后,只有存储在客户端本地的私钥是可以解密的,因此可以保证通信密钥的传输安全</p>
<p>在完成了通信密钥的传输之后,之后所有的数据传输都使用这个通信密钥进行传输了</p>
<ul>
<li>摘要算法+数字签名:为了保证传输的内容不被篡改,我们需要对内容计算出一个指纹,然后同内容一起传输给对方</li>
</ul>
<p>通过这个指纹,对方就可以将数据和摘要进行对比(指的是将数据通过公开的摘要算法计算出来的摘要和对方传过来的摘要进行对比),如果是一致的,那么就认为数据没有被篡改</p>
<p><strong>但是要注意了,你的这个摘要包是完全有可能被伪造的,这是因为中间人可以通过自己构造出一个包,然后通过构造这个包的摘要,这样的话对等端进行验证之后,它依然发现是合法的</strong></p>
<p>那么怎么来解决这个问题呢?可以通过数字签名的方式来实现</p>
<p>之前提到了有一个叫做公钥和私钥的东西,这两个东西对原始报文的加密顺序不同,达到的效果也是不一样的</p>
<ul>
<li>如果先用公钥加密,再用私钥解密,可以保证内容传输的安全,因为被公钥加密的内容,其他人是无法解密的,只有持有私钥的人,才能解密出实际的内容</li>
<li>如果先用私钥加密,再用公钥解密,可以保证数据是对等端传过来的,因为私钥只有对等端才持有</li>
</ul>
<p>一般来说,在使用这个方法的时候不会对数据内容进行直接签名,因为这样签名的效率实在太低,因此通常是对定长短小的摘要进行签名,这样的话可以提升效率</p>
<p>一般来说是这样做的,服务端内部保管了一个私钥,然后服务端对报文摘要进行私钥加密,然后客户端用这个公钥对摘要进行解密,在这样的情况下就可以实现签名认证了</p>
<ul>
<li><strong>数字证书技术(重要)</strong></li>
</ul>
<p>通过<code>哈希算法可以保证信息不会被篡改</code>、<code>数字签名可以保证信息是持有私钥的人发送的</code></p>
<p>但是这其中的关键是,必须要保证你获取到的公钥是正确的,否则的话就无从谈起</p>
<p>那么如果在公开信道上传输公钥的时候,这个公钥被替换了,怎么办呢?</p>
<p>将会出现这样的情况,出现一个中间人,这个中间人截获了所有公钥包,然后替换为自己的公钥,于是在后面,所有人获取到的公钥都是这个中间人的公钥,那么这时候,其他真正的对等端反而无法接收真实的数据,而是只能够接收中间人的数据,这样也会造成冒充的风险</p>
<p>因此,在这样的情况下,为了验证公钥的合法性,引入了第三方权威机构,在使用公钥之前,使用权威机构的手段来对公钥进行验证,验证合法后才能继续使用</p>
<blockquote>
<p>数字证书有什么用?</p>
</blockquote>
<p>数字证书是为了验证你的这个公钥,确实是对等端的公钥,而不是中间人的公钥</p>
<p>因此数字证书中会有公钥信息,同时还会含有服务器的信息,通过验证服务器的信息,就可以知道你这个公钥是合法的了,具体验证流程是这样的:</p>
<p>首先服务器向CA机构提交服务器信息,包括有<code>服务器的个人信息+公钥</code>打包成一个数据包,你可以理解成将这些信息封装成一个字符串,然后通过摘要算法,将这些信息弄成一个定长的<code>hash</code>,然后用CA的私钥进行加密,然后呢,将数据包的信息和经过加密后的hash打包成一个数字证书,就可以使用了</p>
<p>那么客户端会怎么处理这个数字证书呢?</p>
<p>会将服务器的个人信息+公钥执行摘要算法,得到一个<code>hash1</code>,然后将证书中的<code>CA数字签名</code>用<code>CA</code>公钥进行解密,得到<code>hash2</code>,然后比较<code>hash1 == hash2?</code>如果相等,那么证明这个证书就是可信的,可以使用公钥,否则的话就是不可信的</p>
<h2 id="HTTPS是如何建立的">HTTPS是如何建立的?</h2>
<p><code>SSL/TLS</code>握手的基本流程:</p>
<p>第一步,客户端向服务端请求公钥并且验证公钥的合法性</p>
<p>第二步,双方协商生产会话密钥</p>
<p>第三步,双方采用会话密钥进行加密通信</p>
<p>首先要清楚,TLS建立之前,要先执行TCP的三次握手,然后此后基于这条TCP连接执行TLS/SSL的四次握手</p>
<p>握手的流程:</p>
<p><code>第一次握手,ClientHello</code>,这个过程是客户端首先发起的,客户端请求与服务器建立一个HTTPS连接,于是告诉对方(1)自己支持的TLS/SSL协议的版本号(2)自己的支持密码套件有哪些(3)客户端这边自己产生的第一个随机数</p>
<p><code>第二次握手,ServerHello</code>,这个过程是服务端给客户端的一个回应,一般来说会回应说(1)确认版本号(2)确认密钥套件,便于后续双方协商自己的密钥是如何生成的(3)服务器的CA证书(4)服务端自己产生的第二个随机数</p>
<p><code>第三次,ClientReply</code>,首先,在收到你这个ServerHello的时候,这时候会验证你的证书的合法性,验证的流程是这样的:(1)拿到数字证书的服务器信息+公钥,做一个摘要算法,然后将数字证书中的CA签发的数字签名,进行CA公钥的解密,然后两个相同,验证通过(2)在客户端产生一个pre-master key,用公钥加密后传输出去(3)加密通信算法改变通知,表示之后都将使用对称会话密钥进行通信(4)客户端进入<code>SSL/TLS</code>的ESTABLISHED,将之前通信的内容做一个摘要提供给服务端进行检验</p>
<p><code>第四次,ServerReply</code>,服务端收到了三个随机数,经过协商的加密算法,计算出本次的通信密钥,然后向客户端发送最后的消息:</p>
<p>(1)加密通信算法改变通知,表示随后的消息都将采用<code>会话密钥</code>进行通信</p>
<p>(2)服务器握手结束通知,表示服务器的握手阶段已经结束了,同时会将之前所有的内容做一个摘要,给客户端一个验证的机会</p>
<p>(3)TLS的握手阶段全部结束,之后都将使用普通的HTTP协议通信,只不过使用通话密钥来对数据报文进行加密##</p>
<h2 id="HTTPS一定安全可靠的吗？">HTTPS一定安全可靠的吗？</h2>
<p>不一定,当用户信任了不可信的证书的时候,这时候就会导致HTTPS失守了,但是HTTPS本身是安全可靠的,出现这样的问题还是因为用户的操作不规范导致的</p>
<p>下面来讲讲中间人攻击是如何发生的</p>
<p>首先客户端向服务器正常发起一次HTTPS请求,首先也是要完成TLS的四次握手,但是这时候HTTPS请求就会被转发到一个假基站上,也就是说你的报文被人截获了</p>
<p>客户端发起一个<code>Client Hello</code>,携带了相关的密码套件信息,随机数,请求数字证书,TLS/SSL协议版本号,但是它不是直接发给<code>Server</code>的,而是经过了一个中间人服务器,这个中间人服务器截获了第一个随机数</p>
<p>中间人服务器截获后,伪装成客户端,向真正的服务器发送请求</p>
<p>然后接着,服务器发起一个<code>Server Hello</code>,携带了相关的密码套件确认,随机数,数字证书,TLS/SSL协议版本号,然后转发到<code>中间人服务器</code>,截获了第二个随机数</p>
<p>然后这时候中间人服务器将自己的证书转发到客户端上</p>
<p>接着,客户端收到<code>Server Hello</code>的时候,会进行CA证书,然后这时候就会发现不对劲了,就是你的这个CA证书是不合法的,然后就会弹窗:<code>服务器证书不可信</code>,然后客户端点击继续浏览,那么就会继续握手流程,它会用中间人的公钥对当前产生的密钥进行加密,然后发送给中间人服务器</p>
<p>中间人服务器收到<code>ClientReply</code>之后,就会计算和客户端的<code>通信密钥A</code>,同时会继续和真正的服务器进行握手操作,也就是会给服务器一个<code>ClentReply</code>,就会计算和客户端的<code>通信密钥B</code></p>
<p>接下来的流程,就是中间人服务器用通信密钥A解密客户端的数据,用通信密钥B解密服务段的数据,这样的话数据就被偷看了</p>
<blockquote>
<p>如何解决中间人攻击问题?</p>
</blockquote>
<p>不要信任不合法的证书</p>
<p>采取双方验证,上面说的情况是:只有客户端验证对方的身份,如果服务端是正规服务器,那么它也会验证客户端的身份,具体的实现是这样的:</p>
<p>双向验证就是:客户端和服务端都有一个数字证书,这也就意味着双方都有一对公钥和私钥</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081236850.png" alt="image-20230906231807983"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><a class="post-meta__tags" href="/tags/%E9%A2%98%E5%BA%93/">题库</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94900660_p0.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97025298_p0.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络 面试题 总结回顾（2）</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96369940_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统 面试题总结回顾</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97025298_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-18</div><div class="title">计算机网络 面试题 总结回顾（2）</div></div></a></div><div><a href="/2023/08/12/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/" title="JVM 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-12</div><div class="title">JVM 面试题总结回顾</div></div></a></div><div><a href="/2023/08/11/JUC%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/" title="JUC 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-11</div><div class="title">JUC 面试题总结回顾</div></div></a></div><div><a href="/2023/08/10/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE/" title="Java基础面试题回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97052568_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">Java基础面试题回顾</div></div></a></div><div><a href="/2023/08/13/MySQL%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="MySQL 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96167606_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-13</div><div class="title">MySQL 面试题总结回顾</div></div></a></div><div><a href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96887683_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="title">Redis 面试题总结回顾</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kaillliu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/51341210"><i class="fa-brands fa-bilibili"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/51341210" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://weibo.com/u/5412952403" target="_blank" title="weibo"><i class="fa-brands fa-weibo"></i></a><a class="social-icon" href="mailto:kaillliu@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9C%89TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">为什么需要有TCP&#x2F;IP网络模型?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP的应用层是干什么的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E7%9A%84%E4%BC%A0%E8%BE%93%E5%B1%82%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">TCP&#x2F;IP的传输层是干什么的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B1%82%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">4.</span> <span class="toc-text">TCP&#x2F;IP的网络层是干什么的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">5.</span> <span class="toc-text">TCP&#x2F;IP的网络接口层是干什么的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL-%E9%97%AE%E4%BD%A0%E8%BF%99%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">6.</span> <span class="toc-text">输入一个URL,问你这期间发生了什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8EB-S%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%9B%9E%E7%AD%94"><span class="toc-number">6.1.</span> <span class="toc-text">从B&#x2F;S应用架构来进行回答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%9B%9E%E7%AD%94"><span class="toc-number">6.2.</span> <span class="toc-text">从计算机网络协议栈的角度来进行回答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">7.</span> <span class="toc-text">TCP的基本认识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">7.1.</span> <span class="toc-text">TCP的头部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.2.</span> <span class="toc-text">为什么需要TCP协议?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.</span> <span class="toc-text">TCP是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9D%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.</span> <span class="toc-text">如何来描述一个TCP连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">TCP和UDP有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8BTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">简述一下TCP三次握手的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E7%9A%84%E6%8F%A1%E6%89%8B%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1"><span class="toc-number">12.</span> <span class="toc-text">为什么TCP的握手需要三次?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%BB%BA%E7%AB%8B%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%92%E5%BA%A6%E4%B8%8A%E6%9D%A5%E8%AF%B4"><span class="toc-number">12.1.</span> <span class="toc-text">从建立全双工连接的角度上来说</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%A1%AE%E5%AE%9A%E4%B8%80%E6%9D%A1TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%92%E5%BA%A6%E4%B8%8A%E6%9D%A5%E8%AF%B4"><span class="toc-number">12.2.</span> <span class="toc-text">从确定一条TCP连接的角度上来说</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">12.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9B%B8%E5%90%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E-%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">13.</span> <span class="toc-text">初始化的序列号相同该怎么办?会有什么问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81MSS%E5%91%A2"><span class="toc-number">14.</span> <span class="toc-text">IP层会分片,为什么还需要MSS呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">15.</span> <span class="toc-text">如果第一次握手报文丢失了,会发生什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">16.</span> <span class="toc-text">如果第二次握手报文丢失了,会发生什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">17.</span> <span class="toc-text">如果第三次握手报文丢失了,会发生什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSYN%E6%94%BB%E5%87%BB-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DSYN%E6%94%BB%E5%87%BB"><span class="toc-number">18.</span> <span class="toc-text">什么是SYN攻击?如何避免SYN攻击?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">简述TCP四次挥手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="toc-number">20.</span> <span class="toc-text">为什么挥手是四次?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">21.</span> <span class="toc-text">第一次挥手丢失了会发生什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">22.</span> <span class="toc-text">第二次挥手丢失了会发生什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">23.</span> <span class="toc-text">第三次挥手丢失了会发生什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88-%E9%87%8D%E8%A6%81"><span class="toc-number">24.</span> <span class="toc-text">第四次挥手丢失了会发生什么?(重要)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E6%98%AF2MSL"><span class="toc-number">25.</span> <span class="toc-text">为什么TIME_WAIT是2MSL?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90TIME-WAIT%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">26.</span> <span class="toc-text">深入剖析TIME_WAIT的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIME-WAIT%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3"><span class="toc-number">27.</span> <span class="toc-text">TIME_WAIT过多有什么危害?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIME-WAIT%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="toc-number">28.</span> <span class="toc-text">TIME_WAIT如何排查?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCLOSE-WAIT-%E5%A4%A7%E9%87%8F%E5%87%BA%E7%8E%B0%E4%BA%86CLOSE-WAIT%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">29.</span> <span class="toc-text">什么是CLOSE_WAIT?大量出现了CLOSE_WAIT怎么办?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E4%BA%86%E6%95%85%E9%9A%9C%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">30.</span> <span class="toc-text">客户端突然出现了故障怎么办?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">如果已经建立了连接，但是服务端的进程崩溃会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">32.</span> <span class="toc-text">什么是HTTP协议?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">33.</span> <span class="toc-text">HTTP常见的状态码有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%9A%84%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">34.</span> <span class="toc-text">HTTP的头部字段有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Get%E8%AF%B7%E6%B1%82%E5%92%8CPost%E8%AF%B7%E6%B1%82%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">35.</span> <span class="toc-text">Get请求和Post请求有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">36.</span> <span class="toc-text">HTTP缓存的实现方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">37.</span> <span class="toc-text">什么是强制缓存?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">38.</span> <span class="toc-text">什么是协商缓存?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-HTTP%E5%92%8CHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">39.</span> <span class="toc-text">39. HTTP和HTTPS有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">40.</span> <span class="toc-text">HTTPS解决了什么问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E8%AF%B4%E4%B8%89%E4%B8%AA%E6%89%8B%E6%AE%B5%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">41.</span> <span class="toc-text">详细说说三个手段的实现过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%9A%84"><span class="toc-number">42.</span> <span class="toc-text">HTTPS是如何建立的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">HTTPS一定安全可靠的吗？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97025298_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（2）"/></a><div class="content"><a class="title" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）">计算机网络 面试题 总结回顾（2）</a><time datetime="2023-08-18T07:00:00.000Z" title="发表于 2023-08-18 15:00:00">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94900660_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（1）"/></a><div class="content"><a class="title" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）">计算机网络 面试题 总结回顾（1）</a><time datetime="2023-08-17T07:00:00.000Z" title="发表于 2023-08-17 15:00:00">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96369940_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾">操作系统 面试题总结回顾</a><time datetime="2023-08-16T07:00:00.000Z" title="发表于 2023-08-16 15:00:00">2023-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebSocket 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾">WebSocket 面试题总结回顾</a><time datetime="2023-08-15T07:00:00.000Z" title="发表于 2023-08-15 15:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96887683_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾">Redis 面试题总结回顾</a><time datetime="2023-08-14T07:00:00.000Z" title="发表于 2023-08-14 15:00:00">2023-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Kaillliu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>