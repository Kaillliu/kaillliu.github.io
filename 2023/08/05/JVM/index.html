<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java JVM 知识总结 | K A I</title><meta name="author" content="Kaillliu"><meta name="copyright" content="Kaillliu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java JVM 知识总结"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://kaillliu.github.io/2023/08/05/JVM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#263238","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java JVM 知识总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 11:57:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="K A I"><span class="site-name">K A I</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java JVM 知识总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-05T07:00:00.000Z" title="发表于 2023-08-05 15:00:00">2023-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T03:57:32.554Z" title="更新于 2023-09-08 11:57:32">2023-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java JVM 知识总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JVM">JVM</h2>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156753.png" alt="image-20230826221145251"></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h3 id="程序计数器">程序计数器</h3>
<p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
<p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<h3 id="虚拟机栈">虚拟机栈</h3>
<p>生命周期和线程相同</p>
<p>栈由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表、操作数栈、动态链接、方法返回地址</strong>。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156754.png" alt="Java 虚拟机栈"></p>
<p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型、对象引用</p>
<p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果 以及 临时变量</p>
<p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景</p>
<p>​	将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p>
<p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常</p>
<p><strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p>
<p>程序运行中栈可能会出现两种错误：</p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h3 id="本地方法栈">本地方法栈</h3>
<p><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p>
<h3 id="堆">堆</h3>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。</p>
<p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong></p>
<h3 id="方法区">方法区</h3>
<p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。</p>
<p>方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<h3 id="运行时常量池">运行时常量池</h3>
<p>存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong></p>
<p>常量池表会在类加载后存放到方法区的运行时常量池中。</p>
<h3 id="字符串常量池">字符串常量池</h3>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<h3 id="直接内存">直接内存</h3>
<p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在<strong>本地内存</strong>上分配的。</p>
<p>类似的概念还有 <strong>堆外内存</strong></p>
<blockquote>
<p>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p>
</blockquote>
<h2 id="💠对象创建过程">💠对象创建过程</h2>
<p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p>
<h4 id="Step1-类加载检查">Step1:类加载检查</h4>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="Step2-分配内存">Step2:分配内存</h4>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞：
<ul>
<li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表：
<ul>
<li>适用场合：堆内存不规整的情况下。</li>
<li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h4 id="Step3-初始化零值">Step3:初始化零值</h4>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都<strong>初始化为零值</strong>（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="Step4-设置对象头">Step4:设置对象头</h4>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="Step5-执行-init-方法">Step5:执行 init 方法</h4>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p>
<h2 id="对象的内存布局">对象的内存布局</h2>
<p><strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<ul>
<li><strong>对象头</strong>：
<ul>
<li><strong>用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等）</li>
<li><strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
</li>
<li>实例数据：
<ul>
<li><strong>对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</li>
</ul>
</li>
<li>对齐填充：
<ul>
<li><strong>起占位作用</strong></li>
</ul>
</li>
</ul>
<h2 id="对象的访问定位">对象的访问定位</h2>
<p><strong>句柄</strong>、</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156755.png" alt="对象的访问定位-使用句柄"></p>
<p><strong>直接指针</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156756.png" alt="对象的访问定位-直接指针"></p>
<ul>
<li>
<p>使用句柄来访问的最大好处是</p>
<ul>
<li>reference 中存储的是<strong>稳定的句柄地址</strong>，在对象被移动时<strong>只会改变</strong>句柄中的实例数据指针，而 reference 本身不需要修改。</li>
</ul>
</li>
<li>
<p>使用<strong>直接指针访问</strong>方式最大的好处</p>
<ul>
<li>就是<strong>速度快</strong>，它节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ul>
<h1>JVM垃圾回收机制</h1>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>
<p>从垃圾回收的角度来说，由于现在收集器基本都采用<strong>分代垃圾收集</strong>算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据<strong>各个区域的特点</strong>选择<strong>合适的==垃圾收集算法==</strong>。</p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li><strong>新生代</strong>内存(Young Generation)</li>
<li><strong>老生代</strong>(Old Generation)</li>
<li><strong>永久代</strong>(Permanent Generation)  ---- 元空间</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156757.png" alt="堆内存结构"></p>
<p>Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>
<p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(==元空间==) 取代，元空间==使用的是直接内存==</strong> 。</p>
<p>另一张图</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156758.png" alt="img"></p>
<h2 id="内存分配和回收原则">内存分配和回收原则</h2>
<h3 id="对象优先在-Eden-区分配">对象优先在 Eden 区分配</h3>
<h3 id="大对象直接进入老年代">大对象直接进入老年代</h3>
<p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<h3 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h3>
<h3 id="主要进行-gc-的区域">主要进行 gc 的区域</h3>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li><strong>新生代</strong>收集（<strong>Minor</strong> GC / Young GC）：只对新生代进行垃圾收集；</li>
<li><strong>老年代</strong>收集（<strong>Major</strong> GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (<strong>Full</strong> GC)：收集整个 Java 堆和方法区。</p>
<h3 id="空间分配担保">空间分配担保</h3>
<h2 id="死亡对象判断方法（-2-种）">死亡对象判断方法（ 2 种）</h2>
<h3 id="引用计数法">引用计数法</h3>
<p>问题：**==循环引用==**无法解决</p>
<p>方法原理：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<h3 id="可达性分析算法">可达性分析算法</h3>
<p>以 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当<strong>一个对象到 GC Roots 没有任何引用链相连</strong>的话，则证明此对象是不可用的，需要被回收。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156759.png" alt="可达性分析算法"></p>
<p><code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p>
<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li><strong>虚拟机栈</strong>(栈帧中的本地变量表)中引用的对象</li>
<li><strong>本地方法</strong>栈(Native 方法)中引用的对象</li>
<li>方法区中<strong>类静态属性引用</strong>的对象</li>
<li>方法区中<strong>常量引用</strong>的对象</li>
<li>所有被<strong>同步锁</strong>持有的对象</li>
<li>JNI（Java Native Interface）引用的对象</li>
</ul>
<h4 id=""></h4>
<h3 id="引用类型">引用类型</h3>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156760.png" alt="image-20230828155604318"></p>
<p>弱引用和虚引用在每次 垃圾回收的时候都会回收</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
<blockquote>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
</blockquote>
<h3 id="怎么判断一个类是无用的类">怎么判断一个类是无用的类</h3>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="垃圾收集算法（-4-种">垃圾收集算法（ 4 种)</h2>
<h3 id="标记-清除算法">标记-清除算法</h3>
<p>分为“<strong>==标记==（Mark）</strong>”和“<strong>==清除==（Sweep）</strong>”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>它是<strong>最基础</strong>的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的**==内存碎片==**。</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156762.png" alt="image-20230828160629571"></p>
<h3 id="复制算法">复制算法</h3>
<p>将内存分为<strong>大小相同的==两块==</strong>，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使<strong>每次的内存回收都是对内存区间的一半进行回收</strong>。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156763.png" alt="image-20230828160751536"></p>
<p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li>
</ul>
<h3 id="标记-整理算法">标记-整理算法</h3>
<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让<strong>所有存活的对象向一端移动</strong>，然后直接清理掉端边界以外的内存。</p>
<p>复制 存活  ------&gt; 全部清理原来的内存</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156764.png" alt="image-20230828161028647"></p>
<p><strong>优点</strong><br>
该算法不会像标记-清除算法那样产生大量的碎片空间。<br>
<strong>缺点</strong><br>
如果存活的对象过多，整理阶段将会执行<strong>较多复制操作</strong>，导致算法效率降低，适合老年代。</p>
<h3 id="分代收集算法">分代收集算法</h3>
<p>根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样我们就可以根据各个年代的特点<strong>选择合适的垃圾收集算法</strong>。</p>
<blockquote>
<p>在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
</blockquote>
<h2 id="垃圾收集器（-8-种">垃圾收集器（ 8 种 )</h2>
<p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p>
<ul>
<li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li>
<li>JDK 9 ~ JDK20: G1</li>
</ul>
<h3 id="Serial（串行）收集器">Serial（串行）收集器</h3>
<p>是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156765.png" alt="Serial 收集器"></p>
<p>特点：</p>
<ul>
<li>简单高效，但是在GC过程中要完全暂停用户线程</li>
</ul>
<h3 id="ParNew-收集器">ParNew 收集器</h3>
<p>Serial 收集器的多线程版本，除了**使用==多线程==**进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156766.png" alt="ParNew 收集器 "></p>
<p>在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 <strong>CMS 收集器</strong>（真正意义上的并发收集器，后面会介绍到）<strong>配合工作</strong>。</p>
<blockquote>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><strong>并行（Parallel）</strong>：指<strong>多条垃圾收集线程</strong>并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
</blockquote>
<h3 id="Parallel-Scavenge-收集器">Parallel Scavenge 收集器</h3>
<p>Parallel Scavenge 收集器关注点是**==吞吐量==<strong>（<strong>高效率的利用 <code>CPU</code></strong>）。CMS 等垃圾收集器的关注点更多的是</strong>用户==线程==的==停顿时间==**（<strong>提高用户体验</strong>）</p>
<p><strong>提供了很多参数供用户找到最合适的停顿时间或最大吞吐量</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156767.png" alt="Parallel Old收集器运行示意图"></p>
<p><strong>JDK1.8 默认收集器</strong></p>
<h3 id="Serial-Old-收集器">Serial Old 收集器</h3>
<p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 <strong>CMS 收集器的后备方案</strong>。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156768.png" alt="Serial 收集器"></p>
<h3 id="Parallel-Old-收集器">Parallel Old 收集器</h3>
<p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156769.png" alt="Parallel Old收集器运行示意图"></p>
<h3 id="CMS-收集器">CMS 收集器</h3>
<p><strong>以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
<p><strong>是 HotSpot 虚拟机第一款真正意义上的==并发收集器==，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p><strong>“标记-清除”</strong> 实现</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156770.png" alt="CMS 收集器"></p>
<p>整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，<strong>速度很快</strong> ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里<strong>会跟踪记录这些发生引用更新的地方</strong>。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<blockquote>
<p>这里就能很明显的看出，为什么CMS要使用<strong>标记清除</strong>而不是<strong>标记压缩</strong>，如果使用标记压缩，需要<strong>多对象的内存位置进行改变</strong>，这样程序就很难继续执行。但是<strong>标记清除会产生大量内存碎片</strong>，不利于内存分配</p>
<p>CMS的提出是想改善GC的停顿时间，在GC过程中的确做到了减少GC时间，但是同样导致产生大量内存碎片，又需要消耗大量时间去整理碎片，从本质上并没有改善时间</p>
</blockquote>
<p>主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生</strong></li>
</ul>
<h3 id="G1-收集器">G1 收集器</h3>
<p><strong>针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<ul>
<li>
<p><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p>
</li>
<li>
<p><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</p>
</li>
<li>
<p><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是<strong>基于“标记-整理”算法</strong>实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</p>
</li>
<li>
<p><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
</li>
</ul>
<blockquote>
<p>上面提到的<strong>垃圾收集器</strong>，收集的范围都是<strong>整个新生代</strong>或者<strong>老年代</strong>，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个<strong>Java堆划分为多个大小相等的独立区域</strong>（<code>Region</code>），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们<strong>都是一部分（可以不连续）Region的集合</strong>。</p>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。</p>
<p>和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156771.png" alt="G1 收集器"></p>
<p><strong>在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h2 id="类的加载过程">类的加载过程</h2>
<p>7个阶段：<strong>加载（Loading）、验证（Verification）、准备（Preparaton)、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156772.png" alt="一个类的完整生命周期"></p>
<h3 id="加载">加载</h3>
<p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用</strong></p>
<p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<p>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ol>
<p>加载这一步主要是通过我们后面要讲到的 ==<strong>类加载器</strong>== 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 ==<strong>双亲委派模型</strong>== 决定</p>
<p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是**==交叉进行==**的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<h3 id="验证">验证</h3>
<p><strong>验证是连接阶段的第一步，这一阶段的目的是==确保 Class 文件的字节流==中包含的信息==符合==《Java 虚拟机规范》的全部==约束要求==，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p>
<p>验证阶段主要由四个检验阶段组成：</p>
<ol>
<li><strong>文件格式</strong>验证（**==Class 文件格式==**检查）</li>
<li><strong>元数据</strong>验证（**==字节码语义==**检查）</li>
<li><strong>字节码</strong>验证（**==程序语义==**检查）</li>
<li><strong>符号引用</strong>验证（**==类的正确性==**检查）</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156773.png" alt="验证阶段示意图"></p>
<h3 id="准备">准备</h3>
<p><strong>准备阶段是正式==为类变量==分配内存并==设置类变量初始值==的阶段</strong>，这些内存都将在方法区中分配</p>
<ol>
<li>
<p>这时候进行内存分配的<strong>仅</strong>包括类变量（<strong>==静态变量==</strong>），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p>
</li>
<li>
<p>类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配</p>
<blockquote>
<p>JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
</blockquote>
</li>
<li>
<p>这里所设置的初始值&quot;通常情况&quot;下是==<strong>数据类型默认的零值</strong>==（如 0、0L、null、false 等）。</p>
<ul>
<li>但是，如果有加上 <code>final</code> 关键字，那么准备阶段value就会被赋值</li>
<li>比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）</li>
</ul>
</li>
</ol>
<h3 id="解析">解析</h3>
<p><strong>解析阶段是==虚拟机==将==常量池==内的==符号引用==替换为==直接引用==的过程</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156774.png" alt="符号引用和直接引用"></p>
<h3 id="初始化">初始化</h3>
<p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p>
<blockquote>
<p>说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p>
<p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性</p>
<ol>
<li>
<p>当遇到 <code>new</code>、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条字节码指令时，比如 <strong><code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法</strong>时。</p>
<ul>
<li>
<p>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</p>
</li>
<li>
<p>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</p>
</li>
<li>
<p>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</p>
</li>
<li>
<p>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</p>
</li>
</ul>
</li>
<li>
<p>使用 <code>java.lang.reflect</code> 包的方法对类进行**==反射调用==**时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</p>
</li>
<li>
<p>初始化一个类，如果其**==父类还未初始化==**，则先触发该父类的初始化。</p>
</li>
<li>
<p>当虚拟机启动时，用户需要定义**==一个要执行的主类==** (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</p>
</li>
<li>
<p><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是<strong>轻量级的反射调用机制</strong>，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</p>
</li>
<li>
<p><strong>「补充，来自<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745open in new window</a>」</strong> 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</p>
</li>
</ol>
</blockquote>
<h3 id="类卸载">类卸载</h3>
<p><strong>卸载类即该类的 Class 对象被 ==GC==。</strong></p>
<p>卸载类需要满足 3 个要求:</p>
<ol>
<li>该类的<strong>所有的实例对象</strong>都已被 GC，也就是说<strong>堆不存在该类的实例对象</strong>。</li>
<li>该类<strong>没有在其他任何地方被引用</strong></li>
<li>该类的<strong>类加载器</strong>的<strong>实例</strong>已被 GC</li>
</ol>
<p>所以，在 JVM 生命周期内，由 <strong>jvm 自带的类加载器</strong>加载的类是不会被卸载的。但是由我们<strong>自定义的类加载器</strong>加载的类是<strong>可能被卸载</strong>的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。<strong>而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的</strong>。</p>
<h2 id="类加载器详解">类加载器详解</h2>
<p><strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）</strong></p>
<h3 id="-2"></h3>
<h3 id="规则">规则</h3>
<p>JVM 启动的时候，并不会一次性加载所有的类，而是根据<strong>需要去动态加载</strong>。也就是说，大部分类在具体<strong>用到的时候才会去加载</strong></p>
<p>对于已经加载的类会放在 <code>ClassLoader</code> 中。</p>
<p>在类加载的时候，系统会首先**==判断==当前类是否被加载过**。<strong>已经被加载</strong>的<strong>类会直接返回</strong>，<strong>否则才会尝试加载</strong>。也就是说，对于一个类加载器来说，<strong>相同二进制名称的类只会被加载一次</strong>。</p>
<h3 id="总结">总结</h3>
<p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p>
<ol>
<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>
<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>
<li><strong><code>AppClassLoader</code>(==应用程序类==加载器)</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156775.png" alt="类加载器层次关系图"></p>
<blockquote>
<p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>
<p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p>
</blockquote>
<h3 id="自定义类加载器">自定义类加载器</h3>
<p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。</p>
<p>如果我们要<strong>自定义自己的类加载器</strong>，很明显需要**==继承==** <code>ClassLoader</code>抽象类。</p>
<ul>
<li><code>loadClass</code> ： 加载指定二进制名称的类，实现了<strong>双亲委派机制</strong></li>
<li><code>findClass</code> ：根据类的二进制名称来查找类，默认<strong>实现是空方法</strong>。</li>
</ul>
<h2 id="双亲委派机制">双亲委派机制</h2>
<ul>
<li>
<p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</p>
</li>
<li>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
</li>
<li>
<p><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156776.png" alt="类加载器层次关系图"></p>
<blockquote>
<p>在类加载的时候，系统会首先判断当前类<strong>是否被加载过</strong>。<strong>已经被加载的类会直接返回</strong>，<strong>否则才会尝试加载</strong>（每个父类加载器都会走一遍这个流程）。</p>
<p>类加载器在进行类加载的时候，它<strong>首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成</strong>（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</p>
<p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</p>
</blockquote>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。</p>
<blockquote>
<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。<strong>这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类</strong>，会直接返回，不会去加载你写的 <code>Object</code> 类</p>
</blockquote>
<h2 id="JVM参数总结">JVM参数总结</h2>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">最重要的JVM参数总结 | JavaGuide(Java面试 + 学习指南)</a></p>
<h3 id="堆内存相关">堆内存相关</h3>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081156777.png" alt="内存区域常见配置参数"></p>
<h2 id="JDK-监控和故障处理工具总结">JDK 监控和故障处理工具总结</h2>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html">JDK监控和故障处理工具总结 | JavaGuide(Java面试 + 学习指南)</a></p>
<h2 id="JVM-线上问题排查和性能调优">JVM 线上问题排查和性能调优</h2>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-in-action.html">JVM线上问题排查和性能调优案例 | JavaGuide(Java面试 + 学习指南)</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/05/IOC%E5%92%8CAOP/" title="Java Spring IOC AOP 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java Spring IOC AOP 知识总结</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/04/Java%E5%B9%B6%E5%8F%91/" title="Java 并发 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 并发 知识总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/05/IOC%E5%92%8CAOP/" title="Java Spring IOC AOP 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">Java Spring IOC AOP 知识总结</div></div></a></div><div><a href="/2023/08/03/JavaIO/" title="Java IO 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97052568_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-03</div><div class="title">Java IO 知识总结</div></div></a></div><div><a href="/2023/08/04/Java%E5%B9%B6%E5%8F%91/" title="Java 并发 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-04</div><div class="title">Java 并发 知识总结</div></div></a></div><div><a href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/" title="Java基础知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96957552_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="title">Java基础知识总结</div></div></a></div><div><a href="/2023/08/02/Java%E9%9B%86%E5%90%88/" title="Java集合知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-02</div><div class="title">Java集合知识总结</div></div></a></div><div><a href="/2023/08/06/MySQL/" title="MySQL 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">MySQL 知识总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kaillliu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/51341210"><i class="fa-brands fa-bilibili"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/51341210" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://weibo.com/u/5412952403" target="_blank" title="weibo"><i class="fa-brands fa-weibo"></i></a><a class="social-icon" href="mailto:kaillliu@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">1.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.6.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.7.</span> <span class="toc-text">字符串常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.8.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A0%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">💠对象创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="toc-number">2.0.1.</span> <span class="toc-text">Step1:类加载检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">2.0.2.</span> <span class="toc-text">Step2:分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="toc-number">2.0.3.</span> <span class="toc-text">Step3:初始化零值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">2.0.4.</span> <span class="toc-text">Step4:设置对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step5-%E6%89%A7%E8%A1%8C-init-%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.5.</span> <span class="toc-text">Step5:执行 init 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">3.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.</span> <span class="toc-text">对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">JVM垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">内存分配和回收原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.1.</span> <span class="toc-text">对象优先在 Eden 区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">1.2.</span> <span class="toc-text">大对象直接进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">1.3.</span> <span class="toc-text">长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%BF%9B%E8%A1%8C-gc-%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">主要进行 gc 的区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">1.5.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%EF%BC%88-2-%E7%A7%8D%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">死亡对象判断方法（ 2 种）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">怎么判断一个类是无用的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88-4-%E7%A7%8D"><span class="toc-number">3.</span> <span class="toc-text">垃圾收集算法（ 4 种)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88-8-%E7%A7%8D"><span class="toc-number">4.</span> <span class="toc-text">垃圾收集器（ 8 种 )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%EF%BC%88%E4%B8%B2%E8%A1%8C%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">Serial（串行）收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">ParNew 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">Serial Old 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">Parallel Old 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">CMS 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.7.</span> <span class="toc-text">G1 收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">5.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">5.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">5.6.</span> <span class="toc-text">类卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">类加载器详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-2"><span class="toc-number">6.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">6.2.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.4.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">JVM参数总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">8.1.</span> <span class="toc-text">堆内存相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">JDK 监控和故障处理工具总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">10.</span> <span class="toc-text">JVM 线上问题排查和性能调优</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97025298_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（2）"/></a><div class="content"><a class="title" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）">计算机网络 面试题 总结回顾（2）</a><time datetime="2023-08-18T07:00:00.000Z" title="发表于 2023-08-18 15:00:00">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94900660_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（1）"/></a><div class="content"><a class="title" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）">计算机网络 面试题 总结回顾（1）</a><time datetime="2023-08-17T07:00:00.000Z" title="发表于 2023-08-17 15:00:00">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96369940_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾">操作系统 面试题总结回顾</a><time datetime="2023-08-16T07:00:00.000Z" title="发表于 2023-08-16 15:00:00">2023-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebSocket 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾">WebSocket 面试题总结回顾</a><time datetime="2023-08-15T07:00:00.000Z" title="发表于 2023-08-15 15:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96887683_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾">Redis 面试题总结回顾</a><time datetime="2023-08-14T07:00:00.000Z" title="发表于 2023-08-14 15:00:00">2023-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Kaillliu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>