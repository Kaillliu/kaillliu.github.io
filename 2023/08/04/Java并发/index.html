<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 并发 知识总结 | K A I</title><meta name="author" content="Kaillliu"><meta name="copyright" content="Kaillliu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 并发 知识总结"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://kaillliu.github.io/2023/08/04/Java%E5%B9%B6%E5%8F%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#263238","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发 知识总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 11:55:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="K A I"><span class="site-name">K A I</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 并发 知识总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-04T07:00:00.000Z" title="发表于 2023-08-04 15:00:00">2023-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T03:55:46.743Z" title="更新于 2023-09-08 11:55:46">2023-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 并发 知识总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Java并发</h1>
<h2 id="线程和进程">线程和进程</h2>
<h3 id="区别-2">区别</h3>
<ul>
<li>线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</li>
<li>同类的多个线程共享<strong>进程</strong>的**==堆==<strong>和</strong>==方法区==<strong>资源，但每个线程有自己的</strong>程序计数器**、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，</li>
</ul>
<h3 id="关系">关系</h3>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155130.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<ul>
<li>堆和方法区是所有线程共享的资源：
<ul>
<li><strong>堆：</strong>
<ul>
<li>是进程中最大的一块内存，主要用于存放<strong>新创建的对象</strong> (几乎所有对象都在这里分配内存)</li>
</ul>
</li>
<li><strong>方法区：</strong>
<ul>
<li>主要用于存放已被加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器</strong>编译后的<strong>代码</strong>等数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="并发与并行">并发与并行</h2>
<ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<p>关键区别是 是否 <strong>==同时==</strong> 执行</p>
<h2 id="同步与异步">同步与异步</h2>
<ul>
<li><strong>同步</strong>：调用之后，没有得到结果之前，<strong>==一直等待==</strong>。</li>
<li><strong>异步</strong>：调用之后，不用等待返回结果，<strong>==直接返回==</strong>。</li>
</ul>
<h2 id="线程的生命周期和状态-2">线程的生命周期和状态</h2>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155131.png" alt="Java 线程状态变迁图"></p>
<h2 id="死锁">死锁</h2>
<ol>
<li>
<p><strong>互斥条件</strong>：</p>
<ul>
<li>该资源<strong>任意</strong>一个时刻<strong>只由一个线程</strong>占用。</li>
</ul>
</li>
<li>
<p><strong>请求</strong>与<strong>保持</strong>条件：</p>
<ul>
<li>一个线程因请求资源而阻塞时，对<strong>已获得的资源==保持不放==</strong>。</li>
</ul>
</li>
<li>
<p><strong>不剥夺</strong>条件：</p>
<ul>
<li>线程已获得的资源在未使用完之前==<strong>不能被</strong>==其他线程==<strong>强行剥夺</strong>==，只有自己==<strong>使用</strong>完毕==后**才==释放==**资源。</li>
</ul>
</li>
<li>
<p><strong>循环等待</strong>条件：</p>
<ul>
<li>若干线程之间形成一种**==头尾相接==<strong>的</strong>==循环等待==**资源关系。</li>
</ul>
</li>
</ol>
<h3 id="预防死锁">预防死锁</h3>
<ol>
<li>
<p><strong>破坏请求与保持条件</strong>：</p>
<ul>
<li><strong>一次性申请</strong>所有的资源。</li>
</ul>
</li>
<li>
<p><strong>破坏不剥夺条件</strong>：</p>
<ul>
<li>占用部分资源的线程进一步申请其他资源时，如果==<strong>申请不到</strong>==，可以**==主动==释放<strong>它==占有的</strong>资源**==。</li>
</ul>
</li>
<li>
<p><strong>破坏循环等待条件</strong>：</p>
<ul>
<li>靠**==按序申请==资源**来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件</li>
</ul>
</li>
</ol>
<h2 id="sleep-方法和wait-方法">sleep()方法和wait()方法</h2>
<p><strong>共同点</strong>：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于<strong>暂停执行</strong>。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要<strong>别的线程</strong>调用<strong>同一个对象上</strong>的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的<strong>静态本地</strong>方法，<code>wait()</code> 则是 <code>Object</code> 类的<strong>本地方法</strong>。为什么这样设计呢？下一个问题就会聊到。</li>
</ul>
<p><code>wait()</code> 需要 获取 <strong>对象锁</strong> ，让获得<strong>对象锁</strong>的<strong>线程实现等待</strong>，会<strong>自动释放当前线程占有的对象锁</strong>。</p>
<ul>
<li>操作的是对象的锁，不是操作线程</li>
</ul>
<p><code>sleep()</code>是让<strong>当前线程</strong>暂停执行，<strong>不</strong>涉及<strong>对象类</strong>，<strong>无需对象锁</strong></p>
<h2 id="能直接调用Thread类的-run-方法么">能直接调用Thread类的 run 方法么</h2>
<p>可以，但是直接调用无法多线程。<strong>直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<blockquote>
<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了<strong>就绪状态</strong>，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
</blockquote>
<h2 id="JMM（Java内存模型）">JMM（Java内存模型）</h2>
<p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155132.png" alt="JMM(Java 内存模型)"></p>
<p>线程 1 要与线程 2 通信的话：</p>
<ol>
<li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li>
<li>线程 2 到主存中读取对应的共享变量的值。</li>
</ol>
<p>JMM为共享变量提供了可见性的保障。</p>
<h2 id="volatile-关键字">volatile 关键字</h2>
<ul>
<li>保证数据的可见性，但是不能保证数据的原子性</li>
<li><strong>防止 JVM 的指令重排序</strong></li>
</ul>
<p>一个使用 <code>volatile</code> 和 <code>synchronized</code> 关键字实现的对象单例（线程安全）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为**==三步*==*执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 <strong>JVM</strong> 具有指令重排的特性，执行顺序有可能变成==<strong>1-&gt;3-&gt;2</strong>==。指令重排在<strong>单线程环境下不会出现问题</strong>，但是在多线程环境下会导致一个<strong>线程获得还没有初始化的实例</strong>。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还<strong>未被初始化</strong></p>
<h2 id="乐观锁和悲观锁">乐观锁和悲观锁</h2>
<h3 id="悲观锁">悲观锁</h3>
<h4 id="概念">概念</h4>
<ul>
<li><strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</li>
<li>**<code>synchronized </code>**和 <strong><code>ReentrantLock</code><strong>等独占锁就是</strong>悲观锁</strong>思想的实现</li>
<li>高并发的场景下，激烈的锁竞争会造成线程阻塞还可能会存在死锁问题，影响代码的正常运行。</li>
</ul>
<h3 id="乐观锁">乐观锁</h3>
<h4 id="概念-2">概念</h4>
<ul>
<li>共享资源每次被访问的时候不会出现问题，线程可以不停地执行，<strong>==无需加锁==也无需等待</strong>，只是在提交修改的时候去==<strong>验证对应的资源</strong>==（也就是数据）是否被其它线程修改了（具体方法可以使用**==版本号机制==或 ==CAS 算法==**）。</li>
<li>如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</li>
</ul>
<h4 id="比较">比较</h4>
<ul>
<li>悲观锁通常多用于**==写比较多==**的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li>
<li>乐观锁通常多用于**==写比较少==<strong>的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是</strong>单个共享变量**（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h3 id="版本号机制">版本号机制</h3>
<h3 id="CAS算法">CAS算法</h3>
<p>比较与交换算法 (Compare And Swap)</p>
<p>一个**==预期值==<strong>和要</strong>==更新的变量值==**进行比较，两值相等才会进行更新。</p>
<p>CAS 涉及到三个操作数：</p>
<ul>
<li><strong>V</strong>：要更新的变量值(Var)</li>
<li><strong>E</strong>：预期值(Expected)</li>
<li><strong>N</strong>：拟写入的新值(New)</li>
</ul>
<p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</p>
<ol>
<li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li>
<li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>
</ol>
<h4 id="存在的问题">存在的问题</h4>
<ol>
<li>
<p><strong>ABA</strong> 问题</p>
<ul>
<li>读取的时候是 A ，赋值的时候也准备是 A ，不能说它没被其他线程修改过</li>
<li>可以通过在变量前面追加 <strong>版本号和时间戳</strong></li>
</ul>
</li>
<li>
<p>循环**==时间开销大==**</p>
<ul>
<li>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。</li>
<li>如果长时间不成功，会给 CPU 带来非常大的执行开销。</li>
</ul>
</li>
<li>
<p>只能保证**==一个共享变量==<strong>的</strong>==原子==操作**</p>
<ul>
<li>
<p>涉及<strong>跨多个共享变量</strong>时 CAS 无效</p>
</li>
<li>
<p>但是可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作</p>
</li>
</ul>
</li>
</ol>
<h2 id="synchronized-关键字">synchronized 关键字</h2>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能</li>
</ul>
<h4 id="底层">底层</h4>
<ol>
<li>
<p>同步 <strong>代码块</strong> 的情况</p>
<ul>
<li>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</li>
</ul>
<blockquote>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a target="_blank" rel="noopener" href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitoropen in new window</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
</li>
<li>
<p>同步 <strong>方法</strong> 的情况</p>
<ul>
<li>
<p><code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一<strong>个同步方法</strong>。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
</li>
<li>
<p>如果是<strong>实例方法</strong>，<strong>JVM</strong> 会尝试获取<strong>实例对象的锁</strong>。如果是<strong>静态方法</strong>，<strong>JVM</strong> 会尝试获取当前 <strong>class</strong> 的锁。</p>
</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
</li>
<li>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
</li>
<li>
<p><strong>不过两者的本质都是对==对象监视器== monitor 的获取</strong></p>
</li>
</ul>
</li>
</ol>
<h2 id="synchronized-和-volatile-有什么区别">synchronized 和 volatile 有什么区别</h2>
<ul>
<li>
<p><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。</p>
</li>
<li>
<p><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</p>
</li>
<li>
<p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>
</li>
<li>
<p><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p>
</li>
</ul>
<h2 id="ReentrantLock">ReentrantLock</h2>
<p><code>ReentrantLock</code> 的底层就是由 AQS 来实现的。</p>
<h3 id="公平锁和非公平锁">公平锁和非公平锁</h3>
<ul>
<li>
<p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
</li>
<li>
<p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
</li>
</ul>
<h2 id="synchronized-和-ReentrantLock-有什么区别">synchronized 和 ReentrantLock 有什么区别</h2>
<ol>
<li>两者都是可重入锁</li>
</ol>
<p>​	<strong>可重入锁</strong> 也叫递归锁，指的是线程**==可以再次获取==**自己的内部锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p>
</li>
<li>
<p>增加了一些高级功能</p>
<ul>
<li>等待可中断</li>
<li>可实现公平锁</li>
<li>可实现选择性通知</li>
</ul>
</li>
</ol>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
<h3 id="可中断锁和不可中断锁有什么区别？">可中断锁和不可中断锁有什么区别？</h3>
<ul>
<li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li>
<li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li>
</ul>
<h3 id="ReentrantReadWriteLock-是什么？">ReentrantReadWriteLock 是什么？</h3>
<p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个<strong>可重入的读写锁</strong>，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p>
<ul>
<li>一般锁进行并发控制的规则：<strong>读读互斥、读写互斥、写写互斥。</strong></li>
<li>读写锁进行并发控制的规则：<strong>读读==不互斥==、读写互斥、写写互斥</strong>（只有读读不互斥）。</li>
</ul>
<h3 id="ReentrantReadWriteLock-适合什么场景？">ReentrantReadWriteLock 适合什么场景？</h3>
<p>由于 <code>ReentrantReadWriteLock</code> 既可以保证多<strong>个线程同时读的效率</strong>，同时又可以<strong>保证有写入操作时</strong>的<strong>线程安全</strong>。因此，在**==读多写少==**的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p>
<h3 id="共享锁和独占锁有什么区别？">共享锁和独占锁有什么区别？</h3>
<ul>
<li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。</li>
<li><strong>独占锁</strong>：一把锁只能被一个线程获得。</li>
</ul>
<h3 id="线程持有读锁还能获取写锁吗？">线程持有读锁还能获取写锁吗？</h3>
<ul>
<li>在线程**==持有读锁==<strong>的情况下，该线程</strong>不能取得写锁**(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>
<li>在线程<strong>持有写锁</strong>的情况下，该线程可以<strong>继续获取读锁</strong>（获取读锁时如果<strong>发现写锁被占用</strong>，只有<strong>写锁没有被==当前线程==占用</strong>的情况才会获取失败）。</li>
</ul>
<p>读写锁的源码分析，推荐阅读 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw">聊聊 Java 的几把 JVM 级锁 - 阿里巴巴中间件 open in new window</a> 这篇文章，写的很不错。</p>
<h3 id="读锁为什么不能升级为写锁？">读锁为什么不能升级为写锁？</h3>
<p><strong>写锁可以降级为读锁</strong>，但是<strong>读锁却不能升级为写锁</strong>。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</p>
<p>另外，还<strong>可能会有死锁问题</strong>发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</p>
<h2 id="ThreadLocal">ThreadLocal</h2>
<ul>
<li>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的</li>
<li><strong><code>ThreadLocal</code>类主要解决的就是让==每个线程绑定自己的值==，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的==私有数据==。</strong></li>
</ul>
<h3 id="原理">原理</h3>
<ul>
<li>
<p><strong>最终的变量是放在了==当前线程==的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong></p>
</li>
<li>
<p><code>ThrealLocal</code> 类中可以通过**<code>Thread.currentThread()</code><strong>获取到当前线程对象后，直接通过</strong><code>getMap(Thread t)</code><strong>可以访问到该线程的</strong><code>ThreadLocalMap</code>**对象。</p>
</li>
<li>
<p><strong>==每个==<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 ==key== ，==Object== 对象为 value 的键值对。</strong></p>
<blockquote>
<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话， <code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code> 存放数据的，<strong><code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象</strong>，<strong>value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值</strong></p>
</blockquote>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155133.png" alt="ThreadLocal 数据结构"></p>
</li>
</ul>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155134.png" alt="ThreadLocal内部类"></p>
<h3 id="TheadLocal-的-内存泄漏问题">TheadLocal 的 内存泄漏问题</h3>
<p><code>ThreadLocalMap</code> 中使用的 <strong><code>key</code></strong> 为 <code>ThreadLocal</code> 的==<strong>弱引用</strong>==，而 <strong><code>value</code></strong> 是==<strong>强引用</strong>==。</p>
<p>弱引用：</p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。</p>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</p>
<ul>
<li>在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</li>
</ul>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h2 id="💠线程池">💠线程池</h2>
<ul>
<li>
<p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li>
<p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li>
<p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ul>
<h3 id="线程池创建方法">线程池创建方法</h3>
<ol>
<li><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建。</strong></li>
<li><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong>
<ul>
<li>（不推荐）无界的 <code>LinkedBlockingQueue</code>，同步队列 <code>SynchronousQueue</code>，无界的延迟阻塞队列<code>DelayedWorkQueue</code>任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
</li>
</ol>
<h4 id="线程池的多种类型（四种）">线程池的多种类型（四种）</h4>
<ol>
<li><strong><code>FixedThreadPool</code></strong>
<ul>
<li>固定数量</li>
</ul>
</li>
<li><strong><code>SingleThreadExecutor</code></strong>
<ul>
<li>单一</li>
</ul>
</li>
<li><strong><code>CachedThreadPool</code></strong>
<ul>
<li>新创建</li>
</ul>
</li>
<li><strong><code>ScheduledThreadPool</code></strong>
<ul>
<li>定时任务</li>
</ul>
</li>
</ol>
<h3 id="核心参数">核心参数</h3>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ul>
<h3 id="线程池的饱和策略-（-四种-）">线程池的饱和策略 （==四种==）</h3>
<p>当前同时运行的线程数量达到==<strong>最大线程数量</strong>==并且==<strong>队列也已经被放满</strong>==了任务时</p>
<ul>
<li>
<p><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong></p>
<ul>
<li>抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
</ul>
</li>
<li>
<p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong></p>
<ul>
<li>将 run 的任务返回给 调用者</li>
<li><strong>调用执行自己的线程运行任务</strong>，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。</li>
<li>因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
</ul>
</li>
<li>
<p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong></p>
<ul>
<li>不处理新任务，直接丢弃掉。</li>
</ul>
</li>
<li>
<p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong></p>
<ul>
<li>此策略将丢弃**==最早的未处理==**的任务请求。</li>
</ul>
</li>
</ul>
<h3 id="线程池常用阻塞队列-（三种）">线程池常用阻塞队列 （三种）</h3>
<p>workQueue</p>
<ol>
<li><code>LinkedBlockingQueue</code>（<strong>无界</strong>队列 ----- 队列无限）
<ul>
<li>容量
<ul>
<li><code>Integer.MAX_VALUE</code></li>
</ul>
</li>
<li>应用类型
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExector</code></li>
</ul>
</li>
<li>问题
<ul>
<li>由于**==队列==永远不会被放满**，因此<code>FixedThreadPool</code>最多<strong>只能创建核心线程数的线程</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><code>SynchronousQueue</code>（同步队列 ------ 线程无限）
<ul>
<li>==<strong>没有容量</strong>==
<ul>
<li>目的是保证对于提交的任务，如果<strong>有空闲线程，则==使用空闲线程==来处理</strong>；否则新建一个线程来处理任务</li>
</ul>
</li>
<li>应用类型
<ul>
<li><code>CachedThreadPool</code></li>
</ul>
</li>
<li>问题
<ul>
<li><code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为**==线程数==是可以==无限扩展==的**，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</li>
</ul>
</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）
<ul>
<li>容量
<ul>
<li><code>Integer.MAX_VALUE</code></li>
</ul>
</li>
<li>应用类型
<ul>
<li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></li>
</ul>
</li>
<li>问题
<ul>
<li>内部元素<strong>并不是==按照放入的时间排序==</strong>，而是会**按照==延迟的时间长短==**对任务进行排序</li>
<li>内部采用的是 <strong><code>堆</code></strong> 的数据结构，可以保证每次出队的任务都是<strong>当前队列中==执行时间最靠前的==</strong>。</li>
<li>由于**==队列==永远不会被放满**，因此最多<strong>只能创建核心线程数的线程</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="线程池处理任务流程-（-3-个判断）">线程池处理任务流程 （ 3 个判断）</h3>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155136.png" alt="图解线程池实现原理"></p>
<h3 id="线程池命名-两种">线程池命名 ( 两种 )</h3>
<ol>
<li><strong>利用 guava包 的 <code>ThreadFactoryBuilder</code></strong></li>
<li><strong>自己实现 <code>ThreadFactory</code>。</strong></li>
</ol>
<h3 id="如何设定线程池的大小">如何设定线程池的大小</h3>
<blockquote>
<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次==上下文切换==</strong>。</p>
</blockquote>
<p>一个简单的公式:</p>
<ol>
<li><strong>CPU 密集型任务(N+1)</strong></li>
<li><strong>I/O 密集型任务(2N)</strong></li>
</ol>
<p>动态修改线程池参数:</p>
<ul>
<li>美团</li>
<li>开源设置</li>
</ul>
<h2 id="AQS同步器-抽象队列同步器">AQS同步器     抽象队列同步器</h2>
<ul>
<li>
<p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p>
</li>
<li>
<p>AQS 为构建锁和同步器提供了一些通用功能的实现。</p>
</li>
<li>
<p>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的</p>
</li>
</ul>
<h4 id="原理-2">原理</h4>
<ol>
<li>
<p>核心思想</p>
<ul>
<li>如果被请求的共享资源<strong>空闲</strong>，
<ul>
<li>将当前请求资源的线程设置为<strong>有效的工作线程</strong>，</li>
<li>将共享资源设置为<strong>锁定状态</strong>。</li>
</ul>
</li>
<li>如果被请求的共享资源被<strong>占用</strong>，
<ul>
<li>那么就需要一套<strong>线程阻塞等待</strong>以及<strong>被唤醒时锁</strong>分配的机制，</li>
<li>用==<strong>CLH 队列锁</strong>==实现的，即将<strong>暂时获取不到锁</strong>的线程<strong>加入到队列</strong>中。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CLH 队列锁</p>
<ul>
<li>
<p>一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，<strong>仅存在结点之间的关联关系</strong>）</p>
</li>
<li>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155137.png" alt="img"></p>
</li>
<li>
<p><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/202309081155138.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>FIFO 线程等待/等待队列</strong> 来完成获取资源线程的排队工作</p>
</li>
</ol>
<h4 id="Semaphore">Semaphore</h4>
<ol>
<li><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，</li>
<li>而<code>Semaphore</code>(信号量)可以用来控制**==同时==访问特定资源<strong>的</strong>线程数量**。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>
<p><code>Semaphore</code> 有两种模式：。</p>
<ul>
<li><strong>公平模式：</strong> 调用 <code>acquire()</code> 方法的顺序就是获取许可证的顺序，遵循 FIFO；</li>
<li><strong>非公平模式：</strong> 抢占式的。</li>
</ul>
<p><strong>有两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>
<h5 id="信号量的原理">信号量的原理</h5>
<ul>
<li>
<p><code>Semaphore</code> 是共享锁的一种实现，</p>
</li>
<li>
<p>默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，你可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></div><div class="post_share"><div class="social-share" data-image="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/05/JVM/" title="Java JVM 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java JVM 知识总结</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/03/JavaIO/" title="Java IO 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97052568_p0.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java IO 知识总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/05/IOC%E5%92%8CAOP/" title="Java Spring IOC AOP 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97079772_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">Java Spring IOC AOP 知识总结</div></div></a></div><div><a href="/2023/08/05/JVM/" title="Java JVM 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">Java JVM 知识总结</div></div></a></div><div><a href="/2023/08/03/JavaIO/" title="Java IO 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97052568_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-03</div><div class="title">Java IO 知识总结</div></div></a></div><div><a href="/2023/08/01/Java%E5%9F%BA%E7%A1%80/" title="Java基础知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96957552_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="title">Java基础知识总结</div></div></a></div><div><a href="/2023/08/02/Java%E9%9B%86%E5%90%88/" title="Java集合知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97102324_p0_master1200.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-02</div><div class="title">Java集合知识总结</div></div></a></div><div><a href="/2023/08/06/MySQL/" title="MySQL 知识总结"><img class="cover" src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">MySQL 知识总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/EXKx_vaVAAA9c9Z.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kaillliu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/51341210"><i class="fa-brands fa-bilibili"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/51341210" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://weibo.com/u/5412952403" target="_blank" title="weibo"><i class="fa-brands fa-weibo"></i></a><a class="social-icon" href="mailto:kaillliu@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-2"><span class="toc-number">1.1.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">1.3.</span> <span class="toc-text">同步与异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81-2"><span class="toc-number">1.4.</span> <span class="toc-text">线程的生命周期和状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">预防死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E6%96%B9%E6%B3%95%E5%92%8Cwait-%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">sleep()方法和wait()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8Thread%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E4%B9%88"><span class="toc-number">1.7.</span> <span class="toc-text">能直接调用Thread类的 run 方法么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">JMM（Java内存模型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.</span> <span class="toc-text">volatile 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.10.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.10.1.</span> <span class="toc-text">悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.10.2.</span> <span class="toc-text">乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.3.</span> <span class="toc-text">版本号机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.4.</span> <span class="toc-text">CAS算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">存在的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.11.</span> <span class="toc-text">synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82"><span class="toc-number">1.11.0.1.</span> <span class="toc-text">底层</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%92%8C-volatile-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.</span> <span class="toc-text">synchronized 和 volatile 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.13.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.13.1.</span> <span class="toc-text">公平锁和非公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">synchronized 和 ReentrantLock 有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.1.</span> <span class="toc-text">可中断锁和不可中断锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.14.2.</span> <span class="toc-text">ReentrantReadWriteLock 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock-%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.14.3.</span> <span class="toc-text">ReentrantReadWriteLock 适合什么场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E7%8B%AC%E5%8D%A0%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.4.</span> <span class="toc-text">共享锁和独占锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8C%81%E6%9C%89%E8%AF%BB%E9%94%81%E8%BF%98%E8%83%BD%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-number">1.14.5.</span> <span class="toc-text">线程持有读锁还能获取写锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%8D%87%E7%BA%A7%E4%B8%BA%E5%86%99%E9%94%81%EF%BC%9F"><span class="toc-number">1.14.6.</span> <span class="toc-text">读锁为什么不能升级为写锁？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.15.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.15.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TheadLocal-%E7%9A%84-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.15.2.</span> <span class="toc-text">TheadLocal 的 内存泄漏问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.16.</span> <span class="toc-text">💠线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.16.1.</span> <span class="toc-text">线程池创建方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%9B%9B%E7%A7%8D%EF%BC%89"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">线程池的多种类型（四种）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">1.16.2.</span> <span class="toc-text">核心参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5-%EF%BC%88-%E5%9B%9B%E7%A7%8D-%EF%BC%89"><span class="toc-number">1.16.3.</span> <span class="toc-text">线程池的饱和策略 （&#x3D;&#x3D;四种&#x3D;&#x3D;）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E7%94%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89"><span class="toc-number">1.16.4.</span> <span class="toc-text">线程池常用阻塞队列 （三种）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B-%EF%BC%88-3-%E4%B8%AA%E5%88%A4%E6%96%AD%EF%BC%89"><span class="toc-number">1.16.5.</span> <span class="toc-text">线程池处理任务流程 （ 3 个判断）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%BD%E5%90%8D-%E4%B8%A4%E7%A7%8D"><span class="toc-number">1.16.6.</span> <span class="toc-text">线程池命名 ( 两种 )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.16.7.</span> <span class="toc-text">如何设定线程池的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E5%90%8C%E6%AD%A5%E5%99%A8-%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">1.17.</span> <span class="toc-text">AQS同步器     抽象队列同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">1.17.0.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.17.0.2.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.17.0.2.1.</span> <span class="toc-text">信号量的原理</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/97025298_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（2）"/></a><div class="content"><a class="title" href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/" title="计算机网络 面试题 总结回顾（2）">计算机网络 面试题 总结回顾（2）</a><time datetime="2023-08-18T07:00:00.000Z" title="发表于 2023-08-18 15:00:00">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94900660_p0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络 面试题 总结回顾（1）"/></a><div class="content"><a class="title" href="/2023/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%BB%9A%E5%8A%A8%E5%A4%8D%E4%B9%A0/" title="计算机网络 面试题 总结回顾（1）">计算机网络 面试题 总结回顾（1）</a><time datetime="2023-08-17T07:00:00.000Z" title="发表于 2023-08-17 15:00:00">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96369940_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%98%E5%BA%93/" title="操作系统 面试题总结回顾">操作系统 面试题总结回顾</a><time datetime="2023-08-16T07:00:00.000Z" title="发表于 2023-08-16 15:00:00">2023-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/94758289_p0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebSocket 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/15/websocket%E7%90%86%E8%AE%BA/" title="WebSocket 面试题总结回顾">WebSocket 面试题总结回顾</a><time datetime="2023-08-15T07:00:00.000Z" title="发表于 2023-08-15 15:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾"><img src="https://fastly.jsdelivr.net/gh/Kaillliu/blog-img/96887683_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis 面试题总结回顾"/></a><div class="content"><a class="title" href="/2023/08/14/Redis%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" title="Redis 面试题总结回顾">Redis 面试题总结回顾</a><time datetime="2023-08-14T07:00:00.000Z" title="发表于 2023-08-14 15:00:00">2023-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Kaillliu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>