<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式笔记之Adapter（适配器）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BAdapter%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BAdapter%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Adapter（适配器）模式</h1><h2 id="意图">意图</h2><p>将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>注：适配器模式在详细设计阶段不需要考虑它，它是为了对现有系统或产品接口兼容时，也就是既成事实的情况下的<strong>补救措施</strong>。</p><h2 id="适用性">适用性</h2><ol><li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li></ol><ul><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li><li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ul><h2 id="结构">结构</h2><p><strong>类适配器模式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204021711585.png" alt=""></p><p><strong>对象适配器模式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204021712585.png" alt=""></p><h2 id="登场角色">登场角色</h2><ul><li><p>**Target (目标角色 对象，要用的接口) **</p><p>定义Client所需的方法。</p></li><li><p>**Client (使用场景 请求者) **</p><p>与符合Target接口的对象协同，使用Target角色定义的方法进行具体处理。</p></li><li><p>**Adaptee (被适配) **</p><p>定义一个已经存在的接角色，这个角色需要适配。</p></li><li><p><strong>Adapter (适配器，把Adaptee接口转换为Target可用的接口)</strong></p><p>对Adaptee的接口与Target接口进行适配</p></li></ul><h2 id="优点">优点</h2><ol><li><p>可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。</p></li><li><p>增加了类的透明性</p></li><li><p>提高了类的复用度</p></li><li><p>灵活性非常好</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记之Iterator（迭代器）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Iterator（迭代器）模式</h1><h2 id="意图-2">意图</h2><p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，即为遍历和实现可以分离开来。</p><h2 id="适用性-2">适用性</h2><ol><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。</li></ol><h2 id="结构-2">结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204021558441.png" alt="迭代器模式结构"></p><h2 id="登场角色-2">登场角色</h2><ul><li><p><strong>Iterator 迭代器</strong></p><p>负责定义访问和遍历元素的接口（API）。</p></li><li><p><strong>Concretelterator 具体的迭代器</strong></p><p>负责实现Iterator角色所定义的接口（API）。</p></li><li><p><strong>Aggregate 集合</strong></p><p>集合定义创建Iterator角色的接口，在示例程序中，由Aggregate接口扮演此角色，里面定义了Iterator方法。</p></li><li><p><strong>ConcreteAggregate 具体的集合</strong></p><p>负责实现Aggregate角色所定义的接口。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记之Factory Method（工厂方法）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BFactory%EF%BC%88%E5%B7%A5%E5%8E%82%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BFactory%EF%BC%88%E5%B7%A5%E5%8E%82%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Factory Method（工厂方法）模式</h1><h2 id="意图">意图</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><h2 id="适用性">适用性</h2><p>•  当一个类不知道它所必须创建的对象的类的时候。<br>•  当一个类希望由它的子类来指定它所创建的对象的时候。<br>•  当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><h2 id="结构">结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204061430619.png" alt=""></p><h2 id="登场角色">登场角色</h2><ul><li><p><strong>Product 产品</strong></p><p>定义工厂方法所创建的对象的接口。</p></li><li><p><strong>Creator 创建者</strong></p><p>声明工厂方法,该方法返回一个 Product类型的对象。 Creator也可以定义一个工厂方 法的缺省实现,它返回一个缺省的 ConcreteProduct对象。</p></li><li><p><strong>ConcreteProduct 具体的产品</strong></p><p>决定了具体的产品，实现Product接口。</p></li><li><p><strong>ConcreteCreator 具体的创建者</strong></p><p>负责生成具体的产品，重定义工厂方法以返回一个 ConcreteProduct实例。</p></li></ul><h2 id="优缺点">优缺点</h2><p><strong>优点：</strong><br>首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</p><p>工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，可以使用产品子类替换产品父类。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记之Template Method（模板方法）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BTemplate%EF%BC%88%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BTemplate%EF%BC%88%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Template Method（模板方法）模式</h1><h2 id="意图-2">意图</h2><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h2 id="适用性-2">适用性</h2><ul><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的 行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有 代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。</li></ul><h2 id="结构-2">结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204061409711.png" alt=""></p><h2 id="登场角色-2">登场角色</h2><ul><li><p>**AbstractClass(抽象类) **</p><p>负责实现模板方法，声明在模板方法中所使用到的抽象方法。这些抽象方法由子类ConcreteClass角色负责实现。</p></li><li><p>**ConcreteClass(具体类) **</p><p>负责具体实现AbstractClass角色中定义的抽象方法。</p></li></ul><h2 id="优点">优点</h2><ol><li><p>封装不变部分，扩展可变部分<br>把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。在悍马模型例子中，是不是就非常容易扩展？例如增加一个H3型号的悍马模型，很容易呀，增加一个子类，实现父类的基本方法就可以了。</p></li><li><p>提取公共部分代码，便于维护<br>我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！</p></li><li><p>行为由父类控制，子类实现<br>基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。</p></li></ol><h2 id="思考">思考</h2><p><strong>习题3-2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void diaplay()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractDisplay类中使用<code>final</code> 表示子类无法重写display方法。</p><p>不要重写模板方法</p><p><strong>习题3-4</strong></p><p>Java为什么不用接口代替抽象类？</p><p>因为此模式下AbstractClass角色必须实现部分处理流程。接口无法实现</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-084,085-单调栈-数组中的最大矩阵,最大矩阵</title>
      <link href="/2022/03/29/leetcode-42-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
      <url>/2022/03/29/leetcode-42-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p><p>​   ：<a href="https://leetcode-cn.com/problems/maximal-rectangle/">https://leetcode-cn.com/problems/maximal-rectangle/</a></p><p><strong>84. 解法一：暴力求解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为o(N^2)，提交结果超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="comment">//定义长度，返回值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>, n = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//确定宽</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//确定左边</span></span><br><span class="line">            <span class="keyword">for</span>(; left&gt;=<span class="number">0</span>; left--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[left] &lt; heights[i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确定右边</span></span><br><span class="line">            <span class="keyword">for</span>(; right&lt;n; right++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[right] &lt; heights[i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算面积</span></span><br><span class="line">            area = Math.max(area,(heights[i] * (right - left -<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二：单调栈，用Deque数据结构</strong>（来自评论区大佬，太妙了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">       <span class="comment">// 这里为了代码简便，在柱体数组的头和尾加了两个高度为 0 的柱体。</span></span><br><span class="line">    <span class="comment">// arraycopy(源，起始，目标，目标起始，源长度)</span></span><br><span class="line">       <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">       System.arraycopy(heights, <span class="number">0</span>, tmp, <span class="number">1</span>, heights.length); </span><br><span class="line">       </span><br><span class="line">       Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">           <span class="comment">// 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；</span></span><br><span class="line">           <span class="comment">// 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。</span></span><br><span class="line">           <span class="comment">// i是右边界</span></span><br><span class="line">           <span class="comment">// 因此以栈顶柱体为高的矩形的左右宽度边界就确定了，可以计算面积～</span></span><br><span class="line">           <span class="comment">//stack.peek()获得栈顶元素，stack.pop()获取栈顶元素并删除</span></span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; tmp[i] &lt; tmp[stack.peek()]) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> tmp[stack.pop()];</span><br><span class="line">               area = Math.max(area, (i - stack.peek() - <span class="number">1</span>) * h);   </span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> area;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>85. 解法</strong></p><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p>思路：转化为84中的求矩阵中的最大矩形，遍历，对每一行求高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//85-最大矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] heights = <span class="keyword">new</span> <span class="title class_">int</span>[row];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; col; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历列，求高</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; row; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    heights[j] += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result,max(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//84</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, temp, <span class="number">1</span>, heights.length);</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temp[i] &lt; temp[stack.peek()] )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> temp[stack.pop()];</span><br><span class="line">                area = Math.max(area,(i - stack.peek() - <span class="number">1</span>) * h);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配合Github Pages搭建个人博客</title>
      <link href="/2022/03/27/HI/"/>
      <url>/2022/03/27/HI/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>目前市面上有成熟的知识分享平台，例如CSDN、掘金等等，也可以被搜索引擎检索到。除此之外也可以自己搭建一个个人博客网站，主要使用的就是  <code>Hexo + GitPage</code>  的方式，本站主要使用 <code>GitHub Page + Hexo</code>搭建静态博客网站。</p><h2 id="GitHub-Pages-是什么？">GitHub Pages 是什么？</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h2 id="Hexo是什么？">Hexo是什么？</h2><ul><li>官网：<a href="https://hexo.io/zh-cn/">hexo.io</a></li></ul><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><h2 id="为什么使用Hexo-GitHub-Pages">为什么使用Hexo + GitHub Pages</h2><p><strong>优点：</strong> 主要是 Hexo 完全免费，静态，轻量快速，并且可以托管在GitHub，当然也可以托管在国内的Gitee里面，但是会麻烦一点。</p><p><strong>缺点：</strong> 在国内GitHub访问速度一般，前期搭建和发布文章有点点麻烦。</p><h1>搭建步骤</h1><h2 id="安装准备">安装准备</h2><p>在搭建博客之前，需要确认电脑上已经安装好了 Git 和 Node.js ，然后再安装Hexo。</p><ul><li><p>​<a href="https://nodejs.org/en/">Node.js 官网</a></p></li><li><p>​    <a href="https://git-scm.com/">Git 官网</a></p></li><li><p>​    <a href="https://blog.csdn.net/mukes/article/details/115693833">Git 安装教程</a></p></li><li><p>​<a href="https://blog.csdn.net/chanyeolchichi/article/details/121348541">Node.js 安装教程</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Node.js之后使用国内的淘宝镜像源加速，安装之后可以用 cnpm 代替 npm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="链接GitHub">链接GitHub</h2><p>需要一个<a href="https://github.com/">GitHub</a>账号，使用邮箱注册。</p><p><strong>配置GitHub账号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 配置用户名和邮箱</span><br><span class="line">git config --global user.name &quot;github的用户名&quot;</span><br><span class="line">git config --global user.email &quot;github的注册邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>创建SSH密钥</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成 ssh 密钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;github的注册邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>添加密匙：</strong></p><p>进入 <code>C:\Users\用户名\.ssh</code> 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329110048.png" alt="添加成功界面"></p><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329110555.png" alt="连接成功"></p><p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><h2 id="新建Github-Pages-仓库">新建Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329110815.png" alt="创建Pages"></p><p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="本地安装Hexo">本地安装Hexo</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。<strong>打开该文件夹</strong>，右键 -&gt; Git Bash Here。</p><h3 id="安装-Hexo">安装 Hexo</h3><p>使用 npm 一键安装 Hexo 博客程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Hexo-初始化和本地预览">Hexo 初始化和本地预览</h3><p><strong>初始化并安装所需组件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init      <span class="comment"># 初始化</span></span><br><span class="line">cnpm install    <span class="comment"># 安装组件</span></span><br></pre></td></tr></table></figure><p>完成后依次输入下面命令，<strong>启动本地服务器进行预览</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo clean </span></span><br><span class="line"></span><br><span class="line">hexo g   <span class="comment"># 生成页面</span></span><br><span class="line">hexo s   <span class="comment"># 启动预览</span></span><br></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329112426.png" alt="访问成功"></p><p>**Tips：**如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p><p>Hexo 博客文件夹目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329112551.png" alt=""></p><h2 id="部署Hexo到GitHub-Pages">部署Hexo到GitHub Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仓库地址最好是ssh方式，也可以是http格式，可以在github仓库中查找到</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h2 id="绑定域名（待更新）">绑定域名（待更新）</h2><h2 id="开始使用">开始使用</h2><h3 id="发布文章">发布文章</h3><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 My New <a href="http://Post.md">Post.md</a> 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这两条命令。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo d   # 部署发布</span><br></pre></td></tr></table></figure><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="section">- Games</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure><h3 id="网站设置">网站设置</h3><p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考<a href="https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/configuration">官方文档</a>按需要编辑。</p><p>注意：冒号后要加一个空格！</p><h3 id="更换主题">更换主题</h3><p>在 <a href="https://link.zhihu.com/?target=https%3A//hexo.io/themes/">Themes | Hexo</a> 选择一个喜欢的主题，比如 <a href="https://link.zhihu.com/?target=http%3A//theme-next.iissnan.com/getting-started.html">NexT</a>，进入网站目录打开 Git Bash Here 下载主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后修改 _config.yml 中的 theme 为新主题名称 next，发布。（有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。）</p><h3 id="常用命令">常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;name&quot;</span>       <span class="comment"># 新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;name&quot;</span>  <span class="comment"># 新建页面</span></span><br><span class="line">hexo g                <span class="comment"># 生成页面</span></span><br><span class="line">hexo d                <span class="comment"># 部署</span></span><br><span class="line">hexo g -d             <span class="comment"># 生成页面并部署</span></span><br><span class="line">hexo s                <span class="comment"># 本地预览</span></span><br><span class="line">hexo clean            <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line">hexo <span class="built_in">help</span>             <span class="comment"># 帮助</span></span><br></pre></td></tr></table></figure><h2 id="PicGo-Github-CDN-搭建博客图床">PicGo + Github + CDN 搭建博客图床</h2><h3 id="创建仓库">创建仓库</h3><p>新键一个图片仓库</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291231661.png" alt=""></p><p>填好相关信息</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291232207.png" alt=""></p><h3 id="获取token">获取token</h3><blockquote><p><strong>token</strong><br>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。 当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。我们通过token来确定GitHub仓库的位置。</p></blockquote><p>点击setting</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291233120.png" alt=""></p><p><code>Settings -&gt; Developer settings -&gt; Personal access tokens，最后点击 generate new token</code>；</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291233623.png" alt=""></p><p>点击生成token</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291234726.png" alt=""></p><p>保存好生成的token(仅显示一次)，因此最好存放到备忘录里面。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291234280.png" alt=""></p><h3 id="下载PicGo">下载PicGo</h3><p>进入picgo官网: <a href="https://picgo.github.io/PicGo-Doc/zh/">https://picgo.github.io/PicGo-Doc/zh/</a></p><p>点击免费下载，跳转到GitHub界面，选择对应系统的版本进行安装</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291237737.png" alt=""></p><h3 id="设置PicGo">设置PicGo</h3><p>选择GitHub图床，根据提示填写，<strong>保存图片的库可以更换，只需要把PicGo里面的仓库名对应改掉就行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291238463.png" alt=""></p><p>在picgo设置里面可以设置上传的快捷键，此外，最好打开时间戳重命名功能，防止图片名字重复</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291238772.png" alt=""></p><h3 id="CDN加速">CDN加速</h3><blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以<code>就近取得</code>所需的内容，<strong>提高用户访问网站的响应速度。</strong></p></blockquote><p>在这里，我们选择了快速免费公有的CDN-<strong>jsdelivr</strong></p><p>配置方法：</p><p>只需要在我们 PicGo 图床配置中添加如下自定义域名即可</p><p><code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291239301.png" alt=""></p><p>到这里，一个图床算是基本搭建好了。通过picgo上传图片，会在GitHub创建的仓库中保存。</p><h3 id="Markdown编辑器Typora的设置（可选）">Markdown编辑器Typora的设置（可选）</h3><p><strong>Markdown</strong></p><p>官网：<code>https://markdown.com.cn/</code></p><blockquote><p>Markdown是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。 markdown的优点：</p></blockquote><ul><li>专注于文字内容；</li><li>纯文本，易读易写，可以方便地纳入版本控制；</li><li>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。</li></ul><p><strong>Typora</strong></p><blockquote><p>ypora是一个专注于markdown语言的优秀编辑器。 官网：<code>https://typora.io/</code></p></blockquote><p>打开Typora的偏好设置，设置好红色方框里面的内容，便可以在Typora里面编写文章的同时上传图片到图床了。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291241165.png" alt=""></p><h2 id="常见问题">常见问题</h2><h3 id="设置网站图标">设置网站图标</h3><p>进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：<code>favicon: 图标地址</code>。（不同主题可能略有差别）</p><h3 id="修改并部署后没有效果">修改并部署后没有效果</h3><p>使用 <code>hexo clean</code> 清理后重新部署。</p><h3 id="开启-HTTPS-后访问网站显示连接不安全？">开启 HTTPS 后访问网站显示连接不安全？</h3><p>证书还未部署生效，等待一会儿，清除浏览器缓存再试。</p><h3 id="Hexo部署出现错误err-Error-Spawn-failed解决方式">Hexo部署出现错误err: Error: Spawn failed解决方式</h3><pre><code>https://blog.csdn.net/weixin_41256398/article/details/117994899</code></pre><h3 id="Github连接出现ssh-connect-to-host-github-com-port-22-Connection-timed-out-错误">Github连接出现ssh: connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out 错误</h3><p>​<a href="https://blog.csdn.net/vosang/article/details/50499300">Github连接出现ssh: connect to host github.com port 22: Connection timed out 错误</a></p><p>​<a href="https://blog.csdn.net/msStev/article/details/109379342">git commit、merge 如何退出git bash vim编辑器</a></p><h1>参考资料</h1><ul><li><p><a href="https://easyhexo.com/">Easy Hexo</a> ：包括Hexo快速开始，推荐主题，插件使用等等</p></li><li><p><a href="https://butterfly.js.org/">Butterfly</a>：本站使用的主题</p></li><li><p>搭建教程：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></li><li><a href="https://blog.csdn.net/github_39655029/article/details/116485386">https://blog.csdn.net/github_39655029/article/details/116485386</a></li></ul></li><li><p>使用ssh连接Git仓库（Github)</p><ul><li><a href="https://www.jianshu.com/p/20089411571d">https://www.jianshu.com/p/20089411571d</a></li></ul></li><li><p>PicGo+GitHub图床搭建部分的参考</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/350598351">https://zhuanlan.zhihu.com/p/350598351</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/138012354">https://zhuanlan.zhihu.com/p/138012354</a></p></li></ul></li><li><p>Node.js 使用淘宝 NPM 镜像的相关说明</p><ul><li><a href="https://www.twle.cn/l/yufei/nodejs/nodejs-basic-cnpm.html">https://www.twle.cn/l/yufei/nodejs/nodejs-basic-cnpm.html</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
