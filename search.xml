<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx学习（五）--- 与Tomcat结合</title>
      <link href="/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%BA%94/"/>
      <url>/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1>Nginx实现服务器端集群搭建</h1><h2 id="Nginx与Tomcat部署">Nginx与Tomcat部署</h2><p>前面课程已经将Nginx的大部分内容进行了讲解，我们都知道了Nginx在高并发场景和处理静态资源是非常高性能的，但是在实际项目中除了静态资源还有就是后台业务代码模块，一般后台业务都会被部署在Tomcat，weblogic或者是websphere等web服务器上。那么如何使用Nginx接收用户的请求并把请求转发到后台web服务器？</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700404.png" alt="1604498725652"></p><p>步骤分析:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.准备Tomcat环境，并在Tomcat上部署一个web项目</span><br><span class="line">2.准备Nginx环境，使用Nginx接收请求，并把请求分发到Tomat上</span><br></pre></td></tr></table></figure><h3 id="环境准备-Tomcat">环境准备(Tomcat)</h3><p>浏览器访问:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.146:8080/demo/index.html</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700405.png" alt="1604421296014"></p><p>获取动态资源的链接地址:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.146:8080/demo/getAddress</span><br></pre></td></tr></table></figure><p>本次课程将采用Tomcat作为后台web服务器</p><p>（1）在Centos上准备一个Tomcat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Tomcat官网地址:https://tomcat.apache.org/</span><br><span class="line">2.下载tomcat,本次课程使用的是apache-tomcat-8.5.59.tar.gz</span><br><span class="line">3.将tomcat进行解压缩</span><br><span class="line">mkdir web_tomcat</span><br><span class="line">tar -zxf apache-tomcat-8.5.59.tar.gz -C /web_tomcat</span><br></pre></td></tr></table></figure><p>（2）准备一个web项目，将其打包为war</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将资料中的demo.war上传到tomcat8目录下的webapps包下</span><br><span class="line">2.将tomcat进行启动，进入tomcat8的bin目录下</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure><p>（3）启动tomcat进行访问测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态资源: http://192.168.200.146:8080/demo/index.html</span><br><span class="line">动态资源: http://192.168.200.146:8080/demo/getAddress</span><br></pre></td></tr></table></figure><h3 id="环境准备-Nginx">环境准备(Nginx)</h3><p>（1）使用Nginx的反向代理，将请求转给Tomcat进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream webservice &#123;</span><br><span class="line">server 192.168.200.146:8080;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location /demo &#123;</span><br><span class="line">    proxy_pass http://webservice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）启动访问测试</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700406.png" alt="1604421312486"></p><p>学习到这，可能大家会有一个困惑，明明直接通过tomcat就能访问，为什么还需要多加一个nginx，这样不是反而是系统的复杂度变高了么?<br>那接下来我们从两个方便给大家分析下这个问题，</p><p>第一个使用Nginx实现动静分离</p><p>第二个使用Nginx搭建Tomcat的集群</p><h2 id="Nginx实现动静分离">Nginx实现动静分离</h2><p>什么是动静分离?</p><p>动:后台应用程序的业务处理</p><p>静:网站的静态资源(html,javaScript,css,images等文件)</p><p>分离:将两者进行分开部署访问，提供用户进行访问。举例说明就是以后所有和静态资源相关的内容都交给Nginx来部署访问，非静态内容则交个类似于Tomcat的服务器来部署访问。</p><p>为什么要动静分离?</p><p>​前面我们介绍过Nginx在处理静态资源的时候，效率是非常高的，而且Nginx的并发访问量也是名列前茅，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。</p><p>​动静分离以后，降低了动态资源和静态资源的耦合度。如动态资源宕机了也不影响静态资源的展示。</p><p>如何实现动静分离?</p><p>实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。本次课程只要使用Nginx+Tomcat来实现动静分离。</p><h3 id="需求分析">需求分析</h3><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700407.png" alt="1604422564855"></p><h3 id="动静分离实现步骤">动静分离实现步骤</h3><p>1.将demo.war项目中的静态资源都删除掉，重新打包生成一个war包，在资料中有提供。</p><p>2.将war包部署到tomcat中，把之前部署的内容删除掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入到tomcat的webapps目录下，将之前的内容删除掉</span><br><span class="line">将新的war包复制到webapps下</span><br><span class="line">将tomcat启动</span><br></pre></td></tr></table></figure><p>3.在Nginx所在服务器创建如下目录，并将对应的静态资源放入指定的位置</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700408.png" alt="1604493947499"></p><p>其中index.html页面的内容如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           $.<span class="title function_">get</span>(<span class="string">&#x27;http://192.168.200.133/demo/getAddress&#x27;</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">               $(<span class="string">&quot;#msg&quot;</span>).<span class="title function_">html</span>(data);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/logo.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Nginx如何将请求转发到后端服务器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/mv.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.配置Nginx的静态资源与动态资源的访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">upstream webservice&#123;</span><br><span class="line">   server 192.168.200.146:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #动态资源</span><br><span class="line">        location /demo &#123;</span><br><span class="line">                proxy_pass http://webservice;</span><br><span class="line">        &#125;</span><br><span class="line">        #静态资源</span><br><span class="line">        location ~/.*\.(png|jpg|gif|js)&#123;</span><br><span class="line">                root html/web;</span><br><span class="line">                gzip on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/web;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.启动测试，访问http://192.168.200.133/index.html</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700409.png" alt="1604494128097"></p><p>假如某个时间点，由于某个原因导致Tomcat后的服务器宕机了，我们再次访问Nginx,会得到如下效果，用户还是能看到页面，只是缺失了访问次数的统计，这就是前后端耦合度降低的效果，并且整个请求只和后的服务器交互了一次，js和images都直接从Nginx返回，提供了效率，降低了后的服务器的压力。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700410.png" alt="1604494156197"></p><h2 id="Nginx实现Tomcat集群搭建">Nginx实现Tomcat集群搭建</h2><p>在使用Nginx和Tomcat部署项目的时候，我们使用的是一台Nginx服务器和一台Tomcat服务器，效果图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700411.png" alt="1604494256017"></p><p>那么问题来了，如果Tomcat的真的宕机了，整个系统就会不完整，所以如何解决上述问题，一台服务器容易宕机，那就多搭建几台Tomcat服务器，这样的话就提升了后的服务器的可用性。这也就是我们常说的集群，搭建Tomcat的集群需要用到了Nginx的反向代理和赋值均衡的知识，具体如何来实现?我们先来分析下原理</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700412.png" alt="1604494269848"></p><p>环境准备：</p><p>(1)准备3台tomcat,使用端口进行区分[实际环境应该是三台服务器]，<a href="http://xn--server-2g0js76l.ml">修改server.ml</a>，将端口修改分别修改为8080,8180,8280</p><p>(2)启动tomcat并访问测试，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.146:8080/demo/getAddress</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700413.png" alt="1604494822961"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.146:8180/demo/getAddress</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700414.png" alt="1604494843886"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.146:8280/demo/getAddress</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700415.png" alt="1604494860954"></p><p>(3)在Nginx对应的配置文件中添加如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream webservice&#123;</span><br><span class="line">        server 192.168.200.146:8080;</span><br><span class="line">        server 192.168.200.146:8180;</span><br><span class="line">        server 192.168.200.146:8280;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好了，完成了上述环境的部署，我们已经解决了Tomcat的高可用性，一台服务器宕机，还有其他两条对外提供服务，同时也可以实现后台服务器的不间断更新。但是新问题出现了，上述环境中，如果是Nginx宕机了呢，那么整套系统都将服务对外提供服务了，这个如何解决？</p><h2 id="Nginx高可用解决方案">Nginx高可用解决方案</h2><p>针对于上面提到的问题，我们来分析下要想解决上述问题，需要面临哪些问题?</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700416.png" alt="1604495169905"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要两台以上的Nginx服务器对外提供服务，这样的话就可以解决其中一台宕机了，另外一台还能对外提供服务，但是如果是两台Nginx服务器的话，会有两个IP地址，用户该访问哪台服务器，用户怎么知道哪台是好的，哪台是宕机了的?</span><br></pre></td></tr></table></figure><h3 id="Keepalived">Keepalived</h3><p>使用Keepalived来解决，Keepalived 软件由 C 编写的，最初是专为 LVS 负载均衡软件设计的，Keepalived 软件主要是通过 VRRP 协议实现高可用功能。</p><h3 id="VRRP介绍">VRRP介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700417.png" alt="1604495824757"></p><p>VRRP（Virtual Route Redundancy Protocol）协议，翻译过来为虚拟路由冗余协议。VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP,而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER,MASTER实现针对虚拟路由器IP的各种网络功能。其他设备不拥有该虚拟IP，状态为BACKUP,处了接收MASTER的VRRP状态通告信息以外，不执行对外的网络功能。当主机失效时，BACKUP将接管原先MASTER的网络功能。</p><p>从上面的介绍信息获取到的内容就是VRRP是一种协议，那这个协议是用来干什么的？</p><p>1.选择协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VRRP可以把一个虚拟路由器的责任动态分配到局域网上的 VRRP 路由器中的一台。其中的虚拟路由即Virtual路由是由VRRP路由群组创建的一个不真实存在的路由，这个虚拟路由也是有对应的IP地址。而且VRRP路由1和VRRP路由2之间会有竞争选择，通过选择会产生一个Master路由和一个Backup路由。</span><br></pre></td></tr></table></figure><p>2.路由容错协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Master路由和Backup路由之间会有一个心跳检测，Master会定时告知Backup自己的状态，如果在指定的时间内，Backup没有接收到这个通知内容，Backup就会替代Master成为新的Master。Master路由有一个特权就是虚拟路由和后端服务器都是通过Master进行数据传递交互的，而备份节点则会直接丢弃这些请求和数据，不做处理，只是去监听Master的状态</span><br></pre></td></tr></table></figure><p>用了Keepalived后，解决方案如下:</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700418.png" alt="1604495442179"></p><h3 id="环境搭建">环境搭建</h3><p>环境准备</p><table><thead><tr><th>VIP</th><th>IP</th><th>主机名</th><th>主/从</th></tr></thead><tbody><tr><td></td><td>192.168.200.133</td><td>keepalived1</td><td>Master</td></tr><tr><td>192.168.200.222</td><td></td><td></td><td></td></tr><tr><td></td><td>192.168.200.122</td><td>keepalived2</td><td>Backup</td></tr></tbody></table><p>keepalived的安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">步骤1:从官方网站下载keepalived,官网地址https://keepalived.org/</span><br><span class="line">步骤2:将下载的资源上传到服务器</span><br><span class="line">keepalived-2.0.20.tar.gz</span><br><span class="line">步骤3:创建keepalived目录，方便管理资源</span><br><span class="line">mkdir keepalived</span><br><span class="line">步骤4:将压缩文件进行解压缩，解压缩到指定的目录</span><br><span class="line">tar -zxf keepalived-2.0.20.tar.gz -C keepalived/</span><br><span class="line">步骤5:对keepalived进行配置，编译和安装</span><br><span class="line">cd keepalived/keepalived-2.0.20</span><br><span class="line">./configure --sysconf=/etc --prefix=/usr/local</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后，有两个文件需要我们认识下，一个是 <code>/etc/keepalived/keepalived.conf</code>(keepalived的系统配置文件，我们主要操作的就是该文件)，一个是/usr/local/sbin目录下的<code>keepalived</code>,是系统配置脚本，用来启动和关闭keepalived</p><h3 id="Keepalived配置文件介绍">Keepalived配置文件介绍</h3><p>打开keepalived.conf配置文件</p><p>这里面会分三部，第一部分是global全局配置、第二部分是vrrp相关配置、第三部分是LVS相关配置。<br>本次课程主要是使用keepalived实现高可用部署，没有用到LVS，所以我们重点关注的是前两部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">global全局部分：</span><br><span class="line">global_defs &#123;</span><br><span class="line">   #通知邮件，当keepalived发送切换时需要发email给具体的邮箱地址</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     tom@itcast.cn</span><br><span class="line">     jerry@itcast.cn</span><br><span class="line">   &#125;</span><br><span class="line">   #设置发件人的邮箱信息</span><br><span class="line">   notification_email_from zhaomin@itcast.cn</span><br><span class="line">   #指定smpt服务地址</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   #指定smpt服务连接超时时间</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   #运行keepalived服务器的一个标识，可以用作发送邮件的主题信息</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   </span><br><span class="line">   #默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查)</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   #严格遵守VRRP协议。</span><br><span class="line">   vrrp_strict</span><br><span class="line">   #在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   #在一个网卡上每组na消息之间的延迟时间，默认为0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">VRRP部分，该部分可以包含以下四个子模块</span><br><span class="line">1. vrrp_script</span><br><span class="line">2. vrrp_sync_group</span><br><span class="line">3. garp_group</span><br><span class="line">4. vrrp_instance</span><br><span class="line">我们会用到第一个和第四个，</span><br><span class="line">#设置keepalived实例的相关信息，VI_1为VRRP实例名称</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER  #有两个值可选MASTER主 BACKUP备</span><br><span class="line">    interface ens33#vrrp实例绑定的接口，用于发送VRRP包[当前服务器使用的网卡名称]</span><br><span class="line">    virtual_router_id 51#指定VRRP实例ID，范围是0-255</span><br><span class="line">    priority 100#指定优先级，优先级高的将成为MASTER</span><br><span class="line">    advert_int 1#指定发送VRRP通告的间隔，单位是秒</span><br><span class="line">    authentication &#123;#vrrp之间通信的认证信息</span><br><span class="line">        auth_type PASS#指定认证方式。PASS简单密码认证(推荐)</span><br><span class="line">        auth_pass 1111#指定认证使用的密码，最多8位</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123; #虚拟IP地址设置虚拟IP地址，供用户访问使用，可设置多个，一行一个</span><br><span class="line">        192.168.200.222</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置内容如下:</p><p>服务器1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">        tom@itcast.cn</span><br><span class="line">        jerry@itcast.cn</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from zhaomin@itcast.cn</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id keepalived1</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.222</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">        tom@itcast.cn</span><br><span class="line">        jerry@itcast.cn</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from zhaomin@itcast.cn</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id keepalived2</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.222</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问测试">访问测试</h3><ol><li>启动keepalived之前，咱们先使用命令 <code>ip a</code>,查看192.168.200.133和192.168.200.122这两台服务器的IP情况。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700419.png" alt="1604599529242"></p><ol start="2"><li>分别启动两台服务器的keepalived</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/sbin</span><br><span class="line">./keepalived</span><br></pre></td></tr></table></figure><p>再次通过 <code>ip a</code>查看ip</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700420.png" alt="1604599616821"></p><ol start="3"><li>当把192.168.200.133服务器上的keepalived关闭后，再次查看ip</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700421.png" alt="1604599709822"></p><p>通过上述的测试，我们会发现，虚拟IP(VIP)会在MASTER节点上，当MASTER节点上的keepalived出问题以后，因为BACKUP无法收到MASTER发出的VRRP状态通过信息，就会直接升为MASTER。VIP也会&quot;漂移&quot;到新的MASTER。</p><p>上面测试和Nginx有什么关系?</p><p>我们把192.168.200.133服务器的keepalived再次启动下，由于它的优先级高于服务器192.168.200.122的，所有它会再次成为MASTER，VIP也会&quot;漂移&quot;过去，然后我们再次通过浏览器访问:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.222/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700422.png" alt="1604600079149"></p><p>如果把192.168.200.133服务器的keepalived关闭掉，再次访问相同的地址</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700423.png" alt="1604600145318"></p><p>效果实现了以后， 我们会发现要想让vip进行切换，就必须要把服务器上的keepalived进行关闭，而什么时候关闭keepalived呢?应该是在keepalived所在服务器的nginx出现问题后，把keepalived关闭掉，就可以让VIP执行另外一台服务器，但是现在这所有的操作都是通过手动来完成的，我们如何能让系统自动判断当前服务器的nginx是否正确启动，如果没有，要能让VIP自动进行&quot;漂移&quot;，这个问题该如何解决?</p><h3 id="keepalived之vrrp-script">keepalived之vrrp_script</h3><p>keepalived只能做到对网络故障和keepalived本身的监控，即当出现网络故障或者keepalived本身出现问题时，进行切换。但是这些还不够，我们还需要监控keepalived所在服务器上的其他业务，比如Nginx,如果Nginx出现异常了，仅仅keepalived保持正常，是无法完成系统的正常工作的，因此需要根据业务进程的运行状态决定是否需要进行主备切换，这个时候，我们可以通过编写脚本对业务进程进行检测监控。</p><p>实现步骤:</p><ol><li>在keepalived配置文件中添加对应的配置像</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script 脚本名称</span><br><span class="line">&#123;</span><br><span class="line">    script &quot;脚本位置&quot;</span><br><span class="line">    interval 3 #执行时间间隔</span><br><span class="line">    weight -20 #动态调整vrrp_instance的优先级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写脚本</li></ol><p>ck_nginx.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">num=`ps -C nginx --no-header | wc -l`</span><br><span class="line">if [ $num -eq 0 ];then</span><br><span class="line"> /usr/local/nginx/sbin/nginx</span><br><span class="line"> sleep 2</span><br><span class="line"> if [ `ps -C nginx --no-header | wc -l` -eq 0 ]; then</span><br><span class="line">  killall keepalived</span><br><span class="line"> fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>Linux ps命令用于显示当前进程 (process) 的状态。</p><p>-C(command) :指定命令的所有进程</p><p>–no-header 排除标题</p><ol start="3"><li>为脚本文件设置权限</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 ck_nginx.sh</span><br></pre></td></tr></table></figure><ol start="4"><li>将脚本添加到</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script ck_nginx &#123;</span><br><span class="line">   script &quot;/etc/keepalived/ck_nginx.sh&quot; #执行脚本的位置</span><br><span class="line">   interval 2#执行脚本的周期，秒为单位</span><br><span class="line">   weight -20#权重的计算方式</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 10</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.200.111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">      ck_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>如果效果没有出来，可以使用 <code>tail -f /var/log/messages</code>查看日志信息，找对应的错误信息。</li><li>测试</li></ol><p>问题思考:</p><p>通常如果master服务死掉后backup会变成master，但是当master服务又好了的时候 master此时会抢占VIP，这样就会发生两次切换对业务繁忙的网站来说是不好的。所以我们要在配置文件加入 nopreempt 非抢占，但是这个参数只能用于state 为backup，故我们在用HA的时候最好master 和backup的state都设置成backup 让其通过priority来竞争。</p><h1>Nginx制作下载站点</h1><p>首先我们先要清楚什么是下载站点?</p><p>我们先来看一个网站<code>http://nginx.org/download/</code>这个我们刚开始学习Nginx的时候给大家看过这样的网站，该网站主要就是用来提供用户来下载相关资源的网站，就叫做下载网站。</p><p><img src="../../%E4%B8%8A%E8%AF%BE%E5%86%85%E5%AE%B9/doc/Nginx/Nginx/assets/1583825943945.png" alt="1583825943945"></p><p>如何制作一个下载站点:</p><p>nginx使用的是模块ngx_http_autoindex_module来实现的，该模块处理以斜杠(“/”)结尾的请求，并生成目录列表。</p><p>nginx编译的时候会自动加载该模块，但是该模块默认是关闭的，我们需要使用下来指令来完成对应的配置</p><p>（1）autoindex:启用或禁用目录列表输出</p><table><thead><tr><th>语法</th><th>autoindex on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（2）autoindex_exact_size:对应HTLM格式，指定是否在目录列表展示文件的详细大小</p><p>默认为on，显示出文件的确切大小，单位是bytes。<br>改为off后，显示出文件的大概大小，单位是kB或者MB或者GB</p><table><thead><tr><th>语法</th><th>autoindex_exact_size  on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex_exact_size  on;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（3）autoindex_format：设置目录列表的格式</p><table><thead><tr><th>语法</th><th>autoindex_format html|xml|json|jsonp;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex_format html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>注意:该指令在1.7.9及以后版本中出现</p><p>（4）autoindex_localtime:对应HTML格式，是否在目录列表上显示时间。</p><p>默认为off，显示的文件时间为GMT时间。<br>改为on后，显示的文件时间为文件的服务器时间</p><table><thead><tr><th>语法</th><th>autoindex_localtime on | off;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex_localtime off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>配置方式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /download&#123;</span><br><span class="line">    root /usr/local;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size on;</span><br><span class="line">    autoindex_format html;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>XML/JSON格式[一般不用这两种方式]</p><p><img src="../../%E4%B8%8A%E8%AF%BE%E5%86%85%E5%AE%B9/doc/Nginx/Nginx/assets/1583828317365.png" alt="1583828317365"></p><p><img src="../../%E4%B8%8A%E8%AF%BE%E5%86%85%E5%AE%B9/doc/Nginx/Nginx/assets/1583828335279.png" alt="1583828335279"></p><h1>Nginx的用户认证模块</h1><p>对应系统资源的访问，我们往往需要限制谁能访问，谁不能访问。这块就是我们通常所说的认证部分，认证需要做的就是根据用户输入的用户名和密码来判定用户是否为合法用户，如果是则放行访问，如果不是则拒绝访问。</p><p>Nginx对应用户认证这块是通过ngx_http_auth_basic_module模块来实现的，它允许通过使用&quot;HTTP基本身份验证&quot;协议验证用户名和密码来限制对资源的访问。默认情况下nginx是已经安装了该模块，如果不需要则使用–without-http_auth_basic_module。</p><p>该模块的指令比较简单，</p><p>（1）auth_basic:使用“ HTTP基本认证”协议启用用户名和密码的验证</p><table><thead><tr><th>语法</th><th>auth_basic string|off;</th></tr></thead><tbody><tr><td>默认值</td><td>auth_basic off;</td></tr><tr><td>位置</td><td>http,server,location,limit_except</td></tr></tbody></table><p>开启后，服务端会返回401，指定的字符串会返回到客户端，给用户以提示信息，但是不同的浏览器对内容的展示不一致。</p><p>（2）auth_basic_user_file:指定用户名和密码所在文件</p><table><thead><tr><th>语法</th><th>auth_basic_user_file file;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http,server,location,limit_except</td></tr></tbody></table><p>指定文件路径，该文件中的用户名和密码的设置，密码需要进行加密。可以采用工具自动生成</p><p>实现步骤:</p><p>1.nginx.conf添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /download&#123;</span><br><span class="line">    root /usr/local;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_exact_size on;</span><br><span class="line">    autoindex_format html;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">    auth_basic &#x27;please input your auth&#x27;;</span><br><span class="line">    auth_basic_user_file htpasswd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.我们需要使用<code>htpasswd</code>工具生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y httpd-tools</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -c /usr/local/nginx/conf/htpasswd username //创建一个新文件记录用户名和密码</span><br><span class="line">htpasswd -b /usr/local/nginx/conf/htpasswd username password //在指定文件新增一个用户名和密码</span><br><span class="line">htpasswd -D /usr/local/nginx/conf/htpasswd username //从指定文件删除一个用户信息</span><br><span class="line">htpasswd -v /usr/local/nginx/conf/htpasswd username //验证用户名和密码是否正确</span><br></pre></td></tr></table></figure><p><img src="../../%E4%B8%8A%E8%AF%BE%E5%86%85%E5%AE%B9/doc/Nginx/Nginx/assets/1583850151467.png" alt="1583850151467"></p><p>上述方式虽然能实现用户名和密码的验证，但是大家也看到了，所有的用户名和密码信息都记录在文件里面，如果用户量过大的话，这种方式就显得有点麻烦了，这时候我们就得通过后台业务代码来进行用户权限的校验了。</p><h1>Nginx的扩展模块</h1><p>Nginx是可扩展的，可用于处理各种使用场景。本节中，我们将探讨使用Lua扩展Nginx的功能。</p><h2 id="Lua">Lua</h2><h3 id="概念">概念</h3><p>Lua是一种轻量、小巧的脚本语言，用标准C语言编写并以源代码形式开发。设计的目的是为了嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><h3 id="特性">特性</h3><p>跟其他语言进行比较，Lua有其自身的特点：</p><p>（1）轻量级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lua用标准C语言编写并以源代码形式开发，编译后仅仅一百余千字节，可以很方便的嵌入到其他程序中。</span><br></pre></td></tr></table></figure><p>（2）可扩展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lua提供非常丰富易于使用的扩展接口和机制，由宿主语言(通常是C或C++)提供功能，Lua可以使用它们，就像内置的功能一样。</span><br></pre></td></tr></table></figure><p>（3）支持面向过程编程和函数式编程</p><h3 id="应用场景">应用场景</h3><p>Lua在不同的系统中得到大量应用，场景的应用场景如下:</p><p>游戏开发、独立应用脚本、web应用脚本、扩展和数据库插件、系统安全上。</p><h3 id="Lua的安装">Lua的安装</h3><p>在linux上安装Lua非常简单，只需要下载源码包并在终端解压、编译即可使用。</p><p>Lua的官网地址为:<code>https://www.lua.org</code></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700424.png" alt="1604649954522"></p><ol><li>点击download可以找到对应版本的下载地址，我们本次课程采用的是lua-5.3.5,其对应的资源链接地址为https://www.lua.org/ftp/lua-5.4.1.tar.gz,也可以使用wget命令直接下载:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.lua.org/ftp/lua-5.4.1.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>编译安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd lua-5.4.1</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>如果在执行make linux test失败，报如下错误:</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700425.png" alt="1604650028960"></p><p>说明当前系统缺少libreadline-dev依赖包，需要通过命令来进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y readline-devel</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua -v</span><br></pre></td></tr></table></figure><h3 id="Lua的语法">Lua的语法</h3><p>Lua和C/C++语法非常相似，整体上比较清晰，简洁。条件语句、循环语句、函数调用都与C/C++基本一致。如果对C/C++不太熟悉的同学来说，也没关系，因为天下语言是一家，基本上理解起来都不会太困难。我们一点点来讲。</p><h4 id="第一个Lua程序">第一个Lua程序</h4><p>大家需要知道的是，Lua有两种交互方式，分别是:交互式和脚本式，这两者的区别，下面我们分别来讲解下：</p><p>交互式之HELLOWORLD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交互式是指可以在命令行输入程序，然后回车就可以看到运行的效果。</span><br></pre></td></tr></table></figure><p>Lua交互式编程模式可以通过命令lua -i 或lua来启用:</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700426.png" alt="1604650075000"></p><p>在命令行中key输入如下命令，并按回车,会有输出在控制台：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700427.png" alt="1604650092413"></p><p>脚本式之HELLOWORLD</p><p>脚本式是将代码保存到一个以lua为扩展名的文件中并执行的方式。</p><p>方式一:</p><p>我们需要一个文件名为 hello.lua,在文件中添加要执行的代码，然后通过命令 <code>lua hello.lua</code>来执行，会在控制台输出对应的结果。</p><p>hello.lua</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello World!!&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700428.png" alt="1604650118205"></p><p>方式二:</p><p>将hello.lua做如下修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/local/bin/lua</span><br><span class="line">print(&quot;Hello World!!!&quot;)</span><br></pre></td></tr></table></figure><p>第一行用来指定Lua解释器所在位置为 /usr/local/bin/lua，加上#号标记解释器会忽略它。一般情况下#!就是用来指定用哪个程序来运行本文件。但是hello.lua并不是一个可执行文件，需要通过chmod来设置可执行权限，最简单的方式为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 hello.lua</span><br></pre></td></tr></table></figure><p>然后执行该文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.lua</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700429.png" alt="1604650152287"></p><p>补充一点，如果想在交互式中运行脚本式的hello.lua中的内容，我们可以使用一个dofile函数，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dofile(&quot;lua_demo/hello.lua&quot;)</span><br></pre></td></tr></table></figure><p>注意:在Lua语言中，连续语句之间的分隔符并不是必须的，也就是说后面不需要加分号，当然加上也不会报错，</p><p>在Lua语言中，表达式之间的换行也起不到任何作用。如以下四个写法，其实都是等效的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">写法一</span><br><span class="line">a=1</span><br><span class="line">b=a+2</span><br><span class="line">写法二</span><br><span class="line">a=1;</span><br><span class="line">b=a+2;</span><br><span class="line">写法三</span><br><span class="line">a=1; b=a+2;</span><br><span class="line">写法四</span><br><span class="line">a=1 b=a+2</span><br></pre></td></tr></table></figure><p>不建议使用第四种方式，可读性太差。</p><h4 id="Lua的注释">Lua的注释</h4><p>关于Lua的注释要分两种，第一种是单行注释，第二种是多行注释。</p><p>单行注释的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--注释内容</span><br></pre></td></tr></table></figure><p>多行注释的语法为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--[[</span><br><span class="line">注释内容</span><br><span class="line">注释内容</span><br><span class="line">--]]</span><br></pre></td></tr></table></figure><p>如果想取消多行注释，只需要在第一个–之前在加一个-即可，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---[[</span><br><span class="line">注释内容</span><br><span class="line">注释内容</span><br><span class="line">--]]</span><br></pre></td></tr></table></figure><h4 id="标识符">标识符</h4><p>换句话说标识符就是我们的变量名，Lua定义变量名以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。这块建议大家最好不要使用下划线加大写字母的标识符，因为Lua的保留字也是这样定义的，容易发生冲突。注意Lua是区分大小写字母的。</p><p><u>A</u>0</p><h4 id="关键字">关键字</h4><p>下列是Lua的关键字，大家在定义常量、变量或其他用户自定义标识符都要避免使用以下这些关键字：</p><table><thead><tr><th>and</th><th>break</th><th>do</th><th>else</th></tr></thead><tbody><tr><td>elseif</td><td>end</td><td>false</td><td>for</td></tr><tr><td>function</td><td>if</td><td>in</td><td>local</td></tr><tr><td>nil</td><td>not</td><td>or</td><td>repeat</td></tr><tr><td>return</td><td>then</td><td>true</td><td>until</td></tr><tr><td>while</td><td>goto</td><td></td><td></td></tr></tbody></table><p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。这个也是上面我们不建议这么定义标识符的原因。</p><h4 id="运算符">运算符</h4><p>Lua中支持的运算符有算术运算符、关系运算符、逻辑运算符、其他运算符。</p><p>算术运算符:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+   加法</span><br><span class="line">-减法</span><br><span class="line">*乘法</span><br><span class="line">/除法</span><br><span class="line">%取余</span><br><span class="line">^乘幂</span><br><span class="line">-负号</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10+20--&gt;30</span><br><span class="line">20-10--&gt;10</span><br><span class="line">10*20--&gt;200</span><br><span class="line">20/10--&gt;2</span><br><span class="line">3%2--&gt;1</span><br><span class="line">10^2--&gt;100</span><br><span class="line">-10--&gt;-10</span><br></pre></td></tr></table></figure><p>关系运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==等于</span><br><span class="line">~=不等于</span><br><span class="line">&gt;大于</span><br><span class="line">&lt;小于</span><br><span class="line">&gt;=大于等于</span><br><span class="line">&lt;=小于等于</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10==10--&gt;true</span><br><span class="line">10~=10--&gt;false</span><br><span class="line">20&gt;10--&gt;true</span><br><span class="line">20&lt;10--&gt;false</span><br><span class="line">20&gt;=10--&gt;true</span><br><span class="line">20&lt;=10--&gt;false</span><br></pre></td></tr></table></figure><p>逻辑运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and逻辑与 A and B     &amp;&amp;   </span><br><span class="line">or逻辑或 A or B     ||</span><br><span class="line">not逻辑非  取反，如果为true,则返回false  !</span><br></pre></td></tr></table></figure><p>逻辑运算符可以作为if的判断条件，返回的结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A = true</span><br><span class="line">B = true</span><br><span class="line"></span><br><span class="line">A and B--&gt;true</span><br><span class="line">A or  B --&gt;true</span><br><span class="line">not A --&gt;false</span><br><span class="line"></span><br><span class="line">A = true</span><br><span class="line">B = false</span><br><span class="line"></span><br><span class="line">A and B--&gt;false</span><br><span class="line">A or  B --&gt;true</span><br><span class="line">not A --&gt;false</span><br><span class="line"></span><br><span class="line">A = false</span><br><span class="line">B = true</span><br><span class="line"></span><br><span class="line">A and B--&gt;false</span><br><span class="line">A or  B --&gt;true</span><br><span class="line">not A --&gt;true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">..连接两个字符串</span><br><span class="line">#一元预算法，返回字符串或表的长度</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &quot;HELLO &quot;..&quot;WORLD&quot;--&gt;HELLO WORLD</span><br><span class="line">&gt; #&quot;HELLO&quot;--&gt;5</span><br></pre></td></tr></table></figure><h4 id="全局变量-局部变量">全局变量&amp;局部变量</h4><p>在Lua语言中，全局变量无须声明即可使用。在默认情况下，变量总是认为是全局的，如果未提前赋值，默认为nil:</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700430.png" alt="1604650220670"></p><p>要想声明一个局部变量，需要使用local来声明</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700431.png" alt="1604650235860"></p><h4 id="Lua数据类型">Lua数据类型</h4><p>Lua有8个数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nil(空，无效值)</span><br><span class="line">boolean(布尔，true/false)</span><br><span class="line">number(数值)</span><br><span class="line">string(字符串)</span><br><span class="line">function(函数)</span><br><span class="line">table（表）</span><br><span class="line">thread(线程)</span><br><span class="line">userdata（用户数据）</span><br></pre></td></tr></table></figure><p>可以使用type函数测试给定变量或者的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(type(nil))--&gt;nil</span><br><span class="line">print(type(true))               --&gt; boolean</span><br><span class="line">print(type(1.1*1.1))             --&gt; number</span><br><span class="line">print(type(&quot;Hello world&quot;))      --&gt; string</span><br><span class="line">print(type(io.stdin))--&gt;userdata</span><br><span class="line">print(type(print))              --&gt; function</span><br><span class="line">print(type(type))               --&gt;function</span><br><span class="line">print(type&#123;&#125;)--&gt;table</span><br><span class="line">print(type(type(X)))            --&gt; string</span><br></pre></td></tr></table></figure><h5 id="nil">nil</h5><p>nil是一种只有一个nil值的类型，它的作用可以用来与其他所有值进行区分，也可以当想要移除一个变量时，只需要将该变量名赋值为nil,垃圾回收就会会释放该变量所占用的内存。</p><h5 id="boolean">boolean</h5><p>boolean类型具有两个值，true和false。boolean类型一般被用来做条件判断的真与假。在Lua语言中，只会将false和nil视为假，其他的都视为真，特别是在条件检测中0和空字符串都会认为是真，这个和我们熟悉的大多数语言不太一样。</p><h5 id="number">number</h5><p>在Lua5.3版本开始，Lua语言为数值格式提供了两种选择:integer(整型)和float(双精度浮点型)[和其他语言不太一样，float不代表单精度类型]。</p><p>数值常量的表示方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;4--&gt;4</span><br><span class="line">&gt;0.4--&gt;0.4</span><br><span class="line">&gt;4.75e-3--&gt;0.00475</span><br><span class="line">&gt;4.75e3--&gt;4750</span><br></pre></td></tr></table></figure><p>不管是整型还是双精度浮点型，使用type()函数来取其类型，都会返回的是number</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;type(3)--&gt;number</span><br><span class="line">&gt;type(3.3)--&gt;number</span><br></pre></td></tr></table></figure><p>所以它们之间是可以相互转换的，同时，具有相同算术值的整型值和浮点型值在Lua语言中是相等的</p><h5 id="string">string</h5><p>Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍。在Lua语言中，操作100K或者1M个字母组成的字符串的程序很常见。</p><p>可以使用单引号或双引号来声明字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;a = &quot;hello&quot;</span><br><span class="line">&gt;b = &#x27;world&#x27;</span><br><span class="line">&gt;print(a)--&gt;hello</span><br><span class="line">&gt;print(b) --&gt;world</span><br></pre></td></tr></table></figure><p>如果声明的字符串比较长或者有多行，则可以使用如下方式进行声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">html = [[</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Lua-string&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;http://www.lua.org&quot;&gt;Lua&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">]]</span><br></pre></td></tr></table></figure><h5 id="table">table</h5><p>​table是Lua语言中最主要和强大的数据结构。使用表， Lua 语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。 Lua语言中的表本质上是一种辅助数组。这种数组比Java中的数组更加灵活，可以使用数值做索引，也可以使用字符串或其他任意类型的值作索引(除nil外)。</p><p>创建表的最简单方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;&#125;</span><br></pre></td></tr></table></figure><p>创建数组:</p><p>​我们都知道数组就是相同数据类型的元素按照一定顺序排列的集合，那么使用table如何创建一个数组呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;arr = &#123;&quot;TOM&quot;,&quot;JERRY&quot;,&quot;ROSE&quot;&#125;</span><br></pre></td></tr></table></figure><p>​要想获取数组中的值，我们可以通过如下内容来获取:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(arr[0])nil</span><br><span class="line">print(arr[1])TOM</span><br><span class="line">print(arr[2])JERRY</span><br><span class="line">print(arr[3])ROSE</span><br></pre></td></tr></table></figure><p>​从上面的结果可以看出来，数组的下标默认是从1开始的。所以上述创建数组，也可以通过如下方式来创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;arr = &#123;&#125;</span><br><span class="line">&gt;arr[1] = &quot;TOM&quot;</span><br><span class="line">&gt;arr[2] = &quot;JERRY&quot;</span><br><span class="line">&gt;arr[3] = &quot;ROSE&quot;</span><br></pre></td></tr></table></figure><p>上面我们说过了，表的索引即可以是数字，也可以是字符串等其他的内容，所以我们也可以将索引更改为字符串来创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;arr = &#123;&#125;</span><br><span class="line">&gt;arr[&quot;X&quot;] = 10</span><br><span class="line">&gt;arr[&quot;Y&quot;] = 20</span><br><span class="line">&gt;arr[&quot;Z&quot;] = 30</span><br></pre></td></tr></table></figure><p>当然，如果想要获取这些数组中的值，可以使用下面的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方式一</span><br><span class="line">&gt;print(arr[&quot;X&quot;])</span><br><span class="line">&gt;print(arr[&quot;Y&quot;])</span><br><span class="line">&gt;print(arr[&quot;Z&quot;])</span><br><span class="line">方式二</span><br><span class="line">&gt;print(arr.X)</span><br><span class="line">&gt;print(arr.Y)</span><br><span class="line">&gt;print(arr.Z)</span><br></pre></td></tr></table></figure><p>当前table的灵活不进于此，还有更灵活的声明方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;arr = &#123;&quot;TOM&quot;,X=10,&quot;JERRY&quot;,Y=20,&quot;ROSE&quot;,Z=30&#125;</span><br></pre></td></tr></table></figure><p>如何获取上面的值?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TOM :  arr[1]</span><br><span class="line">10  :  arr[&quot;X&quot;] | arr.X</span><br><span class="line">JERRY: arr[2]</span><br><span class="line">20  :  arr[&quot;Y&quot;] | arr.Y</span><br><span class="line">ROESE?</span><br></pre></td></tr></table></figure><h5 id="function">function</h5><p>在 Lua语言中，函数（ Function ）是对语句和表达式进行抽象的主要方式。</p><p>定义函数的语法为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function functionName(params)</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>函数被调用的时候，传入的参数个数与定义函数时使用的参数个数不一致的时候，Lua 语言会通过 抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function  f(a,b)</span><br><span class="line">print(a,b)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">f()--&gt; nil  nil</span><br><span class="line">f(2)--&gt; 2 nil</span><br><span class="line">f(2,6)--&gt; 2 6</span><br><span class="line">f(2.6.8)--&gt; 2 6 (8被丢弃)</span><br></pre></td></tr></table></figure><p>可变长参数函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(...)</span><br><span class="line">a,b,c=...</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">add(1,2,3)  --&gt; 1 2 3</span><br></pre></td></tr></table></figure><p>函数返回值可以有多个，这点和Java不太一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a,b)</span><br><span class="line">return a,b</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">x,y=f(11,22)--&gt; x=11,y=22</span><br></pre></td></tr></table></figure><h5 id="thread">thread</h5><p>thread翻译过来是线程的意思，在Lua中，thread用来表示执行的独立线路，用来执行协同程序。</p><h5 id="userdata">userdata</h5><p>userdata是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型。</p><h4 id="Lua控制结构">Lua控制结构</h4><p>Lua 语言提供了一组精简且常用的控制结构，包括用于条件执行的证 以及用于循环的 while、 repeat 和 for。 所有的控制结构语法上都有一个显式的终结符： end 用于终结 if、 for 及 while 结构， until 用于终结 repeat 结构。</p><h5 id="if-then-elseif-else">if then elseif else</h5><p>if语句先测试其条件，并根据条件是否满足执行相应的 then 部分或 else 部分。 else 部分 是可选的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function testif(a)</span><br><span class="line"> if a&gt;0 then</span><br><span class="line"> print(&quot;a是正数&quot;)</span><br><span class="line"> end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function testif(a)</span><br><span class="line"> if a&gt;0 then</span><br><span class="line"> print(&quot;a是正数&quot;)</span><br><span class="line"> else</span><br><span class="line"> print(&quot;a是负数&quot;)</span><br><span class="line"> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果要编写嵌套的 if 语句，可以使用 elseif。 它类似于在 else 后面紧跟一个if。根据传入的年龄返回不同的结果，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">age&lt;=18 青少年，</span><br><span class="line">age&gt;18 , age &lt;=45 青年</span><br><span class="line">age&gt;45 , age&lt;=60 中年人</span><br><span class="line">age&gt;60 老年人</span><br><span class="line"></span><br><span class="line">function show(age)</span><br><span class="line">if age&lt;=18 then</span><br><span class="line"> return &quot;青少年&quot;</span><br><span class="line">elseif age&gt;18 and age&lt;=45 then</span><br><span class="line"> return &quot;青年&quot;</span><br><span class="line">elseif age&gt;45 and age&lt;=60 then</span><br><span class="line"> return &quot;中年人&quot;</span><br><span class="line">elseif age&gt;60 then</span><br><span class="line"> return &quot;老年人&quot;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="while循环">while循环</h5><p>顾名思义，当条件为真时 while 循环会重复执行其循环体。 Lua 语言先测试 while 语句 的条件，若条件为假则循环结束；否则， Lua 会执行循环体并不断地重复这个过程。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line">  循环体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>例子:实现数组的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function testWhile()</span><br><span class="line"> local i = 1</span><br><span class="line"> while i&lt;=10 do</span><br><span class="line">  print(i)</span><br><span class="line">  i=i+1</span><br><span class="line"> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="repeat循环">repeat循环</h5><p>顾名思义， repeat-until语句会重复执行其循环体直到条件为真时结束。 由于条件测试在循环体之后执行，所以循环体至少会执行一次。</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line"> 循环体</span><br><span class="line"> until 条件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function testRepeat()</span><br><span class="line"> local i = 10</span><br><span class="line"> repeat</span><br><span class="line">  print(i)</span><br><span class="line">  i=i-1</span><br><span class="line"> until i &lt; 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="for循环">for循环</h5><p>数值型for循环</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for param=exp1,exp2,exp3 do</span><br><span class="line"> 循环体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>param的值从exp1变化到exp2之前的每次循环会执行 循环体，并在每次循环结束后将步长(step)exp3增加到param上。exp3可选，如果不设置默认为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 1,100,10 do</span><br><span class="line">print(i)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>泛型for循环</p><p>泛型for循环通过一个迭代器函数来遍历所有值，类似于java中的foreach语句。</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i,v in ipairs(x) do</span><br><span class="line">循环体</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>i是数组索引值，v是对应索引的数组元素值，ipairs是Lua提供的一个迭代器函数，用来迭代数组，x是要遍历的数组。</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;&quot;TOME&quot;,&quot;JERRY&quot;,&quot;ROWS&quot;,&quot;LUCY&quot;&#125;</span><br><span class="line">for i,v in ipairs(arr) do</span><br><span class="line"> print(i,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上述实例输出的结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1TOM</span><br><span class="line">2JERRY</span><br><span class="line">3ROWS</span><br><span class="line">4LUCY</span><br></pre></td></tr></table></figure><p>但是如果将arr的值进行修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;&quot;TOME&quot;,&quot;JERRY&quot;,&quot;ROWS&quot;,x=&quot;JACK&quot;,&quot;LUCY&quot;&#125;</span><br></pre></td></tr></table></figure><p>同样的代码在执行的时候，就只能看到和之前一样的结果，而其中的x为JACK就无法遍历出来，缺失了数据，如果解决呢?</p><p>我们可以将迭代器函数变成pairs,如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i,v in pairs(arr) do</span><br><span class="line"> print(i,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上述实例就输出的结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1TOM</span><br><span class="line">2JERRY</span><br><span class="line">3ROWS</span><br><span class="line">4LUCY</span><br><span class="line">xJACK</span><br></pre></td></tr></table></figure><h2 id="ngx-lua模块概念">ngx_lua模块概念</h2><p>淘宝开发的ngx_lua模块通过将lua解释器集成进Nginx，可以采用lua脚本实现业务逻辑，由于lua的紧凑、快速以及内建协程，所以在保证高并发服务能力的同时极大地降低了业务逻辑实现成本。</p><h2 id="ngx-lua模块环境准备">ngx_lua模块环境准备</h2><h3 id="方式一-lua-nginx-module">方式一:lua-nginx-module</h3><ol><li>LuaJIT是采用C语言编写的Lua代表的解释器。</li></ol><p>官网地址为:<a href="http://luajit.org/">http://luajit.org/</a></p><p>在官网上找到对应的下载地址:<a href="http://luajit.org/download/LuaJIT-2.0.5.tar.gz">http://luajit.org/download/LuaJIT-2.0.5.tar.gz</a></p><p>在centos上使用wget来下载: wget <a href="http://luajit.org/download/LuaJIT-2.0.5.tar.gz">http://luajit.org/download/LuaJIT-2.0.5.tar.gz</a></p><p>将下载的资源进行解压: tar -zxf LuaJIT-2.0.5.tar.gz</p><p>进入解压的目录: cd LuaJIT-2.0.5</p><p>执行编译和安装: make &amp;&amp; make install</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700432.png" alt="1604636335626"></p><ol start="2"><li>下载lua-nginx-module</li></ol><p>下载地址:<a href="https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz">https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz</a></p><p>在centos上使用wget来下载: wget <a href="https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz">https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz</a></p><p>将下载的资源进行解压: tar -zxf lua-nginx-module-0.10.16rc4.tar.gz</p><p>更改目录名:mv lua-nginx-module-0.10.16rc4 lua-nginx-module</p><p>导入环境变量，告诉Nginx去哪里找luajit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LUAJIT_LIB=/usr/local/lib</span><br><span class="line">export LUAJIT_INC=/usr/local/include/luajit-2.0</span><br></pre></td></tr></table></figure><p>进入Nginx的目录执行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --add-module=../lua-nginx-module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意事项:</p><p>（1）如果启动Nginx出现如下错误:</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700433.png" alt="1604636421045"></p><p>解决方案:</p><p>设置软链接，使用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2</span><br></pre></td></tr></table></figure><p>（2）如果启动Nginx出现以下错误信息</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700435.png" alt="1604636405241"></p><p>分析原因:因为lua-nginx-module是来自openrestry,错误中提示的resty.core是openrestry的核心模块，对其下的很多函数进行了优化等工作。以前的版本默认不会把该模块编译进去，所以需要使用的话，我们得手动安装，或者禁用就可以。但是最新的lua-nginx-module模块已经强制性安装了该模块，所以此处因为缺少resty模块导致的报错信息。</p><p>解决方案有两个:一种是下载对应的模块，另一种则是禁用掉restry模块，禁用的方式为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">lua_load_resty_core off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><p>在nginx.conf下配置如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /lua&#123;</span><br><span class="line">    default_type &#x27;text/html&#x27;;</span><br><span class="line">    content_by_lua &#x27;ngx.say(&quot;&lt;h1&gt;HELLO,LUA&lt;/h1&gt;&quot;)&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置成功后，启动nginx,通过浏览器进行访问，如果获取到如下结果，则证明安装成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700436.png" alt="1604636592232"></p><h3 id="方式二-OpenRestry">方式二:OpenRestry</h3><h4 id="概述">概述</h4><p>​前面我们提到过，OpenResty是由淘宝工程师开发的，所以其官方网站(<a href="http://openresty.org/">http://openresty.org/</a>)我们读起来是非常的方便。OpenResty是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。所以本身OpenResty内部就已经集成了Nginx和Lua，所以我们使用起来会更加方便。</p><h4 id="安装">安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(1) 下载OpenResty：https://openresty.org/download/openresty-1.15.8.2.tar.gz</span><br><span class="line">(2)使用wget下载: wget https://openresty.org/download/openresty-1.15.8.2.tar.gz</span><br><span class="line">(3)解压缩: tar -zxf openresty-1.15.8.2.tar.gz</span><br><span class="line">(4)进入OpenResty目录: cd openresty-1.15.8.2</span><br><span class="line">(5) 执行命令:./configure</span><br><span class="line">(6) 执行命令:make &amp;&amp; make install</span><br><span class="line">(7)进入OpenResty的目录，找到nginx：cd /usr/local/openresty/nginx/</span><br><span class="line">(8)在conf目录下的nginx.conf添加如下内容</span><br><span class="line">location /lua&#123;</span><br><span class="line">    default_type &#x27;text/html&#x27;;</span><br><span class="line">    content_by_lua &#x27;ngx.say(&quot;&lt;h1&gt;HELLO,OpenRestry&lt;/h1&gt;&quot;)&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">(9)在sbin目录下启动nginx</span><br><span class="line">(10)通过浏览器访问测试</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700437.png" alt="1604636706604"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700438.png" alt="1604636719140"></p><h2 id="ngx-lua的使用">ngx_lua的使用</h2><p>使用Lua编写Nginx脚本的基本构建块是指令。指令用于指定何时运行用户Lua代码以及如何使用结果。下图显示了执行指令的顺序。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700439.png" alt="1604717983815"></p><p>先来解释下*的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*：无 ， 即 xxx_by_lua ,指令后面跟的是 lua指令</span><br><span class="line">*:_file，即 xxx_by_lua_file 指令后面跟的是 lua文件</span><br><span class="line">*:_block,即 xxx_by_lua_block 在0.9.17版后替换init_by_lua_file</span><br></pre></td></tr></table></figure><h3 id="init-by-lua">init_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令在每次Nginx重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。</span><br></pre></td></tr></table></figure><h3 id="init-worker-by-lua">init_worker_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。</span><br></pre></td></tr></table></figure><h3 id="set-by-lua">set_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。</span><br></pre></td></tr></table></figure><h3 id="rewrite-by-lua">rewrite_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令用于执行内部URL重写或者外部重定向，典型的如伪静态化URL重写，本阶段在rewrite处理阶段的最后默认执行。</span><br></pre></td></tr></table></figure><h3 id="access-by-lua">access_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令用于访问控制。例如，如果只允许内网IP访问。</span><br></pre></td></tr></table></figure><h3 id="content-by-lua">content_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令是应用最多的指令，大部分任务是在这个阶段完成的，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。</span><br></pre></td></tr></table></figure><h3 id="header-filter-by-lua">header_filter_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令用于设置应答消息的头部信息。</span><br></pre></td></tr></table></figure><h3 id="body-filter-by-lua">body_filter_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令是对响应数据进行过滤，如截断、替换。</span><br></pre></td></tr></table></figure><h3 id="log-by-lua">log_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令用于在log请求处理阶段，用Lua代码处理日志，但并不替换原有log处理。</span><br></pre></td></tr></table></figure><h3 id="balancer-by-lua">balancer_by_lua*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令主要的作用是用来实现上游服务器的负载均衡器算法</span><br></pre></td></tr></table></figure><h3 id="ssl-certificate-by">ssl_certificate_by_*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该指令作用在Nginx和下游服务开始一个SSL握手操作时将允许本配置项的Lua代码。</span><br></pre></td></tr></table></figure><h3 id="需求">需求:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.133?name=张三&amp;gender=1</span><br><span class="line">Nginx接收到请求后，根据gender传入的值，如果gender传入的是1，则在页面上展示</span><br><span class="line">张三先生,如果gender传入的是0，则在页面上展示张三女士,如果未传或者传入的不是1和2则在页面上展示张三。</span><br></pre></td></tr></table></figure><p>实现代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">location /getByGender &#123;</span><br><span class="line">default_type &#x27;text/html&#x27;;</span><br><span class="line">set_by_lua $name &quot;</span><br><span class="line">local uri_args = ngx.req.get_uri_args()</span><br><span class="line">gender = uri_args[&#x27;gender&#x27;]</span><br><span class="line">name = uri_args[&#x27;name&#x27;]</span><br><span class="line">if gender==&#x27;1&#x27; then</span><br><span class="line">return name..&#x27;先生&#x27;</span><br><span class="line">elseif gender==&#x27;0&#x27; then</span><br><span class="line">return name..&#x27;女士&#x27;</span><br><span class="line">else</span><br><span class="line">return name</span><br><span class="line">end</span><br><span class="line">&quot;;</span><br><span class="line">header_filter_by_lua &quot;</span><br><span class="line">ngx.header.aaa=&#x27;bbb&#x27;</span><br><span class="line">&quot;;</span><br><span class="line">return 200 $name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ngx-lua操作Redis">ngx_lua操作Redis</h2><p>Redis在系统中经常作为数据缓存、内存数据库使用，在大型系统中扮演着非常重要的作用。在Nginx核心系统中，Redis是常备组件。Nginx支持3种方法访问Redis,分别是HttpRedis模块、HttpRedis2Module、lua-resty-redis库。这三种方式中HttpRedis模块提供的指令少，功能单一，适合做简单缓存，HttpRedis2Module模块比HttpRedis模块操作更灵活，功能更强大。而Lua-resty-redis库是OpenResty提供的一个操作Redis的接口库，可根据自己的业务情况做一些逻辑处理，适合做复杂的业务逻辑。所以本次课程将主要以Lua-resty-redis来进行讲解。</p><h3 id="lua-resty-redis环境准备">lua-resty-redis环境准备</h3><p>步骤一:准备一个Redis环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接地址</span><br><span class="line">host= 192.168.200.111</span><br><span class="line">port=6379</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700440.png" alt="1604726959698"></p><p>步骤二:准备对应的API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lua-resty-redis提供了访问Redis的详细API，包括创建对接、连接、操作、数据处理等。这些API基本上与Redis的操作一一对应。</span><br><span class="line">（1）redis = require &quot;resty.redis&quot;</span><br><span class="line">（2）new</span><br><span class="line">语法: redis,err = redis:new(),创建一个Redis对象。</span><br><span class="line">（3）connect</span><br><span class="line">语法:ok,err=redis:connect(host,port[,options_table]),设置连接Redis的连接信息。</span><br><span class="line">ok:连接成功返回 1，连接失败返回nil</span><br><span class="line">err:返回对应的错误信息</span><br><span class="line">（4）set_timeout</span><br><span class="line">语法: redis:set_timeout(time) ，设置请求操作Redis的超时时间。</span><br><span class="line">（5）close</span><br><span class="line">语法: ok,err = redis:close(),关闭当前连接，成功返回1，失败返回nil和错误信息</span><br><span class="line">（6）redis命令对应的方法</span><br><span class="line">在lua-resty-redis中，所有的Redis命令都有自己的方法，方法名字和命令名字相同，只是全部为小写。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>步骤三:效果实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    default_type &quot;text/html&quot;;</span><br><span class="line">    content_by_lua_block&#123;</span><br><span class="line">        local redis = require &quot;resty.redis&quot; -- 引入Redis</span><br><span class="line">        local redisObj = redis:new()  --创建Redis对象</span><br><span class="line">        redisObj:set_timeout(1000) --设置超时数据为1s</span><br><span class="line">        local ok,err = redisObj:connect(&quot;192.168.200.1&quot;,6379) --设置redis连接信息</span><br><span class="line">        if not ok then --判断是否连接成功</span><br><span class="line">         ngx.say(&quot;failed to connection redis&quot;,err)</span><br><span class="line">         return</span><br><span class="line">        end</span><br><span class="line">        ok,err = redisObj:set(&quot;username&quot;,&quot;TOM&quot;)--存入数据</span><br><span class="line">        if not ok then --判断是否存入成功</span><br><span class="line">         ngx.say(&quot;failed to set username&quot;,err)</span><br><span class="line">         return</span><br><span class="line">        end</span><br><span class="line">        local res,err = redisObj:get(&quot;username&quot;) --从redis中获取数据</span><br><span class="line">        ngx.say(res)--将数据写会消息体中</span><br><span class="line">        redisObj:close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤四:运行测试效果</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700441.png" alt="1604727475883"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211700442.png" alt="1604727483869"></p><h2 id="ngx-lua操作Mysql">ngx_lua操作Mysql</h2><p>MySQL是一个使用广泛的关系型数据库。在ngx_lua中，MySQL有两种访问模式,分别是使</p><p>（1）用ngx_lua模块和lua-resty-mysql模块：这两个模块是安装OpenResty时默认安装的。</p><p>（2）使用drizzle_nginx_module(HttpDrizzleModule)模块：需要单独安装，这个库现不在OpenResty中。</p><h3 id="lua-resty-mysql">lua-resty-mysql</h3><p>lua-resty-mysql是OpenResty开发的模块，使用灵活、功能强大，适合复杂的业务场景，同时支持存储过程的访问。</p><h4 id="使用lua-resty-mysql实现数据库的查询">使用lua-resty-mysql实现数据库的查询</h4><p>步骤一:</p><p>准备MYSQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host: 192.168.200.111</span><br><span class="line">port: 3306</span><br><span class="line">username:root</span><br><span class="line">password:123456</span><br></pre></td></tr></table></figure><p>创建一个数据库表及表中的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create database nginx_db;</span><br><span class="line"></span><br><span class="line">use nginx_db;</span><br><span class="line"></span><br><span class="line">create table users(</span><br><span class="line">   id int primary key auto_increment,</span><br><span class="line">   username varchar(30),</span><br><span class="line">   birthday date,</span><br><span class="line">   salary double</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into users(id,username,birthday,salary) values(null,&quot;TOM&quot;,&quot;1988-11-11&quot;,10000.0);</span><br><span class="line">insert into users(id,username,birthday,salary) values(null,&quot;JERRY&quot;,&quot;1989-11-11&quot;,20000.0);</span><br><span class="line">insert into users(id,username,birthday,salary) values(null,&quot;ROWS&quot;,&quot;1990-11-11&quot;,30000.0);</span><br><span class="line">insert into users(id,username,birthday,salary) values(null,&quot;LUCY&quot;,&quot;1991-11-11&quot;,40000.0);</span><br><span class="line">insert into users(id,username,birthday,salary) values(null,&quot;JACK&quot;,&quot;1992-11-11&quot;,50000.0);</span><br></pre></td></tr></table></figure><p>数据库连接四要素:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://192.168.200.111:3306/nginx_db</span><br><span class="line">username=root</span><br><span class="line">password=123456</span><br></pre></td></tr></table></figure><p>步骤二:API学习</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">（1）引入&quot;resty.mysql&quot;模块</span><br><span class="line">local mysql = require &quot;resty.mysql&quot;</span><br><span class="line">（2）new</span><br><span class="line">创建一个MySQL连接对象，遇到错误时，db为nil，err为错误描述信息</span><br><span class="line">语法: db,err = mysql:new()</span><br><span class="line">（3）connect</span><br><span class="line">尝试连接到一个MySQL服务器</span><br><span class="line">语法:ok,err=db:connect(options),options是一个参数的Lua表结构，里面包含数据库连接的相关信息</span><br><span class="line">    host:服务器主机名或IP地址</span><br><span class="line">    port:服务器监听端口，默认为3306</span><br><span class="line">    user:登录的用户名</span><br><span class="line">    password:登录密码</span><br><span class="line">    database:使用的数据库名</span><br><span class="line">（4）set_timeout</span><br><span class="line">设置子请求的超时时间(ms)，包括connect方法</span><br><span class="line">语法:db:set_timeout(time)</span><br><span class="line">（5）close</span><br><span class="line">关闭当前MySQL连接并返回状态。如果成功，则返回1；如果出现任何错误，则将返回nil和错误描述。</span><br><span class="line">语法:db:close()</span><br><span class="line">（6）send_query</span><br><span class="line">异步向远程MySQL发送一个查询。如果成功则返回成功发送的字节数；如果错误，则返回nil和错误描述</span><br><span class="line">语法:bytes,err=db:send_query(sql)</span><br><span class="line">（7）read_result</span><br><span class="line">从MySQL服务器返回结果中读取一行数据。res返回一个描述OK包或结果集包的Lua表,语法:</span><br><span class="line">res, err, errcode, sqlstate = db:read_result() </span><br><span class="line">res, err, errcode, sqlstate = db:read_result(rows) :rows指定返回结果集的最大值，默认为4</span><br><span class="line">如果是查询，则返回一个容纳多行的数组。每行是一个数据列的key-value对，如</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      &#123;id=1,username=&quot;TOM&quot;,birthday=&quot;1988-11-11&quot;,salary=10000.0&#125;,</span><br><span class="line">      &#123;id=2,username=&quot;JERRY&quot;,birthday=&quot;1989-11-11&quot;,salary=20000.0&#125;</span><br><span class="line">    &#125;</span><br><span class="line">如果是增删改，则返回类上如下数据</span><br><span class="line">    &#123;</span><br><span class="line">    insert_id = 0,</span><br><span class="line">    server_status=2,</span><br><span class="line">    warning_count=1,</span><br><span class="line">    affected_rows=2,</span><br><span class="line">    message=nil</span><br><span class="line">    &#125;</span><br><span class="line">返回值:</span><br><span class="line">res:操作的结果集</span><br><span class="line">err:错误信息</span><br><span class="line">errcode:MySQL的错误码，比如1064</span><br><span class="line">sqlstate:返回由5个字符组成的标准SQL错误码，比如42000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>步骤三:效果实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line">    content_by_lua_block&#123;</span><br><span class="line">        local mysql = require &quot;resty.mysql&quot;</span><br><span class="line">        local db = mysql:new()</span><br><span class="line">        local ok,err = db:connect&#123;</span><br><span class="line">            host=&quot;192.168.200.111&quot;,</span><br><span class="line">            port=3306,</span><br><span class="line">            user=&quot;root&quot;,</span><br><span class="line">            password=&quot;123456&quot;,</span><br><span class="line">            database=&quot;nginx_db&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        db:set_timeout(1000)</span><br><span class="line"></span><br><span class="line">        db:send_query(&quot;select * from users where id =1&quot;)</span><br><span class="line">        local res,err,errcode,sqlstate = db:read_result()</span><br><span class="line">        ngx.say(res[1].id..&quot;,&quot;..res[1].username..&quot;,&quot;..res[1].birthday..&quot;,&quot;..res[1].salary)</span><br><span class="line">    db:close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.如何获取返回数据的内容</span><br><span class="line">2.如何实现查询多条数据</span><br><span class="line">3.如何实现数据库的增删改操作</span><br></pre></td></tr></table></figure><h4 id="使用lua-cjson处理查询结果">使用lua-cjson处理查询结果</h4><p>通过上述的案例学习，read_result()得到的结果res都是table类型，要想在页面上展示，就必须知道table的具体数据结构才能进行遍历获取。处理起来比较麻烦，接下来我们介绍一种简单方式cjson，使用它就可以将table类型的数据转换成json字符串，把json字符串展示在页面上即可。具体如何使用?</p><p>步骤一：引入cjson</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local cjson = require &quot;cjson&quot;</span><br></pre></td></tr></table></figure><p>步骤二：调用cjson的encode方法进行类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cjson.encode(res) </span><br></pre></td></tr></table></figure><p>步骤三:使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line">    content_by_lua_block&#123;</span><br><span class="line"></span><br><span class="line">        local mysql = require &quot;resty.mysql&quot;</span><br><span class="line">        local cjson = require &quot;cjson&quot;</span><br><span class="line"></span><br><span class="line">        local db = mysql:new()</span><br><span class="line"></span><br><span class="line">        local ok,err = db:connect&#123;</span><br><span class="line">            host=&quot;192.168.200.111&quot;,</span><br><span class="line">            port=3306,</span><br><span class="line">            user=&quot;root&quot;,</span><br><span class="line">            password=&quot;123456&quot;,</span><br><span class="line">            database=&quot;nginx_db&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        db:set_timeout(1000)</span><br><span class="line"></span><br><span class="line">        --db:send_query(&quot;select * from users where id = 2&quot;)</span><br><span class="line">        db:send_query(&quot;select * from users&quot;)</span><br><span class="line">        local res,err,errcode,sqlstate = db:read_result()</span><br><span class="line">        ngx.say(cjson.encode(res))</span><br><span class="line">         for i,v in ipairs(res) do</span><br><span class="line">       ngx.say(v.id..&quot;,&quot;..v.username..&quot;,&quot;..v.birthday..&quot;,&quot;..v.salary)</span><br><span class="line">        end</span><br><span class="line">    db:close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lua-resty-mysql实现数据库的增删改">lua-resty-mysql实现数据库的增删改</h4><p>优化send_query和read_result</p><p>本方法是send_query和read_result组合的快捷方法。</p><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res, err, errcode, sqlstate = db:query(sql[,rows])</span><br></pre></td></tr></table></figure><p>有了该API，上面的代码我们就可以进行对应的优化，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line">    content_by_lua_block&#123;</span><br><span class="line"></span><br><span class="line">        local mysql = require &quot;resty.mysql&quot;</span><br><span class="line"></span><br><span class="line">        local db = mysql:new()</span><br><span class="line"></span><br><span class="line">        local ok,err = db:connect&#123;</span><br><span class="line">        host=&quot;192.168.200.1&quot;,</span><br><span class="line">        port=3306,</span><br><span class="line">        user=&quot;root&quot;,</span><br><span class="line">        password=&quot;123456&quot;,</span><br><span class="line">        database=&quot;nginx_db&quot;,</span><br><span class="line">        max_packet_size=1024,</span><br><span class="line">        compact_arrays=false</span><br><span class="line">        &#125;</span><br><span class="line">        db:set_timeout(1000)</span><br><span class="line">        local res,err,errcode,sqlstate = db:query(&quot;select * from users&quot;)</span><br><span class="line">        --local res,err,errcode,sqlstate = db:query(&quot;insert into users(id,username,birthday,salary) values(null,&#x27;zhangsan&#x27;,&#x27;2020-11-11&#x27;,32222.0)&quot;)</span><br><span class="line">        --local res,err,errcode,sqlstate = db:query(&quot;update users set username=&#x27;lisi&#x27; where id = 6&quot;)</span><br><span class="line">        --local res,err,errcode,sqlstate = db:query(&quot;delete from users where id = 6&quot;)</span><br><span class="line">        db:close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="综合小案例">综合小案例</h3><p>使用ngx_lua模块完成Redis缓存预热。</p><p>分析:</p><p>（1）先得有一张表(users)</p><p>（2）浏览器输入如下地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://191.168.200.133?username=TOM</span><br></pre></td></tr></table></figure><p>（3）从表中查询出符合条件的记录，此时获取的结果为table类型</p><p>（4）使用cjson将table数据转换成json字符串</p><p>（5）将查询的结果数据存入Redis中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">init_by_lua_block&#123;</span><br><span class="line"></span><br><span class="line">redis = require &quot;resty.redis&quot;</span><br><span class="line">    mysql = require &quot;resty.mysql&quot;</span><br><span class="line">    cjson = require &quot;cjson&quot;</span><br><span class="line">&#125;</span><br><span class="line">location /&#123;</span><br><span class="line">default_type &quot;text/html&quot;;</span><br><span class="line">content_by_lua_block&#123;</span><br><span class="line"></span><br><span class="line">--获取请求的参数username</span><br><span class="line">local param = ngx.req.get_uri_args()[&quot;username&quot;]</span><br><span class="line">--建立mysql数据库的连接</span><br><span class="line">local db = mysql:new()</span><br><span class="line">local ok,err = db:connect&#123;</span><br><span class="line">host=&quot;192.168.200.111&quot;,</span><br><span class="line">port=3306,</span><br><span class="line">user=&quot;root&quot;,</span><br><span class="line">password=&quot;123456&quot;,</span><br><span class="line">database=&quot;nginx_db&quot;</span><br><span class="line">&#125;</span><br><span class="line">if not ok then</span><br><span class="line"> ngx.say(&quot;failed connect to mysql:&quot;,err)</span><br><span class="line"> return</span><br><span class="line">end</span><br><span class="line">--设置连接超时时间</span><br><span class="line">db:set_timeout(1000)</span><br><span class="line">--查询数据</span><br><span class="line">local sql = &quot;&quot;;</span><br><span class="line">if not param then</span><br><span class="line">sql=&quot;select * from users&quot;</span><br><span class="line">else</span><br><span class="line">sql=&quot;select * from users where username=&quot;..&quot;&#x27;&quot;..param..&quot;&#x27;&quot;</span><br><span class="line">end</span><br><span class="line">local res,err,errcode,sqlstate=db:query(sql)</span><br><span class="line">if not res then</span><br><span class="line"> ngx.say(&quot;failed to query from mysql:&quot;,err)</span><br><span class="line"> return</span><br><span class="line">end</span><br><span class="line">--连接redis</span><br><span class="line">local rd = redis:new()</span><br><span class="line">ok,err = rd:connect(&quot;192.168.200.111&quot;,6379)</span><br><span class="line">if not ok then</span><br><span class="line"> ngx.say(&quot;failed to connect to redis:&quot;,err)</span><br><span class="line"> return</span><br><span class="line">end</span><br><span class="line">rd:set_timeout(1000)</span><br><span class="line">--循环遍历数据</span><br><span class="line">for i,v in ipairs(res) do</span><br><span class="line"> rd:set(&quot;user_&quot;..v.username,cjson.encode(v))</span><br><span class="line">end</span><br><span class="line">ngx.say(&quot;success&quot;)</span><br><span class="line">rd:close()</span><br><span class="line">db:close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习（三）--- 反向代理</title>
      <link href="/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%B8%89/"/>
      <url>/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Rewrite功能配置">Rewrite功能配置</h2><p>Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。<a href="http://www.jd.com">www.jd.com</a><br>注意:Nginx服务器的Rewrite功能的实现依赖于PCRE的支持，因此在编译安装Nginx服务器之前，需要安装PCRE库。Nginx使用的是ngx_http_rewrite_module模块来解析和处理Rewrite功能的相关配置。</p><p>Rewrite的相关命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set指令</span><br><span class="line">if指令</span><br><span class="line">break指令</span><br><span class="line">return指令</span><br><span class="line">rewrite指令</span><br><span class="line">rewrite_log指令</span><br></pre></td></tr></table></figure><p>Rewrite的应用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">域名跳转</span><br><span class="line">域名镜像</span><br><span class="line">独立域名</span><br><span class="line">目录自动添加&quot;/&quot;</span><br><span class="line">合并目录</span><br><span class="line">防盗链的实现</span><br></pre></td></tr></table></figure><h3 id="Rewrite的相关指令">Rewrite的相关指令</h3><h4 id="set指令">set指令</h4><p>该指令用来设置一个新的变量。</p><table><thead><tr><th>语法</th><th>set $variable value;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>variable:变量的名称，该变量名称要用&quot;$&quot;作为变量的第一个字符，且不要与Nginx服务器预设的全局变量同名。</p><p>value:变量的值，可以是字符串、其他变量或者变量的组合等。</p><h4 id="Rewrite常用全局变量">Rewrite常用全局变量</h4><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$args</td><td>变量中存放了请求URL中的请求参数。比如http://192.168.200.133/server?arg1=value1&amp;args2=value2中的&quot;arg1=value1&amp;arg2=value2&quot;，功能和$query_string一样</td></tr><tr><td>$http_user_agent</td><td>变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息)</td></tr><tr><td>$host</td><td>变量存储的是访问服务器的server_name值</td></tr><tr><td>$document_uri</td><td>变量存储的是当前访问地址的URI。比如http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server&quot;，功能和$uri一样</td></tr><tr><td>$document_root</td><td>变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置</td></tr><tr><td>$content_length</td><td>变量存储的是请求头中的Content-Length的值</td></tr><tr><td>$content_type</td><td>变量存储的是请求头中的Content-Type的值</td></tr><tr><td>$http_cookie</td><td>变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie 'cookieName=cookieValue’来添加cookie数据</td></tr><tr><td>$limit_rate</td><td>变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。</td></tr><tr><td>$remote_addr</td><td>变量中存储的是客户端的IP地址</td></tr><tr><td>$remote_port</td><td>变量中存储了客户端与服务端建立连接的端口号</td></tr><tr><td>$remote_user</td><td>变量中存储了客户端的用户名，需要有认证模块才能获取</td></tr><tr><td>$scheme</td><td>变量中存储了访问协议</td></tr><tr><td>$server_addr</td><td>变量中存储了服务端的地址</td></tr><tr><td>$server_name</td><td>变量中存储了客户端请求到达的服务器的名称</td></tr><tr><td>$server_port</td><td>变量中存储了客户端请求到达服务器的端口号</td></tr><tr><td>$server_protocol</td><td>变量中存储了客户端请求协议的版本，比如&quot;HTTP/1.1&quot;</td></tr><tr><td>$request_body_file</td><td>变量中存储了发给后端服务器的本地文件资源的名称</td></tr><tr><td>$request_method</td><td>变量中存储了客户端的请求方式，比如&quot;GET&quot;,&quot;POST&quot;等</td></tr><tr><td>$request_filename</td><td>变量中存储了当前请求的资源文件的路径名</td></tr><tr><td>$request_uri</td><td>变量中存储了当前请求的URI，并且携带请求参数，比如http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server?id=10&amp;name=zhangsan&quot;</td></tr></tbody></table><p>上述参数还可以在日志文件中使用，这个就要用到前面我们介绍的<code>log_format</code>指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format main &#x27;$remote_addr - $request - $status-$request_uri  $http_user_agent&#x27;;</span><br><span class="line"></span><br><span class="line">access_log logs/access.log main;</span><br></pre></td></tr></table></figure><h4 id="if指令">if指令</h4><p>该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。</p><table><thead><tr><th>语法</th><th>if  (condition){…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location</td></tr></tbody></table><p>condition为判定条件，可以支持以下写法：</p><ol><li>变量名。如果变量名对应的值为空字符串或&quot;0&quot;，if都判断为false,其他条件为true。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($param)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用&quot;=“和”!=&quot;比较变量和字符串是否相等，满足条件为true，不满足为false</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($request_method = POST)&#123;</span><br><span class="line">return 405;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：此处和Java不太一样的地方是字符串不需要添加引号,并且等号和不等号前后到需要加空格。</p><ol start="3"><li><p>使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。变量与正则表达式之间使用&quot;~“,”~*“,”!~“,”!~*&quot;来连接。</p><p>&quot;~&quot;代表匹配正则表达式过程中区分大小写，</p><p>&quot;~*&quot;代表匹配正则表达式过程中不区分大小写</p><p>&quot;!~“和”!~*&quot;刚好和上面取相反值，如果匹配上返回false,匹配不上返回true</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE)&#123;</span><br><span class="line">#$http_user_agent的值中是否包含MSIE字符串，如果包含返回true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：正则表达式字符串一般不需要加引号，但是如果字符串中包含&quot;}“或者是”;&quot;等字符时，就需要把引号加上。</p><ol start="4"><li>判断请求的文件是否存在使用&quot;-f&quot;和&quot;!-f&quot;,</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (-f $request_filename)&#123;</span><br><span class="line">#判断请求的文件是否存在</span><br><span class="line">&#125;</span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">#判断请求的文件是否不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>判断请求的目录是否存在使用&quot;-d&quot;和&quot;!-d&quot;</p></li><li><p>判断请求的目录或者文件是否存在使用&quot;-e&quot;和&quot;!-e&quot;</p></li><li><p>判断请求的文件是否可执行使用&quot;-x&quot;和&quot;!-x&quot;</p></li></ol><h4 id="break指令">break指令</h4><p>该指令用于中断当前相同作用域中的其他Nginx配置。与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效。并且break还有另外一个功能就是终止当前的匹配并把当前的URI在本location进行重定向访问处理。</p><table><thead><tr><th>语法</th><th>break;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /testbreak&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">set $username TOM;</span><br><span class="line">if ($args)&#123;</span><br><span class="line">Set $username JERRY;</span><br><span class="line">        break;</span><br><span class="line">set $username ROSE;</span><br><span class="line">&#125;</span><br><span class="line">add_header username $username;</span><br><span class="line">return 200 $username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="return指令">return指令</h4><p>该指令用于完成对请求的处理，直接向客户端返回。在return后的所有Nginx配置都是无效的。</p><table><thead><tr><th>语法</th><th>return code [text];<br/>return code URL;<br/>return URL;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>code:为返回给客户端的HTTP状态代理。可以返回的状态代码为0~999的任意HTTP状态代理</p><p>text:为返回给客户端的响应体内容，支持变量的使用</p><p>URL:为返回给客户端的URL地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location /testreturn &#123;</span><br><span class="line"></span><br><span class="line">return 200 success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /testreturn &#123;</span><br><span class="line"></span><br><span class="line">return https://www.baidu.com; // 302重定向到百度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /testreturn &#123;</span><br><span class="line">return 302 https://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /testreturn &#123;</span><br><span class="line">return 302 www.baidu.com;//不允许这么写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rewrite指令">rewrite指令</h4><p>该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。</p><table><thead><tr><th>语法</th><th>rewrite regex replacement [flag];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>regex:用来匹配URI的正则表达式</p><p>replacement:匹配成功后，用于替换URI中被截取内容的字符串。如果该字符串是以&quot;http://&quot;或者&quot;https://&quot;开头的，则不会继续向下对URI进行其他处理，而是直接返回重写后的URI给客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location rewrite &#123;</span><br><span class="line">rewrite ^/rewrite/url\w*$ https://www.baidu.com;</span><br><span class="line">rewrite ^/rewrite/(test)\w*$ /$1;</span><br><span class="line">rewrite ^/rewrite/(demo)\w*$ /$1;</span><br><span class="line">&#125;</span><br><span class="line">location /test&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 test_success;</span><br><span class="line">&#125;</span><br><span class="line">location /demo&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 demo_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag:用来设置rewrite对URI的处理行为，可选值有如下：</p><ul><li>last:终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行处理。该标志将重写后的URI重写在server块中执行，为重写后的URI提供了转入到其他location块的机会。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location rewrite &#123;</span><br><span class="line">rewrite ^/rewrite/(test)\w*$ /$1 last;</span><br><span class="line">rewrite ^/rewrite/(demo)\w*$ /$1 last;</span><br><span class="line">&#125;</span><br><span class="line">location /test&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 test_success;</span><br><span class="line">&#125;</span><br><span class="line">location /demo&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 demo_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>http://192.168.200.133:8081/rewrite/testabc</code>,能正确访问</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655953.png" alt="1589475653252"></p><ul><li>break：将此处重写的URI作为一个新的URI,在本块中继续进行处理。该标志将重写后的地址在当前的location块中执行，不会将新的URI转向其他的location块。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location rewrite &#123;</span><br><span class="line">    #/test   /usr/local/nginx/html/test/index.html</span><br><span class="line">rewrite ^/rewrite/(test)\w*$ /$1 break;</span><br><span class="line">rewrite ^/rewrite/(demo)\w*$ /$1 break;</span><br><span class="line">&#125;</span><br><span class="line">location /test&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 test_success;</span><br><span class="line">&#125;</span><br><span class="line">location /demo&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 demo_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>http://192.168.200.133:8081/rewrite/demoabc</code>,页面报404错误</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655954.png" alt="1589475732042"></p><ul><li>redirect：将重写后的URI返回给客户端，状态码为302，指明是临时重定向URI,主要用在replacement变量不是以&quot;http://&quot;或者&quot;https://&quot;开头的情况。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location rewrite &#123;</span><br><span class="line">rewrite ^/rewrite/(test)\w*$ /$1 redirect;</span><br><span class="line">rewrite ^/rewrite/(demo)\w*$ /$1 redirect;</span><br><span class="line">&#125;</span><br><span class="line">location /test&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 test_success;</span><br><span class="line">&#125;</span><br><span class="line">location /demo&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 demo_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://192.168.200.133:8081/rewrite/testabc</code>请求会被临时重定向，浏览器地址也会发生改变</p><ul><li>permanent：将重写后的URI返回给客户端，状态码为301，指明是永久重定向URI,主要用在replacement变量不是以&quot;http://&quot;或者&quot;https://&quot;开头的情况。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location rewrite &#123;</span><br><span class="line">rewrite ^/rewrite/(test)\w*$ /$1 permanent;</span><br><span class="line">rewrite ^/rewrite/(demo)\w*$ /$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">location /test&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 test_success;</span><br><span class="line">&#125;</span><br><span class="line">location /demo&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 demo_success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问<code>http://192.168.200.133:8081/rewrite/testabc</code>请求会被永久重定向，浏览器地址也会发生改变</p><h4 id="rewrite-log指令">rewrite_log指令</h4><p>该指令配置是否开启URL重写日志的输出功能。</p><table><thead><tr><th>语法</th><th>rewrite_log on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>rewrite_log off;</td></tr><tr><td>位置</td><td>http、server、location、if</td></tr></tbody></table><p>开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rewrite_log on;</span><br><span class="line">error_log  logs/error.log notice;</span><br></pre></td></tr></table></figure><h3 id="Rewrite的案例">Rewrite的案例</h3><h4 id="域名跳转">域名跳转</h4><p>》问题分析</p><p>先来看一个效果，如果我们想访问京东网站，大家都知道我们可以输入<code>www.jd.com</code>,但是同样的我们也可以输入<code>www.360buy.com</code>同样也都能访问到京东网站。<a href="http://xn--www-w48dncyev1bq7fw6d70b44jz5j4kd0qj8rhqpcd0trr5az4ama9098f7p5f.360buy.com">这个其实是因为京东刚开始的时候域名就是www.360buy.com</a>，<a href="http://xn--www-0h9dlb801dguajcf733ef2c1t1a6tmysbxwf4x7h3yen6qvr1bmz3g.jd.com">后面由于各种原因把自己的域名换成了www.jd.com</a>, 虽然说域名变量，但是对于以前只记住了www.360buy.com的用户来说，我们如何把这部分用户也迁移到我们新域名的访问上来，针对于这个问题，我们就可以使用Nginx中Rewrite的域名跳转来解决。</p><p>》环境准备</p><ul><li>准备三个域名：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   www.itcast.cn</span><br><span class="line">127.0.0.1   www.itheima.cn</span><br><span class="line">127.0.0.1   www.itheima.com</span><br></pre></td></tr></table></figure><ul><li><a href="http://xn--Nginxwww-jn5ou93qyk1cvdk24ac11d.itcast.cn">通过Nginx实现访问www.itcast.cn</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.itcast.cn;</span><br><span class="line">location /&#123;</span><br><span class="line">default_type text/html;</span><br><span class="line">return 200 &#x27;&lt;h1&gt;welcome to itcast&lt;/h1&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>》<a href="http://xn--Rewritewww-uk3sy9bh26b7i0mt9a.ithema.xn--comwww-k76j.itheima.xn--cnwww-8o6hh17mhfr897bgferwe.itcast.com">通过Rewrite完成将www.ithema.com和www.itheima.cn的请求跳转到www.itcast.com</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.itheima.com www.itheima.cn;</span><br><span class="line">rewrite ^/ http://www.itcast.cn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题描述:如何在域名跳转的过程中携带请求的URI？</p><p>修改配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.itheima.com www.itheima.cn;</span><br><span class="line">rewrite ^(.*) http://www.itcast.cn$1；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="域名镜像">域名镜像</h4><p>镜像网站指定是将一个完全相同的网站分别放置到几台服务器上，并分别使用独立的URL进行访问。其中一台服务器上的网站叫主站，其他的为镜像网站。镜像网站和主站没有太大的区别，可以把镜像网站理解为主站的一个备份节点。可以通过镜像网站提供网站在不同地区的响应速度。镜像网站可以平衡网站的流量负载、可以解决网络宽带限制、封锁等。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655955.png" alt="1589560433192"></p><p>而我们所说的域名镜像和网站镜像比较类似，上述案例中，将www.itheima.com和 <a href="http://www.itheima.xn--cnwww-8o6hq90zoxva74cr8e.itcast.cn">www.itheima.cn都能跳转到www.itcast.cn</a>，那么www.itcast.cn我们就可以把它起名叫主域名，其他两个就是我们所说的镜像域名，当然如果我们不想把整个网站做镜像，只想为其中某一个子目录下的资源做镜像，我们可以在location块中配置rewrite功能，比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     www.itheima.cn www.itheima.com;</span><br><span class="line">    location /user &#123;</span><br><span class="line">    rewrite ^/user(.*)$ http://www.itcast.cn$1;</span><br><span class="line">    &#125;</span><br><span class="line">    location /emp&#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;emp_success&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="独立域名">独立域名</h4><p>一个完整的项目包含多个模块，比如购物网站有商品搜索模块、商品详情模块和购物车模块等，那么我们如何为每一个模块设置独立的域名。</p><p>需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://search.itcast.com:81  访问商品搜索模块</span><br><span class="line">http://item.itcast.com:82  访问商品详情模块</span><br><span class="line">http://cart.itcast.com:83  访问商品购物车模块</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 81;</span><br><span class="line">server_name search.itcast.com;</span><br><span class="line">rewrite ^(.*) http://www.itcast.cn/search$1;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 82;</span><br><span class="line">server_name item.itcast.com;</span><br><span class="line">rewrite ^(.*) http://www.itcast.cn/item$1;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 83;</span><br><span class="line">server_name cart.itcast.com;</span><br><span class="line">rewrite ^(.*) http://www.itcast.cn/cart$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="目录自动添加">目录自动添加&quot;/&quot;</h4><p>问题描述</p><p>通过一个例子来演示下问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen8082;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /heima &#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>http://192.168.200.133:8082/heima</code>和通过<code>http://192.168.200.133:8082/heima/</code>访问的区别？</p><p>如果不加斜杠，Nginx服务器内部会自动做一个301的重定向，重定向的地址会有一个指令叫server_name_in_redirect on|off;来决定重定向的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果该指令为on</span><br><span class="line">重定向的地址为:  http://server_name:8082/目录名/;</span><br><span class="line">http://localhost:8082/heima/</span><br><span class="line">如果该指令为off</span><br><span class="line">重定向的地址为:  http://原URL中的域名:8082/目录名/;</span><br><span class="line">http://192.168.200.133:8082/heima/</span><br></pre></td></tr></table></figure><p>所以就拿刚才的地址来说，<a href="http://192.168.200.133:8082/heima%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8A%A0%E6%96%9C%E6%9D%A0%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8C%89%E7%85%A7%E4%B8%8A%E8%BF%B0%E8%A7%84%E5%88%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E4%BB%A4server_name_in_redirect%E4%B8%BAon%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BA">http://192.168.200.133:8082/heima如果不加斜杠，那么按照上述规则，如果指令server_name_in_redirect为on，则301重定向地址变为</a> <a href="http://localhost:8082/heima/,%E5%A6%82%E6%9E%9C%E4%B8%BAoff%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BAhttp://192.168.200.133:8082/heima/%E3%80%82%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%89%8D%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%B0%B1%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%82">http://localhost:8082/heima/,如果为off，则301重定向地址变为http://192.168.200.133:8082/heima/。后面这个是正常的，前面地址就有问题。</a></p><p>注意server_name_in_redirect指令在Nginx的0.8.48版本之前默认都是on，之后改成了off,所以现在我们这个版本不需要考虑这个问题，但是如果是0.8.48以前的版本并且server_name_in_redirect设置为on，我们如何通过rewrite来解决这个问题？</p><p>解决方案</p><p>我们可以使用rewrite功能为末尾没有斜杠的URL自动添加一个斜杠</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen80;</span><br><span class="line">server_name localhost;</span><br><span class="line">server_name_in_redirect on;</span><br><span class="line">location /heima &#123;</span><br><span class="line">if (-d $request_filename)&#123;</span><br><span class="line">rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并目录">合并目录</h4><p>搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提高目的网站在有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含URL的目录层级一般不要超过三层，否则的话不利于搜索引擎的搜索也给客户端的输入带来了负担，但是将所有的文件放在一个目录下又会导致文件资源管理混乱并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用rewrite如何解决上述问题?</p><p>举例，网站中有一个资源文件的访问路径时 /server/11/22/33/44/20.html,也就是说20.html存在于第5级目录下，如果想要访问该资源文件，客户端的URL地址就要写成 <code>http://192.168.200.133/server/11/22/33/44/20.html</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /server&#123;</span><br><span class="line">root html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个是非常不利于SEO搜索引擎优化的，同时客户端也不好记.使用rewrite我们可以进行如下配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /server&#123;</span><br><span class="line">rewrite ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /server/$1/$2/$3/$4/$5.html last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的花，客户端只需要输入http://www.web.name/server-11-22-33-44-20.html就可以访问到20.html页面了。这里也充分利用了rewrite指令支持正则表达式的特性。</p><h4 id="防盗链">防盗链</h4><p>防盗链之前我们已经介绍过了相关的知识，在rewrite中的防盗链和之前将的原理其实都是一样的，只不过通过rewrite可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用rewrite将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。下面我们就通过根据文件类型实现防盗链的一个配置实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">    root html;</span><br><span class="line">    valid_referers none blocked www.baidu.com;</span><br><span class="line">    if ($invalid_referer)&#123;</span><br><span class="line">        #return 403;</span><br><span class="line">        rewrite ^/    /images/forbidden.png break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Nginx反向代理">Nginx反向代理</h2><h3 id="Nginx反向代理概述">Nginx反向代理概述</h3><p>关于正向代理和反向代理，我们在前面的章节已经通过一张图给大家详细的介绍过了，简而言之就是正向代理代理的对象是客户端，反向代理代理的是服务端，这是两者之间最大的区别。</p><p>Nginx即可以实现正向代理，也可以实现反向代理。</p><p>我们先来通过一个小案例演示下Nginx正向代理的简单应用。</p><p>先提需求：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655956.png" alt=""></p><p>(1)服务端的设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  log_format main &#x27;client send request=&gt;clientIp=$remote_addr serverIp=&gt;$host&#x27;;</span><br><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_namelocalhost;</span><br><span class="line">access_log logs/access.log main;</span><br><span class="line">location &#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)使用客户端访问服务端，打开日志查看结果</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655957.png" alt="1589729000713"></p><p>(3)代理服务器设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">        listen  82;</span><br><span class="line">        resolver 8.8.8.8;</span><br><span class="line">        location /&#123;</span><br><span class="line">                proxy_pass http://$host$request_uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(4)查看代理服务器的IP(192.168.200.146)和Nginx配置监听的端口(82)</p><p>(5)在客户端配置代理服务器</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655958.png" alt=""></p><p>(6)设置完成后，再次通过浏览器访问服务端</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655959.png" alt="1589729479920"></p><p>通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是如何使用了代理，那么服务端能看到的只是代理发送过去的请求，这样的化，就使用Nginx实现了正向代理的设置。</p><p>但是Nginx正向代理，在实际的应用中不是特别多，所以我们简单了解下，接下来我们继续学习Nginx的反向代理，这是Nginx比较重要的一个功能。</p><h3 id="Nginx反向代理的配置语法">Nginx反向代理的配置语法</h3><p>Nginx反向代理模块的指令是由<code>ngx_http_proxy_module</code>模块进行解析，该模块在安装Nginx的时候已经自己加装到Nginx中了，接下来我们把反向代理中的常用指令一一介绍下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass</span><br><span class="line">proxy_set_header</span><br><span class="line">proxy_redirect</span><br></pre></td></tr></table></figure><h4 id="proxy-pass">proxy_pass</h4><p>该指令用来设置被代理服务器地址，可以是主机名称、IP地址加端口号形式。</p><table><thead><tr><th>语法</th><th>proxy_pass URL;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>location</td></tr></tbody></table><p>URL:为要设置的被代理服务器地址，包含传输协议(<code>http</code>,<code>https://</code>)、主机名称或IP地址加端口号、URI等要素。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http://www.baidu.com;</span><br><span class="line">location /server&#123;&#125;</span><br><span class="line">proxy_pass http://192.168.200.146;</span><br><span class="line">    http://192.168.200.146/server/index.html</span><br><span class="line">proxy_pass http://192.168.200.146/;</span><br><span class="line">    http://192.168.200.146/index.html</span><br></pre></td></tr></table></figure><p>大家在编写proxy_pass的时候，后面的值要不要加&quot;/&quot;?</p><p>接下来通过例子来说明刚才我们提到的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">#proxy_pass http://192.168.200.146;</span><br><span class="line">proxy_pass http://192.168.200.146/;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">当客户端访问 http://localhost/index.html,效果是一样的</span><br><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /server&#123;</span><br><span class="line">#proxy_pass http://192.168.200.146;</span><br><span class="line">proxy_pass http://192.168.200.146/;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">当客户端访问 http://localhost/server/index.html</span><br><span class="line">这个时候，第一个proxy_pass就变成了http://localhost/server/index.html</span><br><span class="line">第二个proxy_pass就变成了http://localhost/index.html效果就不一样了。</span><br></pre></td></tr></table></figure><h4 id="proxy-set-header">proxy_set_header</h4><p>该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器</p><table><thead><tr><th>语法</th><th>proxy_set_header field value;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_set_header Host $proxy_host;<br/>proxy_set_header Connection close;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。</p><p>被代理服务器： [192.168.200.146]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  8080;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        default_type text/plain;</span><br><span class="line">        return 200 $http_username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理服务器: [192.168.200.133]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  8080;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location /server &#123;</span><br><span class="line">                proxy_pass http://192.168.200.146:8080/;</span><br><span class="line">                proxy_set_header username TOM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问测试</p><h4 id="proxy-redirect">proxy_redirect</h4><p>该指令是用来重置头信息中的&quot;Location&quot;和&quot;Refresh&quot;的值。</p><table><thead><tr><th>语法</th><th>proxy_redirect redirect replacement;<br/>proxy_redirect default;<br/>proxy_redirect off;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_redirect default;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》为什么要用该指令?</p><p>服务端[192.168.200.146]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  8081;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    if (!-f $request_filename)&#123;</span><br><span class="line">    return 302 http://192.168.200.146;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代理服务端[192.168.200.133]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen  8081;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://192.168.200.146:8081/;</span><br><span class="line">proxy_redirect http://192.168.200.146 http://192.168.200.133;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>》该指令的几组选项</p><p>proxy_redirect redirect replacement;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redirect:目标,Location的值</span><br><span class="line">replacement:要替换的值</span><br></pre></td></tr></table></figure><p>proxy_redirect default;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default;</span><br><span class="line">将location块的uri变量作为replacement,</span><br><span class="line">将proxy_pass变量作为redirect进行替换</span><br></pre></td></tr></table></figure><p>proxy_redirect off;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭proxy_redirect的功能</span><br></pre></td></tr></table></figure><h3 id="Nginx反向代理实战">Nginx反向代理实战</h3><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655960.png" alt="1581883378672"></p><p>服务器1,2,3存在两种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种情况: 三台服务器的内容不一样。</span><br><span class="line">第二种情况: 三台服务器的内容是一样。</span><br></pre></td></tr></table></figure><ol><li>如果服务器1、服务器2和服务器3的内容不一样，那我们可以根据用户请求来分发到不同的服务器。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">代理服务器</span><br><span class="line">server &#123;</span><br><span class="line">        listen          8082;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location /server1 &#123;</span><br><span class="line">                proxy_pass http://192.168.200.146:9001/;</span><br><span class="line">        &#125;</span><br><span class="line">        location /server2 &#123;</span><br><span class="line">                proxy_pass http://192.168.200.146:9002/;</span><br><span class="line">        &#125;</span><br><span class="line">        location /server3 &#123;</span><br><span class="line">                proxy_pass http://192.168.200.146:9003/;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">服务端</span><br><span class="line">server1</span><br><span class="line">server &#123;</span><br><span class="line">        listen          9001;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">server2</span><br><span class="line">server &#123;</span><br><span class="line">        listen          9002;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">server3</span><br><span class="line">server &#123;</span><br><span class="line">        listen          9003;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        return 200 &#x27;&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果服务器1、服务器2和服务器3的内容是一样的，该如何处理?</li></ol><h3 id="Nginx的安全控制">Nginx的安全控制</h3><p>关于web服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx反向代理是如何来提升web服务器的安全呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安全隔离</span><br></pre></td></tr></table></figure><p>什么是安全隔离?</p><p>通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655961.png" alt="1589908851340"></p><h4 id="如何使用SSL对流量进行加密">如何使用SSL对流量进行加密</h4><p>翻译成大家能熟悉的说法就是将我们常用的http请求转变成https请求，那么这两个之间的区别简单的来说两个都是HTTP协议，只不过https是身披SSL外壳的http.</p><p>HTTPS是一种通过计算机网络进行安全通信的传输协议。它经由HTTP进行通信，利用SSL/TLS建立全通信，加密数据包，确保数据的安全性。</p><p>SSL(Secure Sockets Layer)安全套接层</p><p>TLS(Transport Layer Security)传输层安全</p><p>上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS和SSL在传输层和应用层对网络连接进行加密。</p><p>总结来说为什么要使用https:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http协议是明文传输数据，存在安全问题，而https是加密传输，相当于http+ssl，并且可以防止流量劫持。</span><br></pre></td></tr></table></figure><p>Nginx要想使用SSL，需要满足一个条件即需要添加一个模块<code>--with-http_ssl_module</code>,而该模块在编译的过程中又需要OpenSSL的支持，这个我们之前已经准备好了。</p><h5 id="nginx添加SSL的支持">nginx添加SSL的支持</h5><p>（1）完成 <code>--with-http_ssl_module</code>模块的增量添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">》将原有/usr/local/nginx/sbin/nginx进行备份</span><br><span class="line">》拷贝nginx之前的配置信息</span><br><span class="line">》在nginx的安装源码进行配置指定对应模块  ./configure --with-http_ssl_module</span><br><span class="line">》通过make模板进行编译</span><br><span class="line">》将objs下面的nginx移动到/usr/local/nginx/sbin下</span><br><span class="line">》在源码目录下执行  make upgrade进行升级，这个可以实现不停机添加新模块的功能</span><br></pre></td></tr></table></figure><h5 id="Nginx的SSL相关指令">Nginx的SSL相关指令</h5><p>因为刚才我们介绍过该模块的指令都是通过ngx_http_ssl_module模块来解析的。</p><p>》ssl:该指令用来在指定的服务器开启HTTPS,可以使用 listen 443 ssl,后面这种方式更通用些。</p><table><thead><tr><th>语法</th><th>ssl on | off;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl off;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 443 ssl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>》ssl_certificate:为当前这个虚拟主机指定一个带有PEM格式证书的证书。</p><table><thead><tr><th>语法</th><th>ssl_certificate file;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>》ssl_certificate_key:该指令用来指定PEM secret key文件的路径</p><table><thead><tr><th>语法</th><th>ssl_ceritificate_key file;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>》ssl_session_cache:该指令用来配置用于SSL会话的缓存</p><table><thead><tr><th>语法</th><th>ssl_sesion_cache off|none|[builtin[:size]] [shared:name:size]</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_session_cache none;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>off:禁用会话缓存，客户端不得重复使用会话</p><p>none:禁止使用会话缓存，客户端可以重复使用，但是并没有在缓存中存储会话参数</p><p>builtin:内置OpenSSL缓存，仅在一个工作进程中使用。</p><p>shared:所有工作进程之间共享缓存，缓存的相关信息用name和size来指定</p><p>》ssl_session_timeout：开启SSL会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间。</p><table><thead><tr><th>语法</th><th>ssl_session_timeout time;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_session_timeout 5m;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>》ssl_ciphers:指出允许的密码，密码指定为OpenSSL支持的格式</p><table><thead><tr><th>语法</th><th>ssl_ciphers ciphers;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_ciphers HIGH:!aNULL:!MD5;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>可以使用<code>openssl ciphers</code>查看openssl支持的格式。</p><p>》ssl_prefer_server_ciphers：该指令指定是否服务器密码优先客户端密码</p><table><thead><tr><th>语法</th><th>ssl_perfer_server_ciphers on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_perfer_server_ciphers off;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><h5 id="生成证书">生成证书</h5><p>方式一：使用阿里云/腾讯云等第三方服务进行购买。</p><p>方式二:使用openssl生成证书</p><p>先要确认当前系统是否有安装openssl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure><p>安装下面的命令进行生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /root/cert</span><br><span class="line"><span class="built_in">cd</span> /root/cert</span><br><span class="line">openssl genrsa -des3 -out server.key 1024</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"><span class="built_in">cp</span> server.key server.key.org</span><br><span class="line">openssl rsa -<span class="keyword">in</span> server.key.org -out server.key</span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure><h5 id="开启SSL实例">开启SSL实例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate      server.cert;</span><br><span class="line">    ssl_certificate_key  server.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）验证</p><h3 id="反向代理系统调优">反向代理系统调优</h3><p>反向代理值Buffer和Cache</p><p>Buffer翻译过来是&quot;缓冲&quot;，Cache翻译过来是&quot;缓存&quot;。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211655962.png" alt="1581879638569"></p><p>总结下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">相同点:</span><br><span class="line">两种方式都是用来提供IO吞吐效率，都是用来提升Nginx代理的性能。</span><br><span class="line">不同点:</span><br><span class="line">缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除。</span><br><span class="line">缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除.</span><br></pre></td></tr></table></figure><p>（1）Proxy Buffer相关指令</p><p>》proxy_buffering :该指令用来开启或者关闭代理服务器的缓冲区；</p><table><thead><tr><th>语法</th><th>proxy_buffering on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_buffering on;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》proxy_buffers:该指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小。</p><table><thead><tr><th>语法</th><th>proxy_buffers number size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_buffers 8 4k | 8K;(与系统平台有关)</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>number:缓冲区的个数</p><p>size:每个缓冲区的大小，缓冲区的总大小就是number*size</p><p>》proxy_buffer_size:该指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与proxy_buffers中的size一致即可，当然也可以更小。</p><table><thead><tr><th>语法</th><th>proxy_buffer_size size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_buffer_size 4k | 8k;(与系统平台有关)</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》proxy_busy_buffers_size：该指令用来限制同时处于BUSY状态的缓冲总大小。</p><table><thead><tr><th>语法</th><th>proxy_busy_buffers_size size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_busy_buffers_size 8k|16K;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》proxy_temp_path:当缓冲区存满后，仍未被Nginx服务器完全接受，响应数据就会被临时存放在磁盘文件上，该指令设置文件路径</p><table><thead><tr><th>语法</th><th>proxy_temp_path  path;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_temp_path proxy_temp;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>注意path最多设置三层。</p><p>》proxy_temp_file_write_size：该指令用来设置磁盘上缓冲文件的大小。</p><table><thead><tr><th>语法</th><th>proxy_temp_file_write_size size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_temp_file_write_size 8K|16K;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>通用网站的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_buffering on;</span><br><span class="line">proxy_buffer_size 4 32k;</span><br><span class="line">proxy_busy_buffers_size 64k;</span><br><span class="line">proxy_temp_file_write_size 64k;</span><br></pre></td></tr></table></figure><p>根据项目的具体内容进行相应的调节。</p>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习（四）--- 负载均衡</title>
      <link href="/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E5%9B%9B/"/>
      <url>/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1>Nginx负载均衡</h1><h2 id="负载均衡概述">负载均衡概述</h2><p>早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657852.png" alt="1591631182469"></p><h2 id="负载均衡的原理及处理流程">负载均衡的原理及处理流程</h2><p>系统的扩展可以分为纵向扩展和横向扩展。</p><p>纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力</p><p>横向扩展是通过添加机器来满足大型网站服务的处理能力。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657853.png" alt="1584602513812"></p><p>这里面涉及到两个重要的角色分别是&quot;应用集群&quot;和&quot;负载均衡器&quot;。</p><p>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据。</p><p>负载均衡器:将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理。</p><h3 id="负载均衡的作用">负载均衡的作用</h3><p>1、解决服务器的高并发压力，提高应用程序的处理性能。</p><p>2、提供故障转移，实现高可用。</p><p>3、通过添加或减少服务器数量，增强网站的可扩展性。</p><p>4、在负载均衡器上进行过滤，可以提高系统的安全性。</p><h2 id="负载均衡常用的处理方式">负载均衡常用的处理方式</h2><h4 id="方式一-用户手动选择">方式一:用户手动选择</h4><p>这种方式比较原始，只要实现的方式就是在网站主页上面提供不同线路、不同服务器链接方式，让用户来选择自己访问的具体服务器，来实现负载均衡。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657854.png" alt="1584602887881"></p><h4 id="方式二-DNS轮询方式">方式二:DNS轮询方式</h4><p>DNS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换。</span><br></pre></td></tr></table></figure><p>大多域名注册商都支持对同一个主机名添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就能完成简单的负载均衡。DNS轮询的成本非常低，在一些不重要的服务器，被经常使用。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657855.png" alt="1591010973996"></p><p>如下是我们为某一个域名添加的IP地址，用2台服务器来做负载均衡。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657856.png" alt="1590064506355"></p><p>验证:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.nginx521.cn</span><br></pre></td></tr></table></figure><p>清空本地的dns缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/flushdns</span><br></pre></td></tr></table></figure><p>我们发现使用DNS来实现轮询，不需要投入过多的成本，虽然DNS轮询成本低廉，但是DNS负载均衡存在明显的缺点。</p><p>1.可靠性低</p><p>假设一个域名DNS轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，即使你将该服务器的IP从DNS中去掉，但是由于各大宽带接入商将众多的DNS存放在缓存中，以节省访问时间，导致DNS不会实时更新。所以DNS轮流上一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。</p><p>2.负载均衡不均衡</p><p>DNS负载均衡采用的是简单的轮询负载算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能好的服务器多分配请求，另外本地计算机也会缓存已经解析的域名到IP地址的映射，这也会导致使用该DNS服务器的用户在一定时间内访问的是同一台Web服务器，从而引发Web服务器减的负载不均衡。</p><p>负载不均衡则会导致某几台服务器负荷很低，而另外几台服务器负荷确很高，处理请求的速度慢，配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。</p><h4 id="方式三-四-七层负载均衡">方式三:四/七层负载均衡</h4><p>介绍四/七层负载均衡之前，我们先了解一个概念，OSI(open system interconnection),叫开放式系统互联模型，这个是由国际标准化组织ISO指定的一个不基于具体机型、操作系统或公司的网络体系结构。该模型将网络通信的工作分为七层。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657857.png" alt="1584693830966"></p><p>应用层：为应用程序提供网络服务。</p><p>表示层：对数据进行格式化、编码、加密、压缩等操作。</p><p>会话层：建立、维护、管理会话连接。</p><p>传输层：建立、维护、管理端到端的连接，常见的有TCP/UDP。</p><p>网络层：IP寻址和路由选择</p><p>数据链路层：控制网络层与物理层之间的通信。</p><p>物理层：比特流传输。</p><p>所谓四层负载均衡指的是OSI七层模型中的传输层，主要是基于IP+PORT的负载均衡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现四层负载均衡的方式：</span><br><span class="line">硬件：F5 BIG-IP、Radware等</span><br><span class="line">软件：LVS、Nginx、Hayproxy等</span><br></pre></td></tr></table></figure><p>所谓的七层负载均衡指的是在应用层，主要是基于虚拟的URL或主机IP的负载均衡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现七层负载均衡的方式：</span><br><span class="line">软件：Nginx、Hayproxy等</span><br></pre></td></tr></table></figure><p>四层和七层负载均衡的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在最顶端进行分发，所以四层负载均衡的效率比七层负载均衡的要高。</span><br><span class="line">四层负载均衡不识别域名，而七层负载均衡识别域名。</span><br></pre></td></tr></table></figure><p>处理四层和七层负载以为其实还有二层、三层负载均衡，二层是在数据链路层基于mac地址来实现负载均衡，三层是在网络层一般采用虚拟IP地址的方式实现负载均衡。</p><p>实际环境采用的模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">四层负载(LVS)+七层负载(Nginx)</span><br></pre></td></tr></table></figure><h3 id="Nginx七层负载均衡">Nginx七层负载均衡</h3><p>Nginx要实现七层负载均衡需要用到proxy_pass代理模块配置。Nginx默认安装支持这个模块，我们不需要再做任何处理。Nginx的负载均衡是在Nginx的反向代理基础上把用户的请求根据指定的算法分发到一组【upstream虚拟服务池】。</p><h4 id="Nginx七层负载均衡的指令">Nginx七层负载均衡的指令</h4><h5 id="upstream指令">upstream指令</h5><p>该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。服务器可以指定不同的权重，默认为1。</p><table><thead><tr><th>语法</th><th>upstream name {…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http</td></tr></tbody></table><h5 id="server指令">server指令</h5><p>该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者unix socket</p><table><thead><tr><th>语法</th><th>server name [paramerters]</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>upstream</td></tr></tbody></table><h4 id="Nginx七层负载均衡的实现流程">Nginx七层负载均衡的实现流程</h4><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657858.png" alt="1590248160635"></p><p>服务端设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen   9001;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    location /&#123;</span><br><span class="line">    return 200 &#x27;&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen   9002;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    location /&#123;</span><br><span class="line">    return 200 &#x27;&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen   9003;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type text/html;</span><br><span class="line">    location /&#123;</span><br><span class="line">    return 200 &#x27;&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负载均衡器设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9091;</span><br><span class="line">server 192.168.200.146:9092;</span><br><span class="line">server 192.168.200.146:9093;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="负载均衡状态">负载均衡状态</h4><p>代理服务器在负责均衡调度中的状态有以下几个：</p><table><thead><tr><th>状态</th><th>概述</th></tr></thead><tbody><tr><td>down</td><td>当前的server暂时不参与负载均衡</td></tr><tr><td>backup</td><td>预留的备份服务器</td></tr><tr><td>max_fails</td><td>允许请求失败的次数</td></tr><tr><td>fail_timeout</td><td>经过max_fails失败后, 服务暂停时间</td></tr><tr><td>max_conns</td><td>限制最大的接收连接数</td></tr></tbody></table><h5 id="down">down</h5><p>down:将该服务器标记为永久不可用，那么该代理服务器将不参与负载均衡。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9001 down;</span><br><span class="line">server 192.168.200.146:9002</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该状态一般会对需要停机维护的服务器进行设置。</p><h5 id="backup">backup</h5><p>backup:将该服务器标记为备份服务器，当主服务器不可用时，将用来传递请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9001 down;</span><br><span class="line">server 192.168.200.146:9002 backup;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时需要将9094端口的访问禁止掉来模拟下唯一能对外提供访问的服务宕机以后，backup的备份服务器就要开始对外提供服务，此时为了测试验证，我们需要使用防火墙来进行拦截。</p><p>介绍一个工具<code>firewall-cmd</code>,该工具是Linux提供的专门用来操作firewall的。</p><p>查询防火墙中指定的端口是否开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=9001/tcp</span><br></pre></td></tr></table></figure><p>如何开放一个指定的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=9002/tcp</span><br></pre></td></tr></table></figure><p>批量添加开发端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=9001-9003/tcp</span><br></pre></td></tr></table></figure><p>如何移除一个指定的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-port=9003/tcp</span><br></pre></td></tr></table></figure><p>重新加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>其中</p><p>​ --permanent表示设置为持久</p><p>​ --add-port表示添加指定端口</p><p>​ --remove-port表示移除指定端口</p><h5 id="max-conns">max_conns</h5><p>max_conns=number:用来设置代理服务器同时活动链接的最大数量，默认为0，表示不限制，使用该配置可以根据后端服务器处理请求的并发量来进行设置，防止后端服务器被压垮。</p><h5 id="max-fails和fail-timeout">max_fails和fail_timeout</h5><p>max_fails=number:设置允许请求代理服务器失败的次数，默认为1。</p><p>fail_timeout=time:设置经过max_fails失败后，服务暂停的时间，默认是10秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.133:9001 down;</span><br><span class="line">server 192.168.200.133:9002 backup;</span><br><span class="line">server 192.168.200.133:9003 max_fails=3 fail_timeout=15;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="负载均衡策略">负载均衡策略</h4><p>介绍完Nginx负载均衡的相关指令后，我们已经能实现将用户的请求分发到不同的服务器上，那么除了采用默认的分配方式以外，我们还能采用什么样的负载算法?</p><p>Nginx的upstream支持如下六种方式的分配算法，分别是:</p><table><thead><tr><th>算法名称</th><th>说明</th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td></tr><tr><td>weight</td><td>权重方式</td></tr><tr><td>ip_hash</td><td>依据ip分配方式</td></tr><tr><td>least_conn</td><td>依据最少连接方式</td></tr><tr><td>url_hash</td><td>依据URL分配方式</td></tr><tr><td>fair</td><td>依据响应时间方式</td></tr></tbody></table><h5 id="轮询">轮询</h5><p>是upstream模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9001 weight=1;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="weight加权-加权轮询">weight加权[加权轮询]</h5><p>weight=number:用来设置服务器的权重，默认为1，权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9001 weight=10;</span><br><span class="line">server 192.168.200.146:9002 weight=5;</span><br><span class="line">server 192.168.200.146:9003 weight=3;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ip-hash">ip_hash</h5><p>当对后端的多台动态应用服务器做负载均衡时，ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上。这样，当来自某一个IP的用户在后端Web服务器A上登录后，在访问该站点的其他URL，能保证其访问的还是后端web服务器A。</p><table><thead><tr><th>语法</th><th>ip_hash;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>upstream</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要额外多说一点的是使用ip_hash指令无法保证后端服务器的负载均衡，可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少，而且设置后端服务器权重等方法将不起作用。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657859.png" alt="1591706748677"></p><h5 id="least-conn">least_conn</h5><p>最少连接，把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">least_conn;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657860.png" alt="1591809623736"></p><h5 id="url-hash">url_hash</h5><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">hash &amp;request_uri;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问如下地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.133:8083/a</span><br><span class="line">http://192.168.200.133:8083/b</span><br><span class="line">http://192.168.200.133:8083/c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657861.png" alt="1591812222306"></p><h5 id="fair">fair</h5><p>fair采用的不是内建负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。那么如何使用第三方模块的fair负载均衡策略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">fair;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如何直接使用会报错，因为fair属于第三方模块实现的负载均衡。需要添加<code>nginx-upstream-fair</code>,如何添加对应的模块:</p><ol><li>下载nginx-upstream-fair模块</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下载地址为:</span><br><span class="line">https://github.com/gnosek/nginx-upstream-fair</span><br></pre></td></tr></table></figure><ol start="2"><li>将下载的文件上传到服务器并进行解压缩</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip nginx-upstream-fair-master.zip</span><br></pre></td></tr></table></figure><ol start="3"><li>重命名资源</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv nginx-upstream-fair-master fair</span><br></pre></td></tr></table></figure><ol start="4"><li>使用./configure命令将资源添加到Nginx模块中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/root/fair</span><br></pre></td></tr></table></figure><ol start="5"><li>编译</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>编译可能会出现如下错误，ngx_http_upstream_srv_conf_t结构中缺少default_port</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657862.png" alt="1584941470457"></p><p>解决方案:</p><p>在Nginx的源码中 src/http/ngx_http_upstream.h,找到<code>ngx_http_upstream_srv_conf_s</code>，在模块中添加添加default_port属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in_port_t   default_port</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657863.png" alt="1584943399597"></p><p>然后再进行make.</p><ol start="6"><li>更新Nginx</li></ol><p>​ 6.1 将sbin目录下的nginx进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold</span><br></pre></td></tr></table></figure><p>​6.2 将安装目录下的objs中的nginx拷贝到sbin目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd objs</span><br><span class="line">cp nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>​ 6.3 更新Nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../</span><br><span class="line">make upgrade</span><br></pre></td></tr></table></figure><ol start="7"><li>编译测试使用Nginx</li></ol><p>上面介绍了Nginx常用的负载均衡的策略，有人说是5种，是把轮询和加权轮询归为一种，也有人说是6种。那么在咱们以后的开发中到底使用哪种，这个需要根据实际项目的应用场景来决定的。</p><h4 id="负载均衡案例">负载均衡案例</h4><h5 id="案例一：对所有请求实现一般轮询规则的负载均衡">案例一：对所有请求实现一般轮询规则的负载均衡</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="案例二：对所有请求实现加权轮询规则的负载均衡">案例二：对所有请求实现加权轮询规则的负载均衡</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9001 weight=7;</span><br><span class="line">server 192.168.200.146:9002 weight=5;</span><br><span class="line">server 192.168.200.146:9003 weight=3;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8083;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="案例三：对特定资源实现负载均衡">案例三：对特定资源实现负载均衡</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">upstream videobackend&#123;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">&#125;</span><br><span class="line">upstream filebackend&#123;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">server 192.168.200.146:9004;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 8084;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /video/ &#123;</span><br><span class="line">proxy_pass http://videobackend;</span><br><span class="line">&#125;</span><br><span class="line">location /file/ &#123;</span><br><span class="line">proxy_pass http://filebackend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="案例四：对不同域名实现负载均衡">案例四：对不同域名实现负载均衡</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">upstream itcastbackend&#123;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">&#125;</span><br><span class="line">upstream itheimabackend&#123;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">server 192.168.200.146:9004;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen8085;</span><br><span class="line">server_name www.itcast.cn;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://itcastbackend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen8086;</span><br><span class="line">server_name www.itheima.cn;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://itheimabackend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="案例五：实现带有URL重写的负载均衡">案例五：实现带有URL重写的负载均衡</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:9001;</span><br><span class="line">server 192.168.200.146:9002;</span><br><span class="line">server 192.168.200.146:9003;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /file/ &#123;</span><br><span class="line">rewrite ^(/file/.*) /server/$1 last;</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx四层负载均衡">Nginx四层负载均衡</h3><p>Nginx在1.9之后，增加了一个stream模块，用来实现四层协议的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p><p>四层协议负载均衡的实现，一般都会用到LVS、HAProxy、F5等，要么很贵要么配置很麻烦，而Nginx的配置相对来说更简单，更能快速完成工作。</p><h4 id="添加stream模块的支持">添加stream模块的支持</h4><p>Nginx默认是没有编译这个模块的，需要使用到stream模块，那么需要在编译的时候加上<code>--with-stream</code>。</p><p>完成添加<code>--with-stream</code>的实现步骤:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">》将原有/usr/local/nginx/sbin/nginx进行备份</span><br><span class="line">》拷贝nginx之前的配置信息</span><br><span class="line">》在nginx的安装源码进行配置指定对应模块  ./configure --with-stream</span><br><span class="line">》通过make模板进行编译</span><br><span class="line">》将objs下面的nginx移动到/usr/local/nginx/sbin下</span><br><span class="line">》在源码目录下执行  make upgrade进行升级，这个可以实现不停机添加新模块的功能</span><br></pre></td></tr></table></figure><h4 id="Nginx四层负载均衡的指令">Nginx四层负载均衡的指令</h4><h5 id="stream指令">stream指令</h5><p>该指令提供在其中指定流服务器指令的配置文件上下文。和http指令同级。</p><table><thead><tr><th>语法</th><th>stream { … }</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>main</td></tr></tbody></table><h5 id="upstream指令-2">upstream指令</h5><p>该指令和http的upstream指令是类似的。</p><h4 id="四层负载均衡的案例">四层负载均衡的案例</h4><h5 id="需求分析-2">需求分析</h5><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657864.png" alt="1591897178807"></p><p>实现步骤</p><p>(1)准备Redis服务器,在一条服务器上准备三个Redis，端口分别是6379,6378</p><p>1.上传redis的安装包，<code>redis-4.0.14.tar.gz</code></p><p>2.将安装包进行解压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf redis-4.0.14.tar.gz</span><br></pre></td></tr></table></figure><p>3.进入redis的安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-4.0.14</span><br></pre></td></tr></table></figure><p>4.使用make和install进行编译和安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/local/redis/redis01 install</span><br></pre></td></tr></table></figure><p>5.拷贝redis配置文件<code>redis.conf</code>到/usr/local/redis/redis01/bin目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf/usr/local/redis/redis01/bin</span><br></pre></td></tr></table></figure><p>6.修改redis.conf配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port  6379      #redis的端口</span><br><span class="line">daemonize yes   #后台启动redis</span><br></pre></td></tr></table></figure><p>7.将redis01复制一份为redis02</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis</span><br><span class="line">cp -r redis01 redis02</span><br></pre></td></tr></table></figure><p>8.将redis02文件文件夹中的redis.conf进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port  6378      #redis的端口</span><br><span class="line">daemonize yes   #后台启动redis</span><br></pre></td></tr></table></figure><p>9.分别启动，即可获取两个Redis.并查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>使用Nginx将请求分发到不同的Redis服务器上。</p><p>(2)准备Tomcat服务器.</p><p>1.上传tomcat的安装包，<code>apache-tomcat-8.5.56.tar.gz</code></p><p>2.将安装包进行解压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf apache-tomcat-8.5.56.tar.gz</span><br></pre></td></tr></table></figure><p>3.进入tomcat的bin目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd apache-tomcat-8.5.56/bin</span><br><span class="line">./startup</span><br></pre></td></tr></table></figure><p>nginx.conf配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">        upstream redisbackend &#123;</span><br><span class="line">                server 192.168.200.146:6379;</span><br><span class="line">                server 192.168.200.146:6378;</span><br><span class="line">        &#125;</span><br><span class="line">        upstream tomcatbackend &#123;</span><br><span class="line">        server 192.168.200.146:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        server &#123;</span><br><span class="line">                listen  81;</span><br><span class="line">                proxy_pass redisbackend;</span><br><span class="line">        &#125;</span><br><span class="line">        server &#123;</span><br><span class="line">        listen82;</span><br><span class="line">        proxy_pass tomcatbackend;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问测试。</p><h1>Nginx缓存集成</h1><h2 id="缓存的概念">缓存的概念</h2><p>缓存就是数据交换的缓冲区(称作:Cache),当用户要获取数据的时候，会先从缓存中去查询获取数据，如果缓存中有就会直接返回给用户，如果缓存中没有，则会发请求从服务器重新查询数据，将数据返回给用户的同时将数据放入缓存，下次用户就会直接从缓存中获取数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657865.png" alt="1591944051969"></p><p>缓存其实在很多场景中都有用到，比如：</p><table><thead><tr><th>场景</th><th>作用</th></tr></thead><tbody><tr><td>操作系统磁盘缓存</td><td>减少磁盘机械操作</td></tr><tr><td>数据库缓存</td><td>减少文件系统的IO操作</td></tr><tr><td>应用程序缓存</td><td>减少对数据库的查询</td></tr><tr><td>Web服务器缓存</td><td>减少对应用服务器请求次数</td></tr><tr><td>浏览器缓存</td><td>减少与后台的交互次数</td></tr></tbody></table><p>缓存的优点</p><p>​1.减少数据传输，节省网络流量，加快响应速度，提升用户体验；</p><p>​2.减轻服务器压力；</p><p>​3.提供服务端的高可用性；</p><p>缓存的缺点</p><p>​1.数据的不一致</p><p>​2.增加成本</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657866.png" alt="1582295367198"></p><p>本次课程注解讲解的是Nginx,Nginx作为web服务器，Nginx作为Web缓存服务器，它介于客户端和应用服务器之间，当用户通过浏览器访问一个URL时，web缓存服务器会去应用服务器获取要展示给用户的内容，将内容缓存到自己的服务器上，当下一次请求到来时，如果访问的是同一个URL，web缓存服务器就会直接将之前缓存的内容返回给客户端，而不是向应用服务器再次发送请求。web缓存降低了应用服务器、数据库的负载，减少了网络延迟，提高了用户访问的响应速度，增强了用户的体验。</p><h2 id="Nginx的web缓存服务">Nginx的web缓存服务</h2><p>Nginx是从0.7.48版开始提供缓存功能。Nginx是基于Proxy Store来实现的，其原理是把URL及相关组合当做Key,在使用MD5算法对Key进行哈希，得到硬盘上对应的哈希目录路径，从而将缓存内容保存在该目录中。它可以支持任意URL连接，同时也支持404/301/302这样的非200状态码。Nginx即可以支持对指定URL或者状态码设置过期时间，也可以使用purge命令来手动清除指定URL的缓存。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657867.png" alt="1591947990200"></p><h2 id="Nginx缓存设置的相关指令">Nginx缓存设置的相关指令</h2><p>Nginx的web缓存服务主要是使用<code>ngx_http_proxy_module</code>模块相关指令集来完成，接下来我们把常用的指令来进行介绍下。</p><h3 id="proxy-cache-path">proxy_cache_path</h3><p>该指定用于设置缓存文件的存放路径</p><table><thead><tr><th>语法</th><th>proxy_cache_path path [levels=number] <br/>keys_zone=zone_name:zone_size [inactive=time][max_size=size];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http</td></tr></tbody></table><p>path:缓存路径地址,如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/proxy_cache</span><br></pre></td></tr></table></figure><p>levels: 指定该缓存空间对应的目录，最多可以设置3层，每层取值为1|2如 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">levels=1:2   缓存空间有两层目录，第一次是1个字母，第二次是2个字母</span><br><span class="line">举例说明:</span><br><span class="line">itheima[key]通过MD5加密以后的值为 43c8233266edce38c2c9af0694e2107d</span><br><span class="line">levels=1:2   最终的存储路径为/usr/local/proxy_cache/d/07</span><br><span class="line">levels=2:1:2 最终的存储路径为/usr/local/proxy_cache/7d/0/21</span><br><span class="line">levels=2:2:2 最终的存储路径为??/usr/local/proxy_cache/7d/10/e2</span><br></pre></td></tr></table></figure><p>keys_zone:用来为这个缓存区设置名称和指定大小，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys_zone=itcast:200m  缓存区的名称是itcast,大小为200M,1M大概能存储8000个keys</span><br></pre></td></tr></table></figure><p>inactive:指定缓存的数据多次时间未被访问就将被删除，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inactive=1d   缓存数据在1天内没有被访问就会被删除</span><br></pre></td></tr></table></figure><p>max_size:设置最大缓存空间，如果缓存空间存满，默认会覆盖缓存时间最长的资源，如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_size=20g</span><br></pre></td></tr></table></figure><p>配置实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">proxy_cache_path /usr/local/proxy_cache keys_zone=itcast:200m  levels=1:2:1 inactive=1d max_size=20g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proxy-cache">proxy_cache</h3><p>该指令用来开启或关闭代理缓存，如果是开启则自定使用哪个缓存区来进行缓存。</p><table><thead><tr><th>语法</th><th>proxy_cache zone_name|off;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>zone_name：指定使用缓存区的名称</p><h3 id="proxy-cache-key">proxy_cache_key</h3><p>该指令用来设置web缓存的key值，Nginx会根据key值MD5哈希存缓存。</p><table><thead><tr><th>语法</th><th>proxy_cache_key key;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache_key $scheme$proxy_host$request_uri;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><h3 id="proxy-cache-valid">proxy_cache_valid</h3><p>该指令用来对不同返回状态码的URL设置不同的缓存时间</p><table><thead><tr><th>语法</th><th>proxy_cache_valid [code …] time;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_valid 200 302 10m;</span><br><span class="line">proxy_cache_valid 404 1m;</span><br><span class="line">为200和302的响应URL设置10分钟缓存，为404的响应URL设置1分钟缓存</span><br><span class="line">proxy_cache_valid any 1m;</span><br><span class="line">对所有响应状态码的URL都设置1分钟缓存</span><br></pre></td></tr></table></figure><h3 id="proxy-cache-min-uses">proxy_cache_min_uses</h3><p>该指令用来设置资源被访问多少次后被缓存</p><table><thead><tr><th>语法</th><th>proxy_cache_min_uses number;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache_min_uses 1;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><h3 id="proxy-cache-methods">proxy_cache_methods</h3><p>该指令用户设置缓存哪些HTTP方法</p><table><thead><tr><th>语法</th><th>proxy_cache_methods GET|HEAD|POST;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache_methods GET HEAD;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>默认缓存HTTP的GET和HEAD方法，不缓存POST方法。</p><h2 id="Nginx缓存设置案例">Nginx缓存设置案例</h2><h4 id="需求分析-3">需求分析</h4><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211657868.png" alt="1591959569463"></p><h4 id="步骤实现">步骤实现</h4><p>1.环境准备</p><p>应用服务器的环境准备</p><p>（1）在192.168.200.146服务器上的tomcat的webapps下面添加一个js目录，并在js目录中添加一个jquery.js文件</p><p>（2）启动tomcat</p><p>（3）访问测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.146:8080/js/jquery.js</span><br></pre></td></tr></table></figure><p>Nginx的环境准备</p><p>（1）完成Nginx反向代理配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass http://backend/js/;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）完成Nginx缓存配置</p><p>4.添加缓存配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">proxy_cache_path /usr/local/proxy_cache levels=2:1 keys_zone=itcast:200m inactive=1d max_size=20g;</span><br><span class="line">upstream backend&#123;</span><br><span class="line">server 192.168.200.146:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_cache itcast;</span><br><span class="line">            proxy_cache_key itheima;</span><br><span class="line">            proxy_cache_min_uses 5;</span><br><span class="line">            proxy_cache_valid 200 5d;</span><br><span class="line">            proxy_cache_valid 404 30s;</span><br><span class="line">            proxy_cache_valid any 1m;</span><br><span class="line">            add_header nginx-cache &quot;$upstream_cache_status&quot;;</span><br><span class="line">        proxy_pass http://backend/js/;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx缓存的清除">Nginx缓存的清除</h2><h3 id="方式一-删除对应的缓存目录">方式一:删除对应的缓存目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/local/proxy_cache/......</span><br></pre></td></tr></table></figure><h3 id="方式二-使用第三方扩展模块">方式二:使用第三方扩展模块</h3><h4 id="ngx-cache-purge">ngx_cache_purge</h4><p>（1）下载ngx_cache_purge模块对应的资源包，并上传到服务器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_cache_purge-2.3.tar.gz</span><br></pre></td></tr></table></figure><p>（2）对资源文件进行解压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf ngx_cache_purge-2.3.tar.gz</span><br></pre></td></tr></table></figure><p>（3）修改文件夹名称，方便后期配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> ngx_cache_purge-2.3 purge</span><br></pre></td></tr></table></figure><p>（4）查询Nginx的配置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure><p>（5）进入Nginx的安装目录，使用./configure进行参数配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/root/nginx/module/purge</span><br></pre></td></tr></table></figure><p>（6）使用make进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>（7）将nginx安装目录的nginx二级制可执行文件备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold</span><br></pre></td></tr></table></figure><p>（8）将编译后的objs中的nginx拷贝到nginx的sbin目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> objs/nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>（9）使用make进行升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure><p>（10）在nginx配置文件中进行如下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">location ~/purge(/.*) &#123;</span><br><span class="line">proxy_cache_purge itcast itheima;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx设置资源不缓存">Nginx设置资源不缓存</h2><p>前面咱们已经完成了Nginx作为web缓存服务器的使用。但是我们得思考一个问题就是不是所有的数据都适合进行缓存。比如说对于一些经常发生变化的数据。如果进行缓存的话，就很容易出现用户访问到的数据不是服务器真实的数据。所以对于这些资源我们在缓存的过程中就需要进行过滤，不进行缓存。</p><p>Nginx也提供了这块的功能设置，需要使用到如下两个指令</p><p>proxy_no_cache</p><p>该指令是用来定义不将数据进行缓存的条件。</p><table><thead><tr><th>语法</th><th>proxy_no_cache string …;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>配置实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;</span><br></pre></td></tr></table></figure><p>proxy_cache_bypass</p><p>该指令是用来设置不从缓存中获取数据的条件。</p><table><thead><tr><th>语法</th><th>proxy_cache_bypass string …;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>配置实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment;</span><br></pre></td></tr></table></figure><p>上述两个指令都有一个指定的条件，这个条件可以是多个，并且多个条件中至少有一个不为空且不等于&quot;0&quot;,则条件满足成立。上面给的配置实例是从官方网站获取的，里面使用到了三个变量，分别是$cookie_nocache、$arg_nocache、$arg_comment</p><h3 id="cookie-nocache、-arg-nocache、-arg-comment">$cookie_nocache、$arg_nocache、$arg_comment</h3><p>这三个参数分别代表的含义是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$cookie_nocache</span><br><span class="line">指的是当前请求的cookie中键的名称为nocache对应的值</span><br><span class="line">$arg_nocache和$arg_comment</span><br><span class="line">指的是当前请求的参数中属性名为nocache和comment对应的属性值</span><br></pre></td></tr></table></figure><p>案例演示下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log_format params $cookie_nocache | $arg_nocache | $arg_comment；</span><br><span class="line">server&#123;</span><br><span class="line">listen8081;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">access_log logs/access_params.log params;</span><br><span class="line">add_header Set-Cookie &#x27;nocache=999&#x27;;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例实现">案例实现</h3><p>设置不缓存资源的配置方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen8080;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line">if ($request_uri ~ /.*\.js$)&#123;</span><br><span class="line">           set $nocache 1;</span><br><span class="line">        &#125;</span><br><span class="line">proxy_no_cache $nocache $cookie_nocache $arg_nocache $arg_comment;</span><br><span class="line">        proxy_cache_bypass $nocache $cookie_nocache $arg_nocache $arg_comment;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习（二）</title>
      <link href="/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%BA%8C/"/>
      <url>/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1>Nginx进阶篇</h1><h2 id="Nginx服务器基础配置实例">Nginx服务器基础配置实例</h2><p>前面我们已经对Nginx服务器默认配置文件的结构和涉及的基本指令做了详细的阐述。通过这些指令的合理配置，我们就可以让一台Nginx服务器正常工作，并且提供基本的web服务器功能。</p><p>接下来我们将通过一个比较完整和最简单的基础配置实例，来巩固下前面所学习的指令及其配置。</p><p>需求如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">（1）有如下访问：</span><br><span class="line">http://192.168.200.133:8081/server1/location1</span><br><span class="line">访问的是：index_sr1_location1.html</span><br><span class="line">http://192.168.200.133:8081/server1/location2</span><br><span class="line">访问的是：index_sr1_location2.html</span><br><span class="line">http://192.168.200.133:8082/server2/location1</span><br><span class="line">访问的是：index_sr2_location1.html</span><br><span class="line">http://192.168.200.133:8082/server2/location2</span><br><span class="line">访问的是：index_sr2_location2.html</span><br><span class="line">（2）如果访问的资源不存在，</span><br><span class="line">返回自定义的404页面</span><br><span class="line">（3）将/server1和/server2的配置使用不同的配置文件分割</span><br><span class="line">将文件放到/home/www/conf.d目录下，然后使用include进行合并</span><br><span class="line">（4）为/server1和/server2各自创建一个访问日志文件</span><br></pre></td></tr></table></figure><p>准备相关文件，目录如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634071.png" alt="1587129309340"></p><p>配置的内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">##全局块 begin##</span></span><br><span class="line"><span class="comment">#配置允许运行Nginx工作进程的用户和用户组</span></span><br><span class="line">user www;</span><br><span class="line"><span class="comment">#配置运行Nginx进程生成的worker进程数</span></span><br><span class="line">worker_processes 2;</span><br><span class="line"><span class="comment">#配置Nginx服务器运行对错误日志存放的路径</span></span><br><span class="line">error_log logs/error.log;</span><br><span class="line"><span class="comment">#配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称</span></span><br><span class="line">pid logs/nginx.pid;</span><br><span class="line"><span class="comment">#配置Nginx服务是否以守护进程方法启动</span></span><br><span class="line"><span class="comment">#daemon on;</span></span><br><span class="line"><span class="comment">##全局块 end##</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##events块 begin##</span></span><br><span class="line">events&#123;</span><br><span class="line"><span class="comment">#设置Nginx网络连接序列化</span></span><br><span class="line">accept_mutex on;</span><br><span class="line"><span class="comment">#设置Nginx的worker进程是否可以同时接收多个请求</span></span><br><span class="line">multi_accept on;</span><br><span class="line"><span class="comment">#设置Nginx的worker进程最大的连接数</span></span><br><span class="line">worker_connections 1024;</span><br><span class="line"><span class="comment">#设置Nginx使用的事件驱动模型</span></span><br><span class="line">use epoll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">##events块 end##</span></span><br><span class="line"><span class="comment">##http块 start##</span></span><br><span class="line">http&#123;</span><br><span class="line"><span class="comment">#定义MIME-Type</span></span><br><span class="line">include mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br><span class="line"><span class="comment">#配置允许使用sendfile方式运输</span></span><br><span class="line">sendfile on;</span><br><span class="line"><span class="comment">#配置连接超时时间</span></span><br><span class="line">keepalive_timeout 65;</span><br><span class="line"><span class="comment">#配置请求处理日志格式</span></span><br><span class="line">log_format server1 <span class="string">&#x27;===&gt;server1 access log&#x27;</span>;</span><br><span class="line">log_format server2 <span class="string">&#x27;===&gt;server2 access log&#x27;</span>;</span><br><span class="line"><span class="comment">##server块 开始##</span></span><br><span class="line">include /home/www/conf.d/*.conf;</span><br><span class="line"><span class="comment">##server块 结束##</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">##http块 end##</span></span><br></pre></td></tr></table></figure><p>server1.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"><span class="comment">#配置监听端口和主机名称</span></span><br><span class="line">listen 8081;</span><br><span class="line">server_name localhost;</span><br><span class="line"><span class="comment">#配置请求处理日志存放路径</span></span><br><span class="line">access_log /home/www/myweb/server1/logs/access.log server1;</span><br><span class="line"><span class="comment">#配置错误页面</span></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line"><span class="comment">#配置处理/server1/location1请求的location</span></span><br><span class="line">location /server1/location1&#123;</span><br><span class="line">root /home/www/myweb;</span><br><span class="line">index index_sr1_location1.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#配置处理/server1/location2请求的location</span></span><br><span class="line">location /server1/location2&#123;</span><br><span class="line">root /home/www/myweb;</span><br><span class="line">index index_sr1_location2.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#配置错误页面转向</span></span><br><span class="line">location = /404.html &#123;</span><br><span class="line">root /home/www/myweb;</span><br><span class="line">index 404.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server2.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"><span class="comment">#配置监听端口和主机名称</span></span><br><span class="line">listen 8082;</span><br><span class="line">server_name localhost;</span><br><span class="line"><span class="comment">#配置请求处理日志存放路径</span></span><br><span class="line">access_log /home/www/myweb/server2/logs/access.log server2;</span><br><span class="line"><span class="comment">#配置错误页面,对404.html做了定向配置</span></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line"><span class="comment">#配置处理/server1/location1请求的location</span></span><br><span class="line">location /server2/location1&#123;</span><br><span class="line">root /home/www/myweb;</span><br><span class="line">index index_sr2_location1.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#配置处理/server2/location2请求的location</span></span><br><span class="line">location /server2/location2&#123;</span><br><span class="line">root /home/www/myweb;</span><br><span class="line">index index_sr2_location2.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#配置错误页面转向</span></span><br><span class="line">location = /404.html &#123;</span><br><span class="line">root /home/www/myweb;</span><br><span class="line">index 404.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问测试：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634072.png" alt="1587129766585"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634073.png" alt="1587129777898"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634074.png" alt="1587290246228"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634075.png" alt="1587129805309"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634076.png" alt="1587129817226"></p><h2 id="Nginx服务操作的问题">Nginx服务操作的问题</h2><p>经过前面的操作，我们会发现，如果想要启动、关闭或重新加载nginx配置文件，都需要先进入到nginx的安装目录的sbin目录，然后使用nginx的二级制可执行文件来操作，相对来说操作比较繁琐，这块该如何优化？另外如果我们想把Nginx设置成随着服务器启动就自动完成启动操作，又该如何来实现?这就需要用到接下来我们要讲解的两个知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nginx配置成系统服务</span><br><span class="line">Nginx命令配置到系统环境</span><br></pre></td></tr></table></figure><h2 id="Nginx配置成系统服务">Nginx配置成系统服务</h2><p>把Nginx应用服务设置成为系统服务，方便对Nginx服务的启动和停止等相关操作，具体实现步骤:</p><p>(1) 在<code>/usr/lib/systemd/system</code>目录下添加nginx.service,内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx web service</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><p>(2)添加完成后如果权限有问题需要进行权限设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure><p>(3)使用系统命令来操作Nginx服务</p><blockquote><p>启动: systemctl start nginx<br>停止: systemctl stop nginx<br>重启: systemctl restart nginx<br>重新加载配置文件: systemctl reload nginx<br>查看nginx状态: systemctl status nginx<br>开机启动: systemctl enable nginx</p></blockquote><h2 id="Nginx命令配置到系统环境">Nginx命令配置到系统环境</h2><p>前面我们介绍过Nginx安装目录下的二级制可执行文件<code>nginx</code>的很多命令，要想使用这些命令前提是需要进入sbin目录下才能使用，很不方便，如何去优化，我们可以将该二进制可执行文件加入到系统的环境变量，这样的话在任何目录都可以使用nginx对应的相关命令。具体实现步骤如下:</p><p>演示可删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin  nginx -V</span><br><span class="line"><span class="comment">#如何优化？？？</span></span><br></pre></td></tr></table></figure><p>(1)修改<code>/etc/profile</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#在最后一行添加</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>(2)使之立即生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>(3)执行nginx命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure><h2 id="Nginx静态资源部署">Nginx静态资源部署</h2><h3 id="Nginx静态资源概述">Nginx静态资源概述</h3><p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个HTTP请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请 求的内容就分为两种类型，一类是静态资源、一类是动态资源。<br>静态资源即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的html页面、css文件、js文件、图 片、视频等资源；<br>动态资源即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</p><p>Nginx处理静态资源的内容，我们需要考虑下面这几个问题：</p><blockquote><p>（1）静态资源的配置指令<br>（2）静态资源的配置优化<br>（3）静态资源的压缩配置指令<br>（4）静态资源的缓存处理<br>（5）静态资源的访问控制，包括跨域问题和防盗链问题</p></blockquote><h3 id="Nginx静态资源的配置指令">Nginx静态资源的配置指令</h3><h4 id="listen指令">listen指令</h4><p>listen:用来配置监听端口。</p><table><thead><tr><th>语法</th><th>listen address[:port] [default_server]…;<br/>listen port [default_server]…;</th></tr></thead><tbody><tr><td>默认值</td><td>listen *:80 | *:8000</td></tr><tr><td>位置</td><td>server</td></tr></tbody></table><p>listen的设置比较灵活，我们通过几个例子来把常用的设置方式熟悉下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listen 127.0.0.1:8000; // listen localhost:8000 监听指定的IP和端口</span><br><span class="line">listen 127.0.0.1;监听指定IP的所有端口</span><br><span class="line">listen 8000;监听指定端口上的连接</span><br><span class="line">listen *:8000;监听指定端口上的连接</span><br></pre></td></tr></table></figure><p>default_server属性是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。如果不指定默认使用的是第一个server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 8080;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">location /&#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 8080 default_server;</span><br><span class="line">server_name localhost;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 444 &#x27;This is a error request&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="server-name指令">server_name指令</h4><p>server_name：用来设置虚拟主机服务名称。</p><p>127.0.0.1 、 localhost 、域名[<a href="http://www.baidu.com">www.baidu.com</a> | <a href="http://www.jd.com">www.jd.com</a>]</p><table><thead><tr><th>语法</th><th>server_name  name …;<br/>name可以提供多个中间用空格分隔</th></tr></thead><tbody><tr><td>默认值</td><td>server_name  “”;</td></tr><tr><td>位置</td><td>server</td></tr></tbody></table><p>关于server_name的配置方式有三种，分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">精确匹配</span><br><span class="line">通配符匹配</span><br><span class="line">正则表达式匹配</span><br></pre></td></tr></table></figure><p>配置方式一：精确匹配</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.itcast.cn www.itheima.cn;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充小知识点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。</span><br></pre></td></tr></table></figure><p>windows:C:\Windows\System32\drivers\etc</p><p>centos：/etc/hosts</p><p>因为域名是要收取一定的费用，所以我们可以使用修改hosts文件来制作一些虚拟域名来使用。需要修改 <code>/etc/hosts</code>文件来添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">127.0.0.1 www.itcast.cn</span><br><span class="line">127.0.0.1 www.itheima.cn</span><br></pre></td></tr></table></figure><p>配置方式二:使用通配符配置</p><p>server_name中支持通配符&quot;*&quot;,但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name  *.itcast.cnwww.itheima.*;</span><br><span class="line"># www.itcast.cn abc.itcast.cn www.itheima.cn www.itheima.com</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的配置就会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name  www.*.cn www.itheima.c*</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置三:使用正则表达式配置</p><p>server_name中可以使用正则表达式，并且使用<code>~</code>作为正则表达式字符串的开始标记。</p><p>常见的正则表达式</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配搜索字符串开始位置</td></tr><tr><td>$</td><td>匹配搜索字符串结束位置</td></tr><tr><td>.</td><td>匹配除换行符\n之外的任何单个字符</td></tr><tr><td>\</td><td>转义字符，将下一个字符标记为特殊字符</td></tr><tr><td>[xyz]</td><td>字符集，与任意一个指定字符匹配</td></tr><tr><td>[a-z]</td><td>字符范围，匹配指定范围内的任何字符</td></tr><tr><td>\w</td><td>与以下任意字符匹配 A-Z a-z 0-9 和下划线,等效于[A-Za-z0-9_]</td></tr><tr><td>\d</td><td>数字字符匹配，等效于[0-9]</td></tr><tr><td>{n}</td><td>正好匹配n次</td></tr><tr><td>{n,}</td><td>至少匹配n次</td></tr><tr><td>{n,m}</td><td>匹配至少n次至多m次</td></tr><tr><td>*</td><td>零次或多次，等效于{0,}</td></tr><tr><td>+</td><td>一次或多次，等效于{1,}</td></tr><tr><td>?</td><td>零次或一次，等效于{0,1}</td></tr></tbody></table><p>配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name ~^www\.(\w+)\.com$;</span><br><span class="line">        default_type text/plain;</span><br><span class="line">        return 200 $1  $2 ..;</span><br><span class="line">&#125;</span><br><span class="line">注意 ~后面不能加空格，括号可以取值</span><br></pre></td></tr></table></figure><h5 id="匹配执行顺序">匹配执行顺序</h5><p>由于server_name指令支持通配符和正则表达式，因此在包含多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的server_name匹配成功，当遇到这种情况，当前的请求交给谁来处理呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name ~^www\.\w+\.com$;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &#x27;regex_success&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.itheima.*;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &#x27;wildcard_after_success&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name *.itheima.com;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &#x27;wildcard_before_success&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.itheima.com;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &#x27;exact_success&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">listen 80 default_server;</span><br><span class="line">server_name _;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 444 &#x27;default_server not found server&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exact_success</span><br><span class="line">wildcard_before_success</span><br><span class="line">wildcard_after_success</span><br><span class="line">regex_success</span><br><span class="line">default_server not found server!!</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">No1:准确匹配server_name</span><br><span class="line"></span><br><span class="line">No2:通配符在开始时匹配server_name成功</span><br><span class="line"></span><br><span class="line">No3:通配符在结束时匹配server_name成功</span><br><span class="line"></span><br><span class="line">No4:正则表达式匹配server_name成功</span><br><span class="line"></span><br><span class="line">No5:被默认的default_server处理，如果没有指定默认找第一个server</span><br></pre></td></tr></table></figure><h4 id="location指令">location指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">location /abc&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>location:用来设置请求的URI</p><table><thead><tr><th>语法</th><th>location [  =  |   ~  |  ~*   |   ^~   |@ ] uri{…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server,location</td></tr></tbody></table><p>uri变量是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式，那么nginx服务器在搜索匹配location的时候，是先使用不包含正则表达式进行匹配，找到一个匹配度最高的一个，然后在通过包含正则表达式的进行匹配，如果能匹配到直接访问，匹配不到，就使用刚才匹配度最高的那个location来处理请求。</p><p>属性介绍:</p><p>不带符号，要求必须以指定模式开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">location /abc&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &quot;access success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">以下访问都是正确的</span><br><span class="line">http://192.168.200.133/abc</span><br><span class="line">http://192.168.200.133/abc?p1=TOM</span><br><span class="line">http://192.168.200.133/abc/</span><br><span class="line">http://192.168.200.133/abcdef</span><br></pre></td></tr></table></figure><p>= :  用于不包含正则表达式的uri前，必须与指定的模式精确匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">location =/abc&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &quot;access success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">可以匹配到</span><br><span class="line">http://192.168.200.133/abc</span><br><span class="line">http://192.168.200.133/abc?p1=TOM</span><br><span class="line">匹配不到</span><br><span class="line">http://192.168.200.133/abc/</span><br><span class="line">http://192.168.200.133/abcdef</span><br></pre></td></tr></table></figure><p>~ ： 用于表示当前uri中包含了正则表达式，并且区分大小写<br>~*:  用于表示当前uri中包含了正则表达式，并且不区分大小写</p><p>换句话说，如果uri包含了正则表达式，需要用上述两个符合来标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">location ~^/abc\w$&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &quot;access success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">location ~*^/abc\w$&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &quot;access success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>^~: 用于不包含正则表达式的uri前，功能和不加符号的一致，唯一不同的是，如果模式匹配，那么就停止搜索其他模式了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line">location ^~/abc&#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 200 &quot;access success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置请求资源的目录root-alias">设置请求资源的目录root / alias</h4><p>root：设置请求的根目录</p><table><thead><tr><th>语法</th><th>root path;</th></tr></thead><tbody><tr><td>默认值</td><td>root html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>path为Nginx服务器接收到请求以后查找资源的根目录路径。</p><p>alias：用来更改location的URI</p><table><thead><tr><th>语法</th><th>alias path;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>location</td></tr></tbody></table><p>path为修改后的根路径。</p><p>以上两个指令都可以来指定访问资源的路径，那么这两者之间的区别是什么?</p><p>举例说明：</p><p>（1）在<code>/usr/local/nginx/html</code>目录下创建一个 images目录,并在目录下放入一张图片<code>mv.png</code>图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">root /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问图片的路径为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.133/images/mv.png</span><br></pre></td></tr></table></figure><p>（2）如果把root改为alias</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">alias /usr/local/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问上述地址，页面会出现404的错误，查看错误日志会发现是因为地址不对，所以验证了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root的处理结果是: root路径+location路径</span><br><span class="line">/usr/local/nginx/html/images/mv.png</span><br><span class="line">alias的处理结果是:使用alias路径替换location路径</span><br><span class="line">/usr/local/nginx/html/images</span><br></pre></td></tr></table></figure><p>需要在alias后面路径改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">alias /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）如果location路径是以/结尾,则alias也必须是以/结尾，root没有要求</p><p>将上述配置修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">alias /usr/local/nginx/html/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问就会出问题，查看错误日志还是路径不对，所以需要把alias后面加上 /</p><p>小结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root的处理结果是: root路径+location路径</span><br><span class="line">alias的处理结果是:使用alias路径替换location路径</span><br><span class="line">alias是一个目录别名的定义，root则是最上层目录的含义。</span><br><span class="line">如果location路径是以/结尾,则alias也必须是以/结尾，root没有要求</span><br></pre></td></tr></table></figure><h4 id="index指令">index指令</h4><p>index:设置网站的默认首页</p><table><thead><tr><th>语法</th><th>index file …;</th></tr></thead><tbody><tr><td>默认值</td><td>index index.html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>index后面可以跟多个设置，如果访问的时候没有指定具体访问的资源，则会依次进行查找，找到第一个为止。</p><p>举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root /usr/local/nginx/html;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">访问该location的时候，可以通过 http://ip:port/，地址后面如果不添加任何内容，则默认依次访问index.html和index.htm，找到第一个来进行返回</span><br></pre></td></tr></table></figure><h4 id="error-page指令">error_page指令</h4><p>error_page:设置网站的错误页面</p><table><thead><tr><th>语法</th><th>error_page code … [=[response]] uri;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location…</td></tr></tbody></table><p>当出现对应的响应code后，如何来处理。</p><p>举例说明：</p><p>（1）可以指定具体跳转的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">error_page 404 http://www.itcast.cn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）可以指定重定向地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">error_page 404 /50x.html;</span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">location =/50x.html&#123;</span><br><span class="line">root html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）使用location的@符合完成错误信息展示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">error_page 404 @jump_to_error;</span><br><span class="line">location @jump_to_error &#123;</span><br><span class="line">default_type text/plain;</span><br><span class="line">return 404 &#x27;Not Found Page...&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选项<code>=[response]</code>的作用是用来将相应代码更改为另外一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">error_page 404 =200 /50x.html;</span><br><span class="line">location =/50x.html&#123;</span><br><span class="line">root html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">这样的话，当返回404找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是200，这块需要注意下，编写error_page后面的内容，404后面需要加空格，200前面不能加空格</span><br></pre></td></tr></table></figure><h3 id="静态资源优化配置语法">静态资源优化配置语法</h3><p>Nginx对静态资源如何进行优化配置。这里从三个属性配置进行优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendfile on;</span><br><span class="line">tcp_nopush on;</span><br><span class="line">tcp_nodeplay on;</span><br></pre></td></tr></table></figure><p>（1）sendﬁle，用来开启高效的文件传输模式。</p><table><thead><tr><th>语法</th><th>sendﬁle on |oﬀ;</th></tr></thead><tbody><tr><td>默认值</td><td>sendﬁle oﬀ;</td></tr><tr><td>位置</td><td>http、server、location…</td></tr></tbody></table><p>请求静态资源的过程：客户端通过网络接口向服务端发送请求，操作系统将这些客户端的请求传递给服务器端应用程序，服务器端应用程序会处理这些请求，请求处理完成以后，操作系统还需要将处理得到的结果通过网络适配器传递回去。</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost；</span><br><span class="line">location / &#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">在html目录下有一个welcome.html页面，访问地址</span><br><span class="line">http://192.168.200.133/welcome.html</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634077.png" alt="1587655397104"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634078.png" alt="1587665814562"></p><p>（2）tcp_nopush：该指令必须在sendfile打开的状态下才会生效，主要是用来提升网络包的传输’效率’</p><table><thead><tr><th>语法</th><th>tcp_nopush on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>tcp_nopush oﬀ;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（3）tcp_nodelay：该指令必须在keep-alive连接开启的情况下才生效，来提高网络包传输的’实时性’</p><table><thead><tr><th>语法</th><th>tcp_nodelay on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>tcp_nodelay on;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634079.png" alt="1587832596733"></p><p>经过刚才的分析，“tcp_nopush&quot;和”tcp_nodelay“看起来是&quot;互斥的”，那么为什么要将这两个值都打开，这个大家需要知道的是在linux2.5.9以后的版本中两者是可以兼容的，三个指令都开启的好处是，sendfile可以开启高效的文件传输模式，tcp_nopush开启可以确保在发送到客户端之前数据包已经充分“填满”， 这大大减少了网络开销，并加快了文件发送的速度。 然后，当它到达最后一个可能因为没有“填满”而暂停的数据包时，Nginx会忽略tcp_nopush参数， 然后，tcp_nodelay强制套接字发送数据。由此可知，TCP_NOPUSH可以与TCP_NODELAY一起设置，它比单独配置TCP_NODELAY具有更强的性能。所以我们可以使用如下配置来优化Nginx静态资源的处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendfile on;</span><br><span class="line">tcp_nopush on;</span><br><span class="line">tcp_nodelay on;</span><br></pre></td></tr></table></figure><h3 id="Nginx静态资源压缩实战">Nginx静态资源压缩实战</h3><p>经过上述内容的优化，我们再次思考一个问题，假如在满足上述优化的前提下，我们传送一个1M的数据和一个10M的数据那个效率高?，答案显而易见，传输内容小，速度就会快。那么问题又来了，同样的内容，如果把大小降下来，我们脑袋里面要蹦出一个词就是&quot;压缩&quot;，接下来，我们来学习Nginx的静态资源压缩模块。</p><p>在Nginx的配置文件中可以通过配置gzip来对静态资源进行压缩，相关的指令可以配置在http块、server块和location块中，Nginx可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_gzip_module模块</span><br><span class="line">ngx_http_gzip_static_module模块</span><br><span class="line">ngx_http_gunzip_module模块</span><br></pre></td></tr></table></figure><p>对这些指令进行解析和处理。</p><p>接下来我们从以下内容进行学习</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）Gzip各模块支持的配置指令</span><br><span class="line">（2）Gzip压缩功能的配置</span><br><span class="line">（3）Gzip和sendfile的冲突解决</span><br><span class="line">（4）浏览器不支持Gzip的解决方案</span><br></pre></td></tr></table></figure><h4 id="Gzip模块配置指令">Gzip模块配置指令</h4><p>接下来所学习的指令都来自ngx_http_gzip_module模块，该模块会在nginx安装的时候内置到nginx的安装环境中，也就是说我们可以直接使用这些指令。</p><ol><li>gzip指令：该指令用于开启或者关闭gzip功能</li></ol><table><thead><tr><th>语法</th><th>gzip on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip off;</td></tr><tr><td>位置</td><td>http、server、location…</td></tr></tbody></table><p>注意只有该指令为打开状态，下面的指令才有效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">   gzip on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>gzip_types指令：该指令可以根据响应页的MIME类型选择性地开启Gzip压缩功能</li></ol><table><thead><tr><th>语法</th><th>gzip_types mime-type …;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_types text/html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>所选择的值可以从mime.types文件中进行查找，也可以使用&quot;*&quot;代表所有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">gzip_types application/javascript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>gzip_comp_level指令：该指令用于设置Gzip压缩程度，级别从1-9,1表示要是程度最低，要是效率最高，9刚好相反，压缩程度最高，但是效率最低最费时间。</li></ol><table><thead><tr><th>语法</th><th>gzip_comp_level level;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_comp_level 1;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>gzip_vary指令：该指令用于设置使用Gzip进行压缩发送是否携带“Vary:Accept-Encoding”头域的响应头部。主要是告诉接收方，所发送的数据经过了Gzip压缩处理</li></ol><table><thead><tr><th>语法</th><th>gzip_vary on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_vary off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634080.png" alt="1587361606028"></p><ol start="5"><li>gzip_buffers指令：该指令用于处理请求压缩的缓冲区数量和大小。</li></ol><table><thead><tr><th>语法</th><th>gzip_buffers number size;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_buffers 32 4k|16 8k;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>其中number:指定Nginx服务器向系统申请缓存空间个数，size指的是每个缓存空间的大小。主要实现的是申请number个每个大小为size的内存空间。这个值的设定一般会和服务器的操作系统有关，所以建议此项不设置，使用默认值即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip_buffers 4 16K;  #缓存空间大小</span><br></pre></td></tr></table></figure><ol start="6"><li>gzip_disable指令：针对不同种类客户端发起的请求，可以选择性地开启和关闭Gzip功能。</li></ol><table><thead><tr><th>语法</th><th>gzip_disable regex …;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>regex:根据客户端的浏览器标志(user-agent)来设置，支持使用正则表达式。指定的浏览器标志不使用Gzip.该指令一般是用来排除一些明显不支持Gzip的浏览器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br></pre></td></tr></table></figure><ol start="7"><li>gzip_http_version指令：针对不同的HTTP协议版本，可以选择性地开启和关闭Gzip功能。</li></ol><table><thead><tr><th>语法</th><th>gzip_http_version 1.0|1.1;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_http_version 1.1;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>该指令是指定使用Gzip的HTTP最低版本，该指令一般采用默认值即可。</p><ol start="8"><li>gzip_min_length指令：该指令针对传输数据的大小，可以选择性地开启和关闭Gzip功能</li></ol><table><thead><tr><th>语法</th><th>gzip_min_length length;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_min_length 20;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nignx计量大小的单位：bytes[字节] / kb[千字节] / M[兆]</span><br><span class="line">例如: 1024 / 10k|K / 10m|M</span><br></pre></td></tr></table></figure><p>Gzip压缩功能对大数据的压缩效果明显，但是如果要压缩的数据比较小的化，可能出现越压缩数据量越大的情况，因此我们需要根据响应内容的大小来决定是否使用Gzip功能，响应页面的大小可以通过头信息中的<code>Content-Length</code>来获取。但是如何使用了Chunk编码动态压缩，该指令将被忽略。建议设置为1K或以上。</p><ol start="9"><li>gzip_proxied指令：该指令设置是否对服务端返回的结果进行Gzip压缩。</li></ol><table><thead><tr><th>语法</th><th>gzip_proxied  off|expired|no-cache|<br/>no-store|private|no_last_modified|no_etag|auth|any;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_proxied off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>off - 关闭Nginx服务器对后台服务器返回结果的Gzip压缩<br>expired - 启用压缩，如果header头中包含 “Expires” 头信息<br>no-cache - 启用压缩，如果header头中包含 “Cache-Control:no-cache” 头信息<br>no-store - 启用压缩，如果header头中包含 “Cache-Control:no-store” 头信息<br>private - 启用压缩，如果header头中包含 “Cache-Control:private” 头信息<br>no_last_modified - 启用压缩,如果header头中不包含 “Last-Modified” 头信息<br>no_etag - 启用压缩 ,如果header头中不包含 “ETag” 头信息<br>auth - 启用压缩 , 如果header头中包含 “Authorization” 头信息<br>any - 无条件启用压缩</p><h4 id="Gzip压缩功能的实例配置">Gzip压缩功能的实例配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gzip on;    #开启gzip功能</span><br><span class="line">gzip_types *;  #压缩源文件类型,根据具体的访问资源类型设定</span><br><span class="line">gzip_comp_level 6;  #gzip压缩级别</span><br><span class="line">gzip_min_length 1024; #进行压缩响应页面的最小长度,content-length</span><br><span class="line">gzip_buffers 4 16K;  #缓存空间大小</span><br><span class="line">gzip_http_version 1.1; #指定压缩响应所需要的最低HTTP请求版本</span><br><span class="line">gzip_vary  on;  #往头信息中添加压缩标识</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;; #对IE6以下的版本都不进行压缩</span><br><span class="line">gzip_proxied  off； #nginx作为反向代理压缩服务端返回数据的条件</span><br></pre></td></tr></table></figure><p>这些配置在很多地方可能都会用到，所以我们可以将这些内容抽取到一个配置文件中，然后通过include指令把配置文件再次加载到nginx.conf配置文件中，方法使用。</p><p>nginx_gzip.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_types *;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line">gzip_min_length 1024;</span><br><span class="line">gzip_buffers 4 16K;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line">gzip_vary  on;</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line">gzip_proxied  off;</span><br></pre></td></tr></table></figure><p>nginx.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include nginx_gzip.conf</span><br></pre></td></tr></table></figure><h4 id="Gzip和sendfile共存问题">Gzip和sendfile共存问题</h4><p>前面在讲解sendfile的时候，提到过，开启sendfile以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以不经过用户进程将静态文件通过网络设备发送出去，但是Gzip要想对资源压缩，是需要经过用户进程进行操作的。所以如何解决两个设置的共存问题。</p><p>可以使用ngx_http_gzip_static_module模块的gzip_static指令来解决。</p><h5 id="gzip-static指令">gzip_static指令</h5><p>gzip_static: 检查与访问资源同名的.gz文件时，response中以gzip相关的header返回.gz文件的内容。</p><table><thead><tr><th>语法</th><th><strong>gzip_static</strong> on | off | always;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_static off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>添加上述命令后，会报一个错误，<code>unknown directive &quot;gzip_static&quot;</code>主要的原因是Nginx默认是没有添加ngx_http_gzip_static_module模块。如何来添加?</p><h5 id="添加模块到Nginx的实现步骤">添加模块到Nginx的实现步骤</h5><p>(1)查询当前Nginx的配置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure><p>(2)将nginx安装目录下sbin目录中的nginx二进制文件进行更名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">mv nginx nginxold</span><br></pre></td></tr></table></figure><p>(3) 进入Nginx的安装目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /root/nginx/core/nginx-1.16.1</span><br></pre></td></tr></table></figure><p>(4)执行make clean清空之前编译的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>(5)使用configure来配置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gzip_static_module</span><br></pre></td></tr></table></figure><p>(6)使用make命令进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>(7) 将objs目录下的nginx二进制执行文件移动到nginx安装目录下的sbin目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv objs/nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>(8)执行更新命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure><h5 id="gzip-static测试使用">gzip_static测试使用</h5><p>(1)直接访问<code>http://192.168.200.133/jquery.js</code></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634081.png" alt="1587932106429"></p><p>(2)使用gzip命令进行压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/html</span><br><span class="line">gzip jquery.js</span><br></pre></td></tr></table></figure><p>(3)再次访问<code>http://192.168.200.133/jquery.js</code></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634082.png" alt="1587932300006"></p><h3 id="静态资源的缓存处理">静态资源的缓存处理</h3><h4 id="什么是缓存">什么是缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</span><br></pre></td></tr></table></figure><h4 id="什么是web缓存">什么是web缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页</span><br></pre></td></tr></table></figure><h4 id="web缓存的种类">web缓存的种类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端缓存</span><br><span class="line">浏览器缓存</span><br><span class="line">服务端缓存</span><br><span class="line">Nginx / Redis / Memcached等</span><br></pre></td></tr></table></figure><h4 id="浏览器缓存">浏览器缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览.</span><br></pre></td></tr></table></figure><h4 id="为什么要用浏览器缓存">为什么要用浏览器缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成本最低的一种缓存实现</span><br><span class="line">减少网络带宽消耗</span><br><span class="line">降低服务器压力</span><br><span class="line">减少网络延迟，加快页面打开速度</span><br></pre></td></tr></table></figure><h4 id="浏览器缓存的执行流程">浏览器缓存的执行流程</h4><p>HTTP协议中和页面缓存相关的字段，我们先来认识下：</p><table><thead><tr><th>header</th><th>说明</th></tr></thead><tbody><tr><td>Expires</td><td>缓存过期的日期和时间</td></tr><tr><td>Cache-Control</td><td>设置和缓存相关的配置信息</td></tr><tr><td>Last-Modified</td><td>请求资源最后修改时间</td></tr><tr><td>ETag</td><td>请求变量的实体标签的当前值，比如文件的MD5值</td></tr></tbody></table><h4 id=""></h4><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634083.png" alt=""></p><p>（1）用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送request请求来获取数据；</p><p>（2）服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回200的成功状态码并且在响应头上附上对应资源以及缓存信息；</p><p>（3）当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件</p><p>（4）如果没有找到对应的缓存文件，则走(2)步</p><p>（5）如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires),</p><p>（6）如果没有过期，则直接从本地缓存中返回数据进行展示</p><p>（7）如果Expires过期，接下来需要判断缓存文件是否发生过变化</p><p>（8）判断的标准有两个，一个是ETag(Entity Tag),一个是Last-Modified</p><p>（9）判断结果是未发生变化，则服务端返回304，直接从缓存文件中获取数据</p><p>（10）如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。</p><h4 id="浏览器缓存相关指令">浏览器缓存相关指令</h4><p>Nginx需要进行缓存相关设置，就需要用到如下的指令</p><h5 id="expires指令">expires指令</h5><p>expires:该指令用来控制页面缓存的作用。可以通过该指令控制HTTP应答中的“Expires&quot;和”Cache-Control&quot;</p><table><thead><tr><th>语法</th><th>expires   [modified] time<br/>expires epoch|max|off;</th></tr></thead><tbody><tr><td>默认值</td><td>expires off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>time:可以整数也可以是负数，指定过期时间，如果是负数，Cache-Control则为no-cache,如果为整数或0，则Cache-Control的值为max-age=time;</p><p>epoch: 指定Expires的值为’1 January,1970,00:00:01 GMT’(1970-01-01 00:00:00)，Cache-Control的值no-cache</p><p>max:指定Expires的值为’31 December2037 23:59:59GMT’ (2037-12-31 23:59:59) ，Cache-Control的值为10年</p><p>off:默认不缓存。</p><h5 id="add-header指令">add_header指令</h5><p>add_header指令是用来添加指定的响应头和响应值。</p><table><thead><tr><th>语法</th><th>add_header name value [always];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location…</td></tr></tbody></table><p>Cache-Control作为响应头信息，可以设置如下值：</p><p>缓存响应指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: must-revalidate</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: public</span><br><span class="line">Cache-control: private</span><br><span class="line">Cache-control: proxy-revalidate</span><br><span class="line">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class="line">Cache-control: s-maxage=&lt;seconds&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>must-revalidate</td><td>可缓存但必须再向源服务器进行确认</td></tr><tr><td>no-cache</td><td>缓存前必须确认其有效性</td></tr><tr><td>no-store</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>代理不可更改媒体类型</td></tr><tr><td>public</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>仅向特定用户返回响应</td></tr><tr><td>proxy-revalidate</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td>max-age=&lt;秒&gt;</td><td>响应最大Age值</td></tr><tr><td>s-maxage=&lt;秒&gt;</td><td>公共缓存服务器响应的最大Age值</td></tr></tbody></table><p>max-age=[秒]：</p><h3 id="Nginx的跨域问题解决">Nginx的跨域问题解决</h3><p>这块内容，我们主要从以下方面进行解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么情况下会出现跨域问题?</span><br><span class="line">实例演示跨域问题</span><br><span class="line">具体的解决方案是什么?</span><br></pre></td></tr></table></figure><h4 id="同源策略">同源策略</h4><p>浏览器的同源策略：是一种约定，是浏览器最核心也是最基本的安全功能，如果浏览器少了同源策略，则浏览器的正常功能可能都会受到影响。</p><p>同源:  协议、域名(IP)、端口相同即为同源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.200.131/user/1</span><br><span class="line">https://192.168.200.131/user/1</span><br><span class="line">不</span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.132/user/1</span><br><span class="line">不</span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.131:8080/user/1</span><br><span class="line">不</span><br><span class="line"></span><br><span class="line">http://www.nginx.com/user/1</span><br><span class="line">http://www.nginx.org/user/1</span><br><span class="line">不</span><br><span class="line"></span><br><span class="line">http://192.168.200.131/user/1</span><br><span class="line">http://192.168.200.131:8080/user/1</span><br><span class="line">不</span><br><span class="line"></span><br><span class="line">http://www.nginx.org:80/user/1</span><br><span class="line">http://www.nginx.org/user/1</span><br><span class="line">满足</span><br></pre></td></tr></table></figure><h4 id="跨域问题">跨域问题</h4><p>简单描述下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有两台服务器分别为A,B,如果从服务器A的页面发送异步请求到服务器B获取数据，如果服务器A和服务器B不满足同源策略，则就会出现跨域问题。</span><br></pre></td></tr></table></figure><h4 id="跨域问题的案例演示">跨域问题的案例演示</h4><p>出现跨域问题会有什么效果?,接下来通过一个需求来给大家演示下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634084.png" alt="">（1）nginx的html目录下新建一个a.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域问题演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            $(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        $.<span class="title function_">get</span>(<span class="string">&#x27;http://192.168.200.133:8080/getUser&#x27;</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span></span><br><span class="line"><span class="language-javascript">                        &#125;);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取数据&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）在nginx.conf配置如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen  8080;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        location /getUser&#123;</span><br><span class="line">                default_type application/json;</span><br><span class="line">                return 200 &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;TOM&quot;,&quot;age&quot;:18&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /&#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)通过浏览器访问测试</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634085.png" alt="1588004913681"></p><h4 id="解决方案">解决方案</h4><p>使用add_header指令，该指令可以用来添加一些头信息</p><table><thead><tr><th>语法</th><th>add_header name  value…</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>此处用来解决跨域问题，需要添加两个头信息，一个是<code>Access-Control-Allow-Origin</code>,<code>Access-Control-Allow-Methods</code></p><p>Access-Control-Allow-Origin: 直译过来是允许跨域访问的源地址信息，可以配置多个(多个用逗号分隔)，也可以使用<code>*</code>代表所有源</p><p>Access-Control-Allow-Methods:直译过来是允许跨域访问的请求方式，值可以为 GET POST PUT DELETE…,可以全部设置，也可以根据需要设置，多个用逗号分隔</p><p>具体配置方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /getUser&#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE;</span><br><span class="line">    default_type application/json;</span><br><span class="line">    return 200 &#x27;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;TOM&quot;,&quot;age&quot;:18&#125;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态资源防盗链">静态资源防盗链</h3><h4 id="什么是资源盗链">什么是资源盗链</h4><p>资源盗链指的是此内容不在自己服务器上，而是通过技术手段，绕过别人的限制将别人的内容放到自己页面上最终展示给用户。以此来盗取大网站的空间和流量。简而言之就是用别人的东西成就自己的网站。</p><p>效果演示</p><p>京东:<a href="https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg">https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg</a></p><p>百度:<a href="https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB">https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB</a></p><p>我们自己准备一个页面，在页面上引入这两个图片查看效果</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634086.png" alt=""></p><p>从上面的效果，可以看出来，下面的图片地址添加了防止盗链的功能，京东这边我们可以直接使用其图片。</p><h4 id="Nginx防盗链的实现原理：">Nginx防盗链的实现原理：</h4><p>了解防盗链的原理之前，我们得先学习一个HTTP的头信息Referer,当浏览器向web服务器发送请求的时候，一般都会带上Referer,来告诉浏览器该网页是从哪个页面链接过来的。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634087.png" alt=""></p><p>后台服务器可以根据获取到的这个Referer信息来判断是否为自己信任的网站地址，如果是则放行继续访问，如果不是则可以返回403(服务端拒绝访问)的状态信息。</p><p>在本地模拟上述的服务器效果：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211634088.png" alt=""></p><p>Nginx防盗链的具体实现:</p><p>valid_referers:nginx会通就过查看referer自动和valid_referers后面的内容进行匹配，如果匹配到了就将$invalid_referer变量置0，如果没有匹配到，则将$invalid_referer变量置为1，匹配的过程中不区分大小写。</p><table><thead><tr><th>语法</th><th>valid_referers none|blocked|server_names|string…</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location</td></tr></tbody></table><p>none: 如果Header中的Referer为空，允许访问</p><p>blocked:在Header中的Referer不为空，但是该值被防火墙或代理进行伪装过，如不带&quot;http://&quot; 、&quot;https://&quot;等协议头的资源允许访问。</p><p>server_names:指定具体的域名或者IP</p><p>string: 可以支持正则表达式和*的字符串。如果是正则表达式，需要以<code>~</code>开头表示，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~*\.(png|jpg|gif)&#123;</span><br><span class="line">           valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.*  www.example.org  ~\.google\.;</span><br><span class="line">           if ($invalid_referer)&#123;</span><br><span class="line">                return 403;</span><br><span class="line">           &#125;</span><br><span class="line">           root /usr/local/nginx/html;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到的问题:图片有很多，该如何批量进行防盗链？</p><h4 id="针对目录进行防盗链">针对目录进行防盗链</h4><p>配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">           valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.*  www.example.org  ~\.google\.;</span><br><span class="line">           if ($invalid_referer)&#123;</span><br><span class="line">                return 403;</span><br><span class="line">           &#125;</span><br><span class="line">           root /usr/local/nginx/html;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以对一个目录下的所有资源进行翻到了操作。</p><p>遇到的问题：Referer的限制比较粗，比如随意加一个Referer，上面的方式是无法进行限制的。那么这个问题改如何解决？</p><p>此处我们需要用到Nginx的第三方模块<code>ngx_http_accesskey_module</code>，第三方模块如何实现盗链，如果在Nginx中使用第三方模块的功能，这些我们在后面的Nginx的模块篇再进行详细的讲解。</p><h3 id="Rewrite功能配置-2">Rewrite功能配置</h3><p>Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。</p><p>注意:Nginx服务器的Rewrite功能的实现依赖于PCRE的支持，因此在编译安装Nginx服务器之前，需要安装PCRE库。Nginx使用的是ngx_http_rewrite_module模块来解析和处理Rewrite功能的相关配置。</p><h4 id="“地址重写-与-地址转发”">“地址重写&quot;与&quot;地址转发”</h4><p>重写和转发的区别:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">地址重写浏览器地址会发生变化而地址转发则不变</span><br><span class="line">一次地址重写会产生两次请求而一次地址转发只会产生一次请求</span><br><span class="line">地址重写到的页面必须是一个完整的路径而地址转发则不需要</span><br><span class="line">地址重写因为是两次请求所以request范围内属性不能传递给新页面而地址转发因为是一次请求所以可以传递值</span><br><span class="line">地址转发速度快于地址重写</span><br></pre></td></tr></table></figure><h4 id="Rewrite规则">Rewrite规则</h4><h4 id="set指令-2">set指令</h4><p>该指令用来设置一个新的变量。</p><table><thead><tr><th>语法</th><th>set $variable value;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>variable:变量的名称，该变量名称要用&quot;$&quot;作为变量的第一个字符，且不能与Nginx服务器预设的全局变量同名。</p><p>value:变量的值，可以是字符串、其他变量或者变量的组合等。</p><h4 id="Rewrite常用全局变量-2">Rewrite常用全局变量</h4><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$args</td><td>变量中存放了请求URL中的请求指令。比如http://192.168.200.133:8080?arg1=value1&amp;args2=value2中的&quot;arg1=value1&amp;arg2=value2&quot;，功能和$query_string一样</td></tr><tr><td>$http_user_agent</td><td>变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息)</td></tr><tr><td>$host</td><td>变量存储的是访问服务器的server_name值</td></tr><tr><td>$document_uri</td><td>变量存储的是当前访问地址的URI。比如http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server&quot;，功能和$uri一样</td></tr><tr><td>$document_root</td><td>变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置</td></tr><tr><td>$content_length</td><td>变量存储的是请求头中的Content-Length的值</td></tr><tr><td>$content_type</td><td>变量存储的是请求头中的Content-Type的值</td></tr><tr><td>$http_cookie</td><td>变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie 'cookieName=cookieValue’来添加cookie数据</td></tr><tr><td>$limit_rate</td><td>变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。</td></tr><tr><td>$remote_addr</td><td>变量中存储的是客户端的IP地址</td></tr><tr><td>$remote_port</td><td>变量中存储了客户端与服务端建立连接的端口号</td></tr><tr><td>$remote_user</td><td>变量中存储了客户端的用户名，需要有认证模块才能获取</td></tr><tr><td>$scheme</td><td>变量中存储了访问协议</td></tr><tr><td>$server_addr</td><td>变量中存储了服务端的地址</td></tr><tr><td>$server_name</td><td>变量中存储了客户端请求到达的服务器的名称</td></tr><tr><td>$server_port</td><td>变量中存储了客户端请求到达服务器的端口号</td></tr><tr><td>$server_protocol</td><td>变量中存储了客户端请求协议的版本，比如&quot;HTTP/1.1&quot;</td></tr><tr><td>$request_body_file</td><td>变量中存储了发给后端服务器的本地文件资源的名称</td></tr><tr><td>$request_method</td><td>变量中存储了客户端的请求方式，比如&quot;GET&quot;,&quot;POST&quot;等</td></tr><tr><td>$request_filename</td><td>变量中存储了当前请求的资源文件的路径名</td></tr><tr><td>$request_uri</td><td>变量中存储了当前请求的URI，并且携带请求参数，比如http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server?id=10&amp;name=zhangsan&quot;</td></tr></tbody></table><h4 id="if指令-2">if指令</h4><p>该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。</p><table><thead><tr><th>语法</th><th>if  (condition){…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location</td></tr></tbody></table><p>condition为判定条件，可以支持以下写法：</p><ol><li>变量名。如果变量名对应的值为空或者是0，if都判断为false,其他条件为true。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($param)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 使用&quot;=&quot;和&quot;!=&quot;比较变量和字符串是否相等，满足条件为true，不满足为false</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($request_method = POST)&#123;</span><br><span class="line">return 405;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：此处和Java不太一样的地方是字符串不需要添加引号。</p><ol start="3"><li><p>使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。变量与正则表达式之间使用&quot;~“,”~*“,”!~“,”!~*&quot;来连接。</p><p>&quot;~&quot;代表匹配正则表达式过程中区分大小写，</p><p>&quot;~*&quot;代表匹配正则表达式过程中不区分大小写</p><p>&quot;!~“和”!~*&quot;刚好和上面取相反值，如果匹配上返回false,匹配不上返回true</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE)&#123;</span><br><span class="line">#$http_user_agent的值中是否包含MSIE字符串，如果包含返回true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：正则表达式字符串一般不需要加引号，但是如果字符串中包含&quot;}“或者是”;&quot;等字符时，就需要把引号加上。</p><ol start="4"><li><p>判断请求的文件是否存在使用&quot;-f&quot;和&quot;!-f&quot;,</p><p>当使用&quot;-f&quot;时，如果请求的文件存在返回true，不存在返回false。</p><p>当使用&quot;!f&quot;时，如果请求文件不存在，但该文件所在目录存在返回true,文件和目录都不存在返回false,如果文件存在返回false</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (-f $request_filename)&#123;</span><br><span class="line">#判断请求的文件是否存在</span><br><span class="line">&#125;</span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">#判断请求的文件是否不存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>判断请求的目录是否存在使用&quot;-d&quot;和&quot;!-d&quot;,</p><p>当使用&quot;-d&quot;时，如果请求的目录存在，if返回true，如果目录不存在则返回false</p><p>当使用&quot;!-d&quot;时，如果请求的目录不存在但该目录的上级目录存在则返回true，该目录和它上级目录都不存在则返回false,如果请求目录存在也返回false.</p></li><li><p>判断请求的目录或者文件是否存在使用&quot;-e&quot;和&quot;!-e&quot;</p><p>当使用&quot;-e&quot;,如果请求的目录或者文件存在时，if返回true,否则返回false.</p><p>当使用&quot;!-e&quot;,如果请求的文件和文件所在路径上的目录都不存在返回true,否则返回false</p></li><li><p>判断请求的文件是否可执行使用&quot;-x&quot;和&quot;!-x&quot;</p><p>当使用&quot;-x&quot;,如果请求的文件可执行，if返回true,否则返回false</p><p>当使用&quot;!-x&quot;,如果请求文件不可执行，返回true,否则返回false</p></li></ol><h4 id="break指令-2">break指令</h4><p>该指令用于中断当前相同作用域中的其他Nginx配置。与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效。</p><table><thead><tr><th>语法</th><th>break;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$param</span>)&#123;</span><br><span class="line"><span class="built_in">set</span> <span class="variable">$id</span> <span class="variable">$1</span>;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">limit_rate 10k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="return指令-2">return指令</h4><p>该指令用于完成对请求的处理，直接向客户端返回响应状态代码。在return后的所有Nginx配置都是无效的。</p><table><thead><tr><th>语法</th><th>return code [text];<br/>return code URL;<br/>return URL;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>code:为返回给客户端的HTTP状态代理。可以返回的状态代码为0~999的任意HTTP状态代理</p><p>text:为返回给客户端的响应体内容，支持变量的使用</p><p>URL:为返回给客户端的URL地址</p><h4 id="rewrite指令-2">rewrite指令</h4><p>该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。</p><p>URL和URI的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI:统一资源标识符</span><br><span class="line">URL:统一资源定位符</span><br></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>rewrite regex replacement [flag];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>regex:用来匹配URI的正则表达式</p><p>replacement:匹配成功后，用于替换URI中被截取内容的字符串。如果该字符串是以&quot;http://&quot;或者&quot;https://&quot;开头的，则不会继续向下对URI进行其他处理，而是直接返回重写后的URI给客户端。</p><p>flag:用来设置rewrite对URI的处理行为，可选值有如下：</p><ul><li>last:</li><li>break</li><li>redirect</li><li>permanent</li></ul><h4 id="rewrite-log指令-2">rewrite_log指令</h4><p>该指令配置是否开启URL重写日志的输出功能。</p><table><thead><tr><th>语法</th><th>rewrite_log on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>rewrite_log off;</td></tr><tr><td>位置</td><td>http、server、location、if</td></tr></tbody></table><p>开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。</p><h3 id="Rewrite的案例-2">Rewrite的案例</h3><h4 id="域名跳转-2">域名跳转</h4><p>》问题分析</p><p>先来看一个效果，如果我们想访问京东网站，大家都知道我们可以输入<code>www.jd.com</code>,但是同样的我们也可以输入<code>www.360buy.com</code>同样也都能访问到京东网站。<a href="http://xn--www-w48dncyev1bq7fw6d70b44jz5j4kd0qj8rhqpcd0trr5az4ama9098f7p5f.360buy.com">这个其实是因为京东刚开始的时候域名就是www.360buy.com</a>，<a href="http://xn--www-0h9dlb801dguajcf733ef2c1t1a6tmysbxwf4x7h3yen6qvr1bmz3g.jd.com">后面由于各种原因把自己的域名换成了www.jd.com</a>, 虽然说域名变量，但是对于以前只记住了www.360buy.com的用户来说，我们如何把这部分用户也迁移到我们新域名的访问上来，针对于这个问题，我们就可以使用Nginx中Rewrite的域名跳转来解决。</p><p>》环境准备</p><ul><li>准备两个域名  <a href="http://www.360buy.com">www.360buy.com</a> | <a href="http://www.jd.com">www.jd.com</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.200.133 www.360buy.com</span><br><span class="line">192.168.200.133 www.jd.com</span><br></pre></td></tr></table></figure><ul><li>在/usr/local/nginx/html/hm目录下创建一个访问页面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到我们的网站&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>通过Nginx实现当访问www.访问到系统的首页</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.hm.com;</span><br><span class="line">location /&#123;</span><br><span class="line">root /usr/local/nginx/html/hm;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>》<a href="http://xn--Rewritewww-uk3sy9bh26b7i0mt9a.360buy.xn--comwww-rr3jj63oikt462cytej3e.jd.com">通过Rewrite完成将www.360buy.com的请求跳转到www.jd.com</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.360buy.com;</span><br><span class="line">rewrite ^/ http://www.jd.com permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题描述:如何在域名跳转的过程中携带请求的URI？</p><p>修改配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.itheima.com;</span><br><span class="line">rewrite ^(.*) http://www.hm.com$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题描述:我们除了上述说的www.jd.com 、www.360buy.com其实还有我们也可以通过www.jingdong.com来访问，那么如何通过Rewrite来实现多个域名的跳转?</p><p>添加域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">192.168.200.133 www.jingdong.com</span><br></pre></td></tr></table></figure><p>修改配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.360buy.com www.jingdong.com;</span><br><span class="line">rewrite ^(.*) http://www.jd.com$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="域名镜像-2">域名镜像</h4><p>上述案例中，<a href="http://xn--www-zr0f.360buy.com">将www.360buy.com</a> 和 <a href="http://www.jingdong.xn--comwww-rr3j0502ahnyazcd7uf.jd.com">www.jingdong.com都能跳转到www.jd.com</a>，那么www.jd.com我们就可以把它起名叫主域名，其他两个就是我们所说的镜像域名，当然如果我们不想把整个网站做镜像，只想为其中某一个子目录下的资源做镜像，我们可以在location块中配置rewrite功能，比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name rewrite.myweb.com;</span><br><span class="line">location ^~ /source1&#123;</span><br><span class="line">rewrite ^/resource1(.*) http://rewrite.myweb.com/web$1 last;</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /source2&#123;</span><br><span class="line">rewrite ^/resource2(.*) http://rewrite.myweb.com/web$1 last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="独立域名-2">独立域名</h4><p>一个完整的项目包含多个模块，比如购物网站有商品商品搜索模块、商品详情模块已经购物车模块等，那么我们如何为每一个模块设置独立的域名。</p><p>需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://search.hm.com  访问商品搜索模块</span><br><span class="line">http://item.hm.com  访问商品详情模块</span><br><span class="line">http://cart.hm.com  访问商品购物车模块</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name search.hm.com;</span><br><span class="line">rewrite ^(.*) http://www.hm.com/bbs$1 last;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 81;</span><br><span class="line">server_name item.hm.com;</span><br><span class="line">rewrite ^(.*) http://www.hm.com/item$1 last;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">listen 82;</span><br><span class="line">server_name cart.hm.com;</span><br><span class="line">rewrite ^(.*) http://www.hm.com/cart$1 last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="目录自动添加-2">目录自动添加&quot;/&quot;</h4><p>问题描述</p><p>通过一个例子来演示下问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要想访问上述资源，很简单，只需要通过http://192.168.200.133直接就能访问，地址后面不需要加/,但是如果将上述的配置修改为如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen80;</span><br><span class="line">server_name localhost;</span><br><span class="line">location /hm &#123;</span><br><span class="line">root html;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，要想访问上述资源，按照上述的访问方式，我们可以通过http://192.168.200.133/hm/来访问,但是如果地址后面不加斜杠，页面就会出问题。如果不加斜杠，Nginx服务器内部会自动做一个301的重定向，重定向的地址会有一个指令叫server_name_in_redirect on|off;来决定重定向的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果该指令为on</span><br><span class="line">重定向的地址为:  http://server_name/目录名/;</span><br><span class="line">如果该指令为off</span><br><span class="line">重定向的地址为:  http://原URL中的域名/目录名/;</span><br></pre></td></tr></table></figure><p>所以就拿刚才的地址来说，<a href="http://192.168.200.133/hm%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8A%A0%E6%96%9C%E6%9D%A0%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8C%89%E7%85%A7%E4%B8%8A%E8%BF%B0%E8%A7%84%E5%88%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E4%BB%A4server_name_in_redirect%E4%B8%BAon%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BA">http://192.168.200.133/hm如果不加斜杠，那么按照上述规则，如果指令server_name_in_redirect为on，则301重定向地址变为</a> <a href="http://localhost/hm/,%E5%A6%82%E6%9E%9C%E4%B8%BAoff%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BAhttp://192.168.200.133/ht/%E3%80%82%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%89%8D%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%B0%B1%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%82">http://localhost/hm/,如果为off，则301重定向地址变为http://192.168.200.133/ht/。后面这个是正常的，前面地址就有问题。</a></p><p>注意server_name_in_redirect指令在Nginx的0.8.48版本之前默认都是on，之后改成了off,所以现在我们这个版本不需要考虑这个问题，但是如果是0.8.48以前的版本并且server_name_in_redirect设置为on，我们如何通过rewrite来解决这个问题？</p><p>解决方案</p><p>我们可以使用rewrite功能为末尾没有斜杠的URL自动添加一个斜杠</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen80;</span><br><span class="line">server_name localhost;</span><br><span class="line">server_name_in_redirect on;</span><br><span class="line">location /hm &#123;</span><br><span class="line">if (-d $request_filename)&#123;</span><br><span class="line">rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并目录-2">合并目录</h4><p>搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提供目的网站的有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含URL的目录层级一般不要超过三层，否则的话不利于搜索引擎的搜索也给客户端的输入带来了负担，但是将所有的文件放在一个目录下又会导致文件资源管理混乱并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用rewrite如何解决上述问题?</p><p>举例，网站中有一个资源文件的访问路径时 /server/11/22/33/44/20.html,也就是说20.html存在于第5级目录下，如果想要访问该资源文件，客户端的URL地址就要写成 <code>http://www.web.name/server/11/22/33/44/20.html</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.web.name;</span><br><span class="line">location /server&#123;</span><br><span class="line">root html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个是非常不利于SEO搜索引擎优化的，同时客户端也不好记.使用rewrite我们可以进行如下配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.web.name;</span><br><span class="line">location /server&#123;</span><br><span class="line">rewrite ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /server/$1/$2/$3/$4/$5.html last;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的花，客户端只需要输入http://www.web.name/server-11-22-33-44-20.html就可以访问到20.html页面了。这里也充分利用了rewrite指令支持正则表达式的特性。</p><h4 id="防盗链-2">防盗链</h4><p>防盗链之前我们已经介绍过了相关的知识，在rewrite中的防盗链和之前将的原理其实都是一样的，只不过通过rewrite可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用rewrite将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。下面我们就通过根据文件类型实现防盗链的一个配置实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.web.com;</span><br><span class="line">locatin ~* ^.+\.(gif|jpg|png|swf|flv|rar|zip)$&#123;</span><br><span class="line">valid_referers none blocked server_names *.web.com;</span><br><span class="line">if ($invalid_referer)&#123;</span><br><span class="line">rewrite ^/ http://www.web.com/images/forbidden.png;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据目录实现防盗链配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www.web.com;</span><br><span class="line">location /file/&#123;</span><br><span class="line">root /server/file/;</span><br><span class="line">valid_referers none blocked server_names *.web.com;</span><br><span class="line">if ($invalid_referer)&#123;</span><br><span class="line">rewrite ^/ http://www.web.com/images/forbidden.png;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习（一）</title>
      <link href="/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%B8%80/"/>
      <url>/2022/04/21/Nginx%E5%AD%A6%E4%B9%A0%E5%85%B6%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx简介">Nginx简介</h2><h3 id="背景介绍">背景介绍</h3><p>Nginx（“engine x”）一个具有高性能的【HTTP】和【反向代理】的【WEB服务器】，同时也是一个【POP3/SMTP/IMAP代理服务器】，是由伊戈尔·赛索耶夫(俄罗斯人)使用C语言编写的，Nginx的第一个版本是2004年10月4号发布的0.1.0版本。另外值得一提的是伊戈尔·赛索耶夫将Nginx的源码进行了开源，这也为Nginx的发展提供了良好的保障。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613219.png" alt="1573470187616"></p><h4 id="名词解释">名词解释</h4><ol><li>WEB服务器：</li></ol><p>WEB服务器也叫网页服务器，英文名叫Web Server，主要功能是为用户提供网上信息浏览服务。</p><ol start="2"><li>HTTP:</li></ol><p>HTTP是超文本传输协议的缩写，是用于从WEB服务器传输超文本到本地浏览器的传输协议，也是互联网上应用最为广泛的一种网络协议。HTTP是一个客户端和服务器端请求和应答的标准，客户端是终端用户，服务端是网站，通过使用Web浏览器、网络爬虫或者其他工具，客户端发起一个到服务器上指定端口的HTTP请求。</p><ol start="3"><li>POP3/SMTP/IMAP：</li></ol><p>POP3(Post Offic Protocol 3)邮局协议的第三个版本，</p><p>SMTP(Simple Mail Transfer Protocol)简单邮件传输协议，</p><p>IMAP(Internet Mail Access Protocol)交互式邮件存取协议，</p><p>通过上述名词的解释，我们可以了解到Nginx也可以作为电子邮件代理服务器。</p><ol start="4"><li>反向代理</li></ol><p>正向代理</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613220.png" alt="1573489359728"></p><p>反向代理</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613222.png" alt="1573489653799"></p><h3 id="常见服务器对比">常见服务器对比</h3><p>在介绍这一节内容之前，我们先来认识一家公司叫Netcraft。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netcraft公司于1994年底在英国成立，多年来一直致力于互联网市场以及在线安全方面的咨询服务，其中在国际上最具影响力的当属其针对网站服务器、SSL市场所做的客观严谨的分析研究，公司官网每月公布的调研数据（Web Server Survey）已成为当今人们了解全球网站数量以及服务器市场分额情况的主要参考依据，时常被诸如华尔街杂志，英国BBC，Slashdot等媒体报道或引用。</span><br></pre></td></tr></table></figure><p>我们先来看一组数据，我们先打开Nginx的官方网站  <a href="http://nginx.org/">http://nginx.org/</a>,找到Netcraft公司公布的数据，对当前主流服务器产品进行介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613223.png" alt="1581394945120"></p><p>上面这张图展示了2019年全球主流Web服务器的市场情况，其中有Apache、Microsoft-IIS、google Servers、Nginx、Tomcat等，而我们在了解新事物的时候，往往习惯通过类比来帮助自己理解事物的概貌。所以下面我们把几种常见的服务器来给大家简单介绍下：</p><h4 id="IIS">IIS</h4><p>​全称(Internet Information Services)即互联网信息服务，是由微软公司提供的基于windows系统的互联网基本服务。windows作为服务器在稳定性与其他一些性能上都不如类UNIX操作系统，因此在需要高性能Web服务器的场合下，IIS可能就会被&quot;冷落&quot;.</p><h4 id="Tomcat">Tomcat</h4><p>​Tomcat是一个运行Servlet和JSP的Web应用软件，Tomcat技术先进、性能稳定而且开放源代码，因此深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。但是Tomcat天生是一个重量级的Web服务器，对静态文件和高并发的处理比较弱。</p><h4 id="Apache">Apache</h4><p>​Apache的发展时期很长，同时也有过一段辉煌的业绩。从上图可以看出大概在2014年以前都是市场份额第一的服务器。Apache有很多优点，如稳定、开源、跨平台等。但是它出现的时间太久了，在它兴起的年代，互联网的产业规模远远不如今天，所以它被设计成一个重量级的、不支持高并发的Web服务器。在Apache服务器上，如果有数以万计的并发HTTP请求同时访问，就会导致服务器上消耗大量能存，操作系统内核对成百上千的Apache进程做进程间切换也会消耗大量的CUP资源，并导致HTTP请求的平均响应速度降低，这些都决定了Apache不可能成为高性能的Web服务器。这也促使了Lighttpd和Nginx的出现。</p><h4 id="Lighttpd">Lighttpd</h4><p>​Lighttpd是德国的一个开源的Web服务器软件，它和Nginx一样，都是轻量级、高性能的Web服务器，欧美的业界开发者比较钟爱Lighttpd,而国内的公司更多的青睐Nginx，同时网上Nginx的资源要更丰富些。</p><h4 id="其他的服务器">其他的服务器</h4><p>Google Servers，Weblogic, Webshpere(IBM)…</p><p>经过各个服务器的对比，种种迹象都表明，Nginx将以性能为王。这也是我们为什么选择Nginx的理由。</p><h4 id="Nginx的优点">Nginx的优点</h4><h5 id="1-速度更快、并发更高">(1)速度更快、并发更高</h5><p>单次请求或者高并发请求的环境下，Nginx都会比其他Web服务器响应的速度更快。一方面在正常情况下，单次请求会得到更快的响应，另一方面，在高峰期(如有数以万计的并发请求)，Nginx比其他Web服务器更快的响应请求。Nginx之所以有这么高的并发处理能力和这么好的性能原因在于Nginx采用了多进程和I/O多路复用(epoll)的底层实现。</p><h5 id="2-配置简单，扩展性强">(2)配置简单，扩展性强</h5><p>Nginx的设计极具扩展性，它本身就是由很多模块组成，这些模块的使用可以通过配置文件的配置来添加。这些模块有官方提供的也有第三方提供的模块，如果需要完全可以开发服务自己业务特性的定制模块。</p><h5 id="3-高可靠性">(3)高可靠性</h5><p>Nginx采用的是多进程模式运行，其中有一个master主进程和N多个worker进程，worker进程的数量我们可以手动设置，每个worker进程之间都是相互独立提供服务，并且master主进程可以在某一个worker进程出错时，快速去&quot;拉起&quot;新的worker进程提供服务。</p><h5 id="4-热部署">(4)热部署</h5><p>现在互联网项目都要求以7*24小时进行服务的提供，针对于这一要求，Nginx也提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级、更新配置和更换日志文件等功能。</p><h5 id="5-成本低、BSD许可证">(5)成本低、BSD许可证</h5><p>BSD是一个开源的许可证，世界上的开源许可证有很多，现在比较流行的有六种分别是GPL、BSD、MIT、Mozilla、Apache、LGPL。这六种的区别是什么，我们可以通过下面一张图来解释下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613224.png" alt="1585139995444"></p><p>Nginx本身是开源的，我们不仅可以免费的将Nginx应用在商业领域，而且还可以在项目中直接修改Nginx的源码来定制自己的特殊要求。这些点也都是Nginx为什么能吸引无数开发者继续为Nginx来贡献自己的智慧和青春。OpenRestry [Nginx+Lua]   Tengine[淘宝]</p><h3 id="Nginx的功能特性及常用功能">Nginx的功能特性及常用功能</h3><p>Nginx提供的基本功能服务从大体上归纳为&quot;基本HTTP服务&quot;、“高级HTTP服务”和&quot;邮件服务&quot;等三大类。</p><h4 id="基本HTTP服务">基本HTTP服务</h4><p>Nginx可以提供基本HTTP服务，可以作为HTTP代理服务器和反向代理服务器，支持通过缓存加速访问，可以完成简单的负载均衡和容错，支持包过滤功能，支持SSL等。</p><ul><li>处理静态文件、处理索引文件以及支持自动索引；</li><li>提供反向代理服务器，并可以使用缓存加上反向代理，同时完成负载均衡和容错；</li><li>提供对FastCGI、memcached等服务的缓存机制，，同时完成负载均衡和容错；</li><li>使用Nginx的模块化特性提供过滤器功能。Nginx基本过滤器包括gzip压缩、ranges支持、chunked响应、XSLT、SSI以及图像缩放等。其中针对包含多个SSI的页面，经由FastCGI或反向代理，SSI过滤器可以并行处理。</li><li>支持HTTP下的安全套接层安全协议SSL.</li><li>支持基于加权和依赖的优先权的HTTP/2</li></ul><h4 id="高级HTTP服务">高级HTTP服务</h4><ul><li>支持基于名字和IP的虚拟主机设置</li><li>支持HTTP/1.0中的KEEP-Alive模式和管线(PipeLined)模型连接</li><li>自定义访问日志格式、带缓存的日志写操作以及快速日志轮转。</li><li>提供3xx~5xx错误代码重定向功能</li><li>支持重写（Rewrite)模块扩展</li><li>支持重新加载配置以及在线升级时无需中断正在处理的请求</li><li>支持网络监控</li><li>支持FLV和MP4流媒体传输</li></ul><h4 id="邮件服务">邮件服务</h4><p>Nginx提供邮件代理服务也是其基本开发需求之一，主要包含以下特性：</p><ul><li>支持IMPA/POP3代理服务功能</li><li>支持内部SMTP代理服务功能</li></ul><h4 id="Nginx常用的功能模块">Nginx常用的功能模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">静态资源部署</span><br><span class="line">Rewrite地址重写</span><br><span class="line">正则表达式</span><br><span class="line">反向代理</span><br><span class="line">负载均衡</span><br><span class="line">轮询、加权轮询、ip_hash、url_hash、fair</span><br><span class="line">Web缓存</span><br><span class="line">环境部署</span><br><span class="line">高可用的环境</span><br><span class="line">用户认证模块...</span><br></pre></td></tr></table></figure><p>Nginx的核心组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx二进制可执行文件</span><br><span class="line">nginx.conf配置文件</span><br><span class="line">error.log错误的日志记录</span><br><span class="line">access.log访问日志记录</span><br></pre></td></tr></table></figure><h2 id="Nginx环境准备">Nginx环境准备</h2><h3 id="Nginx版本介绍">Nginx版本介绍</h3><p>Nginx的官方网站为: <a href="http://nginx.org">http://nginx.org</a></p><p>打开源码可以看到如下的页面内容</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613225.png" alt="1580461114467"></p><p>Nginx的官方下载网站为<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a>，当然你也可以之间在首页选中右边的download进入版本下载网页。在下载页面我们会看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613226.png" alt="1580463222053"></p><h3 id="获取Nginx源码">获取Nginx源码</h3><p><a href="http://nginx.org/download/">http://nginx.org/download/</a></p><p>打开上述网站，就可以查看到Nginx的所有版本，选中自己需要的版本进行下载。下载我们可以直接在windows上下载然后上传到服务器，也可以直接从服务器上下载，这个时候就需要准备一台服务器。</p><h3 id="1580610584036"><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613227.png" alt="1580610584036"></h3><h3 id="准备服务器系统">准备服务器系统</h3><p>环境准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VMware WorkStation</span><br><span class="line">Centos7</span><br><span class="line">MobaXterm</span><br><span class="line">xsheel,SecureCRT</span><br><span class="line">网络</span><br></pre></td></tr></table></figure><p>(1)确认centos的内核</p><p>准备一个内核为2.6及以上版本的操作系统，因为linux2.6及以上内核才支持epoll,而Nginx需要解决高并发压力问题是需要用到epoll，所以我们需要有这样的版本要求。</p><p>我们可以使用<code>uname -a</code>命令来查询linux的内核版本。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613228.png" alt="1581416022481"></p><p>(2)确保centos能联网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613229.png" alt="1585224061192"></p><p>(3)确认关闭防火墙</p><p>这一项的要求仅针对于那些对linux系统的防火墙设置规则不太清楚的，建议大家把防火墙都关闭掉，因为我们此次课程主要的内容是对Nginx的学习，把防火墙关闭掉，可以省掉后续Nginx学习过程中遇到的诸多问题。</p><p>关闭的方式有如下两种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld      关闭运行的防火墙，系统重新启动后，防火墙将重新打开</span><br><span class="line">systemctl disable firewalld   永久关闭防火墙，，系统重新启动后，防火墙依然关闭</span><br><span class="line">systemctl status firewalld 查看防火墙状态</span><br></pre></td></tr></table></figure><p>（4）确认停用selinux</p><p>selinux(security-enhanced linux),美国安全局对于强制访问控制的实现，在linux2.6内核以后的版本中，selinux已经成功内核中的一部分。可以说selinux是linux史上最杰出的新安全子系统之一。虽然有了selinux，我们的系统会更安全，但是对于我们的学习Nginx的历程中，会多很多设置，所以这块建议大家将selinux进行关闭。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613230.png" alt=""></p><p>sestatus查看状态</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613231.png" alt="1581419845687"></p><p>如果查看不是disabled状态，我们可以通过修改配置文件来进行设置,修改SELINUX=disabled，然后重启下系统即可生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613232.png" alt="1581419902873"></p><h3 id="Nginx安装方式介绍">Nginx安装方式介绍</h3><p>Nginx的安装方式有两种分别是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过Nginx源码</span><br><span class="line">通过Nginx源码简单安装 (1)</span><br><span class="line">通过Nginx源码复杂安装 (3)</span><br><span class="line">通过yum安装 (2)</span><br></pre></td></tr></table></figure><p>如果通过Nginx源码安装需要提前准备的内容：</p><h5 id="GCC编译器">GCC编译器</h5><p>Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。</p><p>使用命令<code>yum install -y gcc</code>来安装</p><p>安装成功后，可以通过<code>gcc --version</code>来查看gcc是否安装成功</p><h5 id="PCRE">PCRE</h5><p>Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。</p><p>可以使用命令<code>yum install -y pcre pcre-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa pcre pcre-devel</code>来查看是否安装成功</p><h5 id="zlib">zlib</h5><p>zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel</p><p>可以使用命令<code>yum install -y zlib zlib-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa zlib zlib-devel</code>来查看是否安装成功</p><h5 id="OpenSSL">OpenSSL</h5><p>OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p><p>SSL:Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。</p><p>可以使用命令<code>yum install -y openssl openssl-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa openssl openssl-devel</code>来查看是否安装成功</p><p>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装</p><p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code>进行全部安装。</p><h4 id="方案一：Nginx的源码简单安装">方案一：Nginx的源码简单安装</h4><p>(1)进入官网查找需要下载版本的链接地址，然后使用wget命令进行下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><p>(2)建议大家将下载的资源进行包管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p nginx/core</span><br><span class="line">mv nginx-1.16.1.tar.gz nginx/core</span><br></pre></td></tr></table></figure><p>(3)解压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><p>(4)进入资源文件中，发现configure</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>(5)编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>(6)安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="方案二：yum安装">方案二：yum安装</h4><p>使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备GCC编译器、PCRE兼容正则表达式库、zlib压缩库、OpenSSL安全通信的软件库包，然后才能进行Nginx的安装。</p><p>（1）安装yum-utils</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum  install -y yum-utils</span><br></pre></td></tr></table></figure><p>（2）添加yum源文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure><p>（3）查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613233.png" alt="1581416861684"></p><p>（4）使用yum进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yun install -y nginx</span><br></pre></td></tr></table></figure><p>（5）查看nginx的安装位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613234.png" alt="1581416981939"></p><p>（6）启动测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/sbin</span><br><span class="line">./nginx</span><br><span class="line"><span class="comment">#浏览器打开IPADDR，出现nginx即为启动成功</span></span><br></pre></td></tr></table></figure><h4 id="源码简单安装和yum安装的差异：">源码简单安装和yum安装的差异：</h4><p>这里先介绍一个命令: <code>./nginx -V</code>,通过该命令可以查看到所安装Nginx的版本及相关配置信息。</p><p>简单安装</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613235.png" alt="1586016586042"></p><p>yum安装</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613236.png" alt="1586016605581"></p><h5 id="解压Nginx目录">解压Nginx目录</h5><p>执行<code>tar -zxvf nginx-1.16.1.tar.gz</code>对下载的资源进行解压缩，进入压缩后的目录，可以看到如下结构</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613237.png" alt="1581421319232"></p><p>内容解释：</p><p>auto:存放的是编译相关的脚本</p><p>CHANGES:版本变更记录</p><p><a href="http://CHANGES.ru">CHANGES.ru</a>:俄罗斯文的版本变更记录</p><p>conf:nginx默认的配置文件</p><p>configure:nginx软件的自动脚本程序,是一个比较重要的文件，作用如下：</p><p>​（1）检测环境及根据环境检测结果生成C代码</p><p>​（2）生成编译代码需要的Makefile文件</p><p>contrib:存放的是几个特殊的脚本文件，其中README中对脚本有着详细的说明</p><p>html:存放的是Nginx自带的两个html页面，访问Nginx的首页和错误页面</p><p>LICENSE:许可证的相关描述文件</p><p>man:nginx的man手册</p><p>README:Nginx的阅读指南</p><p>src:Nginx的源代码</p><h4 id="方案三-Nginx的源码复杂安装">方案三:Nginx的源码复杂安装</h4><p>这种方式和简单的安装配置不同的地方在第一步，通过<code>./configure</code>来对编译参数进行设置，需要我们手动来指定。那么都有哪些参数可以进行设置，接下来我们进行一个详细的说明。</p><p>PATH:是和路径相关的配置信息</p><p>with:是启动模块，默认是关闭的</p><p>without:是关闭模块，默认是开启的</p><p>我们先来认识一些简单的路径配置已经通过这些配置来完成一个简单的编译：</p><p>–prefix=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx的安装目录，默认值为/usr/local/nginx   </span><br></pre></td></tr></table></figure><p>–sbin-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向(执行)程序文件(nginx)的路径,默认值为&lt;prefix&gt;/sbin/nginx</span><br></pre></td></tr></table></figure><p>–modules-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx动态模块安装目录，默认值为&lt;prefix&gt;/modules</span><br></pre></td></tr></table></figure><p>–conf-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向配置文件(nginx.conf)的路径,默认值为&lt;prefix&gt;/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>–error-log-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向错误日志文件的路径,默认值为&lt;prefix&gt;/logs/error.log</span><br></pre></td></tr></table></figure><p>–http-log-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向访问日志文件的路径,默认值为&lt;prefix&gt;/logs/access.log</span><br></pre></td></tr></table></figure><p>–pid-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx启动后进行ID的文件路径，默认值为&lt;prefix&gt;/logs/nginx.pid</span><br></pre></td></tr></table></figure><p>–lock-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx锁文件的存放路径,默认值为&lt;prefix&gt;/logs/nginx.lock</span><br></pre></td></tr></table></figure><p>要想使用可以通过如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx \</span><br><span class="line">--sbin-path=/usr/local/nginx/sbin/nginx \</span><br><span class="line">--modules-path=/usr/local/nginx/modules \</span><br><span class="line">--conf-path=/usr/local/nginx/conf/nginx.conf \</span><br><span class="line">--error-log-path=/usr/local/nginx/logs/error.log \</span><br><span class="line">--http-log-path=/usr/local/nginx/logs/access.log \</span><br><span class="line">--pid-path=/usr/local/nginx/logs/nginx.pid \</span><br><span class="line">--lock-path=/usr/local/nginx/logs/nginx.lock</span><br></pre></td></tr></table></figure><p>在使用上述命令之前，需要将之前服务器已经安装的nginx进行卸载，卸载的步骤分为三步骤：</p><p>步骤一：需要将nginx的进程关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure><p>步骤二:将安装的nginx进行删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/local/nginx</span><br></pre></td></tr></table></figure><p>步骤三:将安装包之前编译的环境清除掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><h3 id="Nginx目录结构分析">Nginx目录结构分析</h3><p>在使用Nginx之前，我们先对安装好的Nginx目录文件进行一个分析，在这块给大家介绍一个工具tree，通过tree我们可以很方面的去查看centos系统上的文件目录结构，当然，如果想使用tree工具，就得先通过<code>yum install -y tree</code>来进行安装，安装成功后，可以通过执行<code>tree /usr/local/nginx</code>(tree后面跟的是Nginx的安装目录)，获取的结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613238.png" alt="1581439634265"></p><p>conf:nginx所有配置文件目录</p><p>​    CGI(Common Gateway Interface)通用网关【接口】，主要解决的问题是从客户端发送一个请求和数据，服务端获取到请求和数据后可以调用调用CGI【程序】处理及相应结果给客户端的一种标准规范。</p><p>​fastcgi.conf:fastcgi相关配置文件</p><p>​fastcgi.conf.default:fastcgi.conf的备份文件</p><p>​fastcgi_params:fastcgi的参数文件</p><p>​fastcgi_params.default:fastcgi的参数备份文件</p><p>​scgi_params:scgi的参数文件</p><p>​scgi_params.default：scgi的参数备份文件</p><p>​    uwsgi_params:uwsgi的参数文件</p><p>​uwsgi_params.default:uwsgi的参数备份文件</p><p>​mime.types:记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系</p><p>​mime.types.default:mime.types的备份文件</p><p>​nginx.conf:这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点</p><p>​nginx.conf.default:nginx.conf的备份文件</p><p>​koi-utf、koi-win、win-utf这三个文件都是与编码转换映射相关的配置文件，用来将一种编码转换成另一种编码</p><p>html:存放nginx自带的两个静态的html页面</p><p>​50x.html:访问失败后的失败页面</p><p>​index.html:成功访问的默认首页</p><p>logs:记录入门的文件，当nginx服务器启动后，这里面会有 access.log error.log 和nginx.pid三个文件出现。</p><p>sbin:是存放执行程序文件nginx</p><p>​nginx是用来控制Nginx的启动和停止等相关的命令。</p><h3 id="Nginx服务器启停命令">Nginx服务器启停命令</h3><p>Nginx安装完成后，接下来我们要学习的是如何启动、重启和停止Nginx的服务。</p><p>对于Nginx的启停在linux系统中也有很多种方式，我们本次课程介绍两种方式：</p><ol><li><p>Nginx服务的信号控制</p></li><li><p>Nginx的命令行控制</p></li></ol><h4 id="方式一-Nginx服务的信号控制">方式一:Nginx服务的信号控制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nginx中的master和worker进程?</span><br><span class="line">Nginx的工作方式?</span><br><span class="line">如何获取进程的PID?</span><br><span class="line">信号有哪些?</span><br><span class="line">如何通过信号控制Nginx的启停等相关操作?</span><br></pre></td></tr></table></figure><p>前面在提到Nginx的高性能，其实也和它的架构模式有关。Nginx默认采用的是多进程的方式来工作的，当将Nginx启动后，我们通过<code>ps -ef | grep nginx</code>命令可以查看到如下内容：</p><blockquote><p>ps 命令 ：获取正在运行进程信息</p><p>grep：过滤nginx相关命令</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613239.png" alt="1581444289294"></p><p>从上图中可以看到,Nginx后台进程中包含一个master进程和多个worker进程，master进程主要用来管理worker进程，包含接收外界的信息，并将接收到的信号发送给各个worker进程，监控worker进程的状态，当worker进程出现异常退出后，会自动重新启动新的worker进程。而worker进程则是专门用来处理用户请求的，各个worker进程之间是平等的并且相互独立，处理请求的机会也是一样的。nginx的进程模型，我们可以通过下图来说明下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613240.png" alt="1581444603231"></p><p>我们现在作为管理员，只需要通过给master进程发送信号就可以来控制Nginx,这个时候我们需要有两个前提条件，一个是要操作的master进程，一个是信号。</p><p>（1）要想操作Nginx的master进程，就需要获取到master进程的进程号ID。获取方式简单介绍两个，</p><p>方式一：通过<code>ps -ef | grep nginx</code>；</p><p>方式二：在讲解nginx的<code>./configure</code>的配置参数的时候，有一个参数是<code>--pid-path=PATH</code>默认是<code>/usr/local/nginx/logs/nginx.pid</code>,所以可以通过查看该文件来获取nginx的master进程ID.</p><p>（2）信号</p><table><thead><tr><th>信号</th><th>作用</th></tr></thead><tbody><tr><td>TERM/INT</td><td>立即关闭整个服务</td></tr><tr><td>QUIT</td><td>&quot;优雅&quot;地关闭整个服务</td></tr><tr><td>HUP</td><td>重读配置文件并使用服务对新配置项生效</td></tr><tr><td>USR1</td><td>重新打开日志文件，可以用来进行日志切割</td></tr><tr><td>USR2</td><td>平滑升级到最新版的nginx</td></tr><tr><td>WINCH</td><td>所有子进程不在接收处理新连接，相当于给work进程发送QUIT指令</td></tr></tbody></table><p>调用命令为<code>kill -signal PID</code></p><blockquote><p>例如 kill -TERM 20211</p></blockquote><p>signal:即为信号；PID即为获取到的master线程ID</p><ol><li>发送TERM/INT信号给master进程，会将Nginx服务立即关闭。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -TERM PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class="line">kill -INT PID / kill -INT `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="2"><li>发送QUIT信号给master进程，master进程会控制所有的work进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="3"><li>发送HUP信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="4"><li>发送USR1信号给master进程，告诉Nginx重新开启日志文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR1 PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="5"><li>发送USR2信号给master进程，告诉master进程要平滑升级，这个时候，会重新开启对应的master进程和work进程，整个系统中将会有两个master进程，并且新的master进程的PID会被记录在<code>/usr/local/nginx/logs/nginx.pid</code>而之前的旧的master进程PID会被记录在<code>/usr/local/nginx/logs/nginx.pid.oldbin</code>文件中，接着再次发送QUIT信号给旧的master进程，让其处理完请求后再进行关闭</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 PID / kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT PID / kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613241.png" alt="1586368250085"></p><ol start="6"><li>发送WINCH信号给master进程,让master进程控制不让所有的work进程在接收新的请求了，请求处理完后关闭work进程。注意master进程不会被关闭掉</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH PID /kill -WINCH`cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><h4 id="方式二-Nginx的命令行控制">方式二:Nginx的命令行控制</h4><p>此方式是通过Nginx安装目录下的sbin下的可执行文件nginx来进行Nginx状态的控制，我们可以通过<code>nginx -h</code>来查看都有哪些参数可以用：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613242.png" alt="1581486604517"></p><p>-?和-h:显示帮助信息</p><p>-v:打印版本号信息并退出</p><p>-V:打印版本号信息和配置信息并退出</p><p>-t:测试nginx的配置文件语法是否正确并退出</p><p>-T:测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出</p><p>-q:在配置测试期间禁止显示非错误消息</p><p>-s:signal信号，后面可以跟 ：</p><p>​ stop[快速关闭，类似于TERM/INT信号的作用]</p><p>​quit[优雅的关闭，类似于QUIT信号的作用]</p><p>​reopen[重新打开日志文件类似于USR1信号的作用]</p><p>​reload[类似于HUP信号的作用]</p><p>-p:prefix，指定Nginx的prefix路径，(默认为: /usr/local/nginx/)</p><p>-c:filename,指定Nginx的配置文件路径,(默认为: conf/nginx.conf)</p><p>-g:用来补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</p><h3 id="Nginx服务器版本升级和新增模块">Nginx服务器版本升级和新增模块</h3><p>如果想对Nginx的版本进行更新，或者要应用一些新的模块，最简单的做法就是停止当前的Nginx服务，然后开启新的Nginx服务。但是这样会导致在一段时间内，用户是无法访问服务器。为了解决这个问题，我们就需要用到Nginx服务器提供的平滑升级功能。这个也是Nginx的一大特点，使用这种方式，就可以使Nginx在7*24小时不间断的提供服务了。接下来我们分析下需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：Nginx的版本最开始使用的是Nginx-1.14.2,由于服务升级，需要将Nginx的版本升级到Nginx-1.16.1,要求Nginx不能中断提供服务。</span><br></pre></td></tr></table></figure><p>为了应对上述的需求，这里我们给大家提供两种解决方案:</p><p>方案一:使用Nginx服务信号完成Nginx的升级</p><p>方案二:使用Nginx安装目录的make命令完成升级</p><h4 id="环境准备">环境准备</h4><p>（1）先准备两个版本的Nginx分别是 1.14.2和1.16.1</p><p>（2）使用Nginx源码安装的方式将1.14.2版本安装成功并正确访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入安装目录</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>（3）将Nginx1.16.1进行参数配置和编译，不需要进行安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入安装目录</span><br><span class="line">./configure</span><br><span class="line">make </span><br></pre></td></tr></table></figure><h4 id="方案一-使用Nginx服务信号进行升级">方案一:使用Nginx服务信号进行升级</h4><p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">mv nginx nginxold</span><br></pre></td></tr></table></figure><p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/nginx/core/nginx-1.16.1/objs</span><br><span class="line">cp nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>第三步:发送信号USR2给Nginx的1.14.2版本对应的master进程</p><p>第四步:发送信号QUIT给Nginx的1.14.2版本对应的master进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT `more /usr/local/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure><h4 id="方案二-使用Nginx安装目录的make命令完成升级">方案二:使用Nginx安装目录的make命令完成升级</h4><p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">mv nginx nginxold</span><br></pre></td></tr></table></figure><p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/nginx/core/nginx-1.16.1/objs</span><br><span class="line">cp nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>第三步:进入到安装目录，执行<code>make upgrade</code></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613243.png" alt="1581494652284"></p><p>第四步:查看是否更新成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -v</span><br></pre></td></tr></table></figure><p>在整个过程中，其实Nginx是一直对外提供服务的。并且当Nginx的服务器启动成功后，我们是可以通过浏览器进行直接访问的，同时我们可以通过更改html目录下的页面来修改我们在页面上所看到的内容，那么问题来了，为什么我们要修改html目录下的文件，能不能多添加一些页面是Nginx的功能更加丰富，还有前面聊到Nginx的前端功能又是如何来实现的，这就需要我们对Nginx的核心配置文件进行一个详细的学习。</p><h2 id="Nginx核心配置文件结构">Nginx核心配置文件结构</h2><p>从前面的内容学习中，我们知道Nginx的核心配置文件默认是放在<code>/usr/local/nginx/conf/nginx.conf</code>，这一节，我们就来学习下nginx.conf的内容和基本配置方法。</p><p>读取Nginx自带的Nginx配置文件，我们将其中的注释部分【学习一个技术点就是在Nginx的配置文件中可以使用<code>#</code>来注释】删除掉后，就剩下下面内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">指令名指令值;  #全局块，主要设置Nginx服务器整体运行的配置指令</span><br><span class="line"></span><br><span class="line"> #events块,主要设置,Nginx服务器与用户的网络连接,这一部分对Nginx服务器的性能影响较大</span><br><span class="line">events &#123; </span><br><span class="line">    指令名指令值;</span><br><span class="line">&#125;</span><br><span class="line">#http块，是Nginx服务器配置中的重要部分，代理、缓存、日志记录、第三方模块配置...             </span><br><span class="line">http &#123;</span><br><span class="line">    指令名指令值;</span><br><span class="line">    server &#123; #server块，是Nginx配置和虚拟主机相关的内容</span><br><span class="line">        指令名指令值;</span><br><span class="line">        location / &#123; </span><br><span class="line">        #location块，基于Nginx服务器接收请求字符串与location后面的值进行匹配，对特定请求进行处理</span><br><span class="line">            指令名指令值;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单小结下:</p><p>nginx.conf配置文件中默认有三大块：全局块、events块、http块</p><p>http块中可以配置多个server块，每个server块又可以配置多个location块。</p><h3 id="全局块">全局块</h3><h4 id="user指令">user指令</h4><p>（1）user:用于配置运行Nginx服务器的worker进程的用户和用户组。</p><table><thead><tr><th>语法</th><th>user user [group]</th></tr></thead><tbody><tr><td>默认值</td><td>nobody</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>该属性也可以在编译的时候指定，语法如下<code>./configure --user=user --group=group</code>,如果两个地方都进行了设置，最终生效的是配置文件中的配置。</p><p>该指令的使用步骤:</p><p>(1)设置一个用户信息&quot;www&quot;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user www;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613244.png" alt="1586597350943"></p><p>(2) 创建一个用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd www</span><br></pre></td></tr></table></figure><p>(3)修改user属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user www</span><br></pre></td></tr></table></figure><p>(4)创建<code>/root/html/index.html</code>页面，添加如下内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">35em</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-family</span>: Tahoma, Verdana, Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For online documentation and support please refer to</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;</span>nginx.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Commercial support is available at</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;</span>nginx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Thank you for using nginx.<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>I am WWW<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(5)修改nginx.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root   /root/html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5)测试启动访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面会报403拒绝访问的错误</span><br></pre></td></tr></table></figure><p>(6)分析原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为当前用户没有访问/root/html目录的权限</span><br></pre></td></tr></table></figure><p>(7)将文件创建到 <code>/home/www/html/index.html</code>,修改配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root   /home/www/html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(8)再次测试启动访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能正常访问。</span><br></pre></td></tr></table></figure><p>综上所述，使用user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全。</p><h4 id="work-process指令">work process指令</h4><p>master_process:用来指定是否开启工作进程。</p><table><thead><tr><th>语法</th><th>master_process on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>master_process on;</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>worker_processes:用于配置Nginx生成工作进程的数量，这个是Nginx服务器实现并发处理服务的关键所在。理论上来说workder process的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，建议将该值和服务器CPU的内核数保存一致。</p><table><thead><tr><th>语法</th><th>worker_processes     num/auto;</th></tr></thead><tbody><tr><td>默认值</td><td>1</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>如果将worker_processes设置成2，则会看到如下内容:</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613245.png" alt="1581563242526"></p><h4 id="其他指令">其他指令</h4><p>daemon：设定Nginx是否以守护进程的方式启动。</p><p>守护式进程是linux后台执行的一种服务进程，特点是独立于控制终端，不会随着终端关闭而停止。</p><table><thead><tr><th>语法</th><th>daemon on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>daemon on;</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>pid:用来配置Nginx当前master进程的进程号ID存储的文件路径。</p><table><thead><tr><th>语法</th><th>pid file;</th></tr></thead><tbody><tr><td>默认值</td><td>默认为:/usr/local/nginx/logs/nginx.pid</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>该属性可以通过<code>./configure --pid-path=PATH</code>来指定</p><p>error_log:用来配置Nginx的错误日志存放路径</p><table><thead><tr><th>语法</th><th>error_log  file [日志级别];</th></tr></thead><tbody><tr><td>默认值</td><td>error_log logs/error.log error;</td></tr><tr><td>位置</td><td>全局块、http、server、location</td></tr></tbody></table><p>该属性可以通过<code>./configure --error-log-path=PATH</code>来指定</p><p>其中日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg，翻译过来为试|信息|通知|警告|错误|临界|警报|紧急，这块建议大家设置的时候不要设置成info以下的等级，因为会带来大量的磁盘I/O消耗，影响Nginx的性能。</p><p>（5）include:用来引入其他配置文件，使Nginx的配置更加灵活</p><table><thead><tr><th>语法</th><th>include file;</th></tr></thead><tbody><tr><td>默认值</td><td>无</td></tr><tr><td>位置</td><td>any</td></tr></tbody></table><h3 id="events块">events块</h3><p>（1）accept_mutex:用来设置Nginx网络连接序列化</p><table><thead><tr><th>语法</th><th>accept_mutex on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>accept_mutex on;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>这个配置主要可以用来解决常说的&quot;惊群&quot;问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx后台是以多进程的工作模式，也就是说有多个worker进程会被同时唤醒，但是最终只会有一个进程可以获取到连接，如果每次唤醒的进程数目太多，就会影响Nginx的整体性能。如果将上述值设置为on(开启状态)，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204211613246.png" alt="1581566971955"></p><p>（2）multi_accept:用来设置是否允许同时接收多个网络连接</p><table><thead><tr><th>语法</th><th>multi_accept on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>multi_accept off;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</p><p>（3）worker_connections：用来配置单个worker进程最大的连接数</p><table><thead><tr><th>语法</th><th>worker_connections number;</th></tr></thead><tbody><tr><td>默认值</td><td>worker_commections 512;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外，number值不能大于操作系统支持打开的最大文件句柄数量。</p><p>（4）use:用来设置Nginx服务器选择哪种事件驱动来处理网络消息。</p><table><thead><tr><th>语法</th><th>use  method;</th></tr></thead><tbody><tr><td>默认值</td><td>根据操作系统定</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>注意：此处所选择事件处理模型是Nginx优化部分的一个重要内容，method的可选值有select/poll/epoll/kqueue等，之前在准备centos环境的时候，我们强调过要使用linux内核在2.6以上，就是为了能使用epoll函数来优化Nginx。</p><p>另外这些值的选择，我们也可以在编译的时候使用</p><p><code>--with-select_module</code>、<code>--without-select_module</code>、</p><p><code> --with-poll_module</code>、<code> --without-poll_module</code>来设置是否需要将对应的事件驱动模块编译到Nginx的内核。</p><h4 id="events指令配置实例">events指令配置实例</h4><p>打开Nginx的配置文件 nginx.conf,添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events&#123;</span><br><span class="line">accept_mutex on;</span><br><span class="line">multi_accept on;</span><br><span class="line">worker_commections 1024;</span><br><span class="line">use epoll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx -t</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="http块">http块</h3><h4 id="定义MIME-Type">定义MIME-Type</h4><p>我们都知道浏览器中可以显示的内容有HTML、XML、GIF等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用MIME Type。所以说MIME Type是网络资源的媒体类型。Nginx作为web服务器，也需要能够识别前端请求的资源类型。</p><p>在Nginx的配置文件中，默认有两行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br></pre></td></tr></table></figure><p>（1）default_type:用来配置Nginx响应前端请求默认的MIME类型。</p><table><thead><tr><th>语法</th><th>default_type mime-type;</th></tr></thead><tbody><tr><td>默认值</td><td>default_type text/plain；</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>在default_type之前还有一句<code>include mime.types</code>,include之前我们已经介绍过，相当于把mime.types文件中MIMT类型与相关类型文件的文件后缀名的对应关系加入到当前的配置文件中。</p><p>举例来说明：</p><p>有些时候请求某些接口的时候需要返回指定的文本字符串或者json字符串，如果逻辑非常简单或者干脆是固定的字符串，那么可以使用nginx快速实现，这样就不用编写程序响应请求了，可以减少服务器资源占用并且响应性能非常快。</p><p>如何实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /get_text &#123;</span><br><span class="line">#这里也可以设置成text/plain</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &quot;This is nginx&#x27;s text&quot;;</span><br><span class="line">&#125;</span><br><span class="line">location /get_json&#123;</span><br><span class="line">    default_type application/json;</span><br><span class="line">    return 200 &#x27;&#123;&quot;name&quot;:&quot;TOM&quot;,&quot;age&quot;:18&#125;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义服务日志">自定义服务日志</h4><p>Nginx中日志的类型分access.log、error.log。</p><p>access.log:用来记录用户所有的访问请求。</p><p>error.log:记录nginx本身运行时的错误信息，不会记录用户的访问请求。</p><p>Nginx服务器支持对服务日志的格式、大小、输出等进行设置，需要使用到两个指令，分别是access_log和log_format指令。</p><p>（1）access_log:用来设置用户访问日志的相关属性。</p><table><thead><tr><th>语法</th><th>access_log path[format[buffer=size]]</th></tr></thead><tbody><tr><td>默认值</td><td>access_log logs/access.log combined;</td></tr><tr><td>位置</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>（2）log_format:用来指定日志的输出格式。</p><table><thead><tr><th>语法</th><th>log_format name [escape=default|json|none] string…;</th></tr></thead><tbody><tr><td>默认值</td><td>log_format combined “…”;</td></tr><tr><td>位置</td><td>http</td></tr></tbody></table><h4 id="其他配置指令">其他配置指令</h4><p>（1）sendfile:用来设置Nginx服务器是否使用sendfile()传输文件，该属性可以大大提高Nginx处理静态资源的性能</p><table><thead><tr><th>语法</th><th>sendfile on|off；</th></tr></thead><tbody><tr><td>默认值</td><td>sendfile off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（2）keepalive_timeout:用来设置长连接的超时时间。</p><p>》为什么要使用keepalive？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们都知道HTTP是一种无状态协议，客户端向服务端发送一个TCP请求，服务端响应完毕后断开连接。</span><br><span class="line">如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。</span><br></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>keepalive_timeout time;</th></tr></thead><tbody><tr><td>默认值</td><td>keepalive_timeout 75s;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（3）keepalive_requests:用来设置一个keep-alive连接使用的次数。</p><table><thead><tr><th>语法</th><th>keepalive_requests number;</th></tr></thead><tbody><tr><td>默认值</td><td>keepalive_requests 100;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><h3 id="server块和location块">server块和location块</h3><p>server块和location块都是我们要重点讲解和学习的内容，因为我们后面会对Nginx的功能进行详细讲解，所以这块内容就放到静态资源部署的地方给大家详细说明。</p><p>本节我们主要来认识下Nginx默认给的nginx.conf中的相关内容，以及server块与location块在使用的时候需要注意的一些内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       server_name  localhost;</span><br><span class="line">       location / &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       error_page   500 502 503 504 404  /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">           root   html;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Centos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 安装 JAVA环境（JDK 1.8）</title>
      <link href="/2022/04/21/CentOS%207%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83%EF%BC%88JDK%201.8%EF%BC%89/"/>
      <url>/2022/04/21/CentOS%207%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83%EF%BC%88JDK%201.8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="卸载CentOS默认安装的OpenJDK">卸载CentOS默认安装的OpenJDK</h2><p>查看是否安装 OpenJDK</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_222&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_222-b10)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode)</span><br></pre></td></tr></table></figure><p>复制</p><p>查看安装位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br><span class="line">javamail-1.4.6-8.el7.noarch</span><br><span class="line">python-javapackages-3.4.1-11.el7.noarch</span><br><span class="line">tzdata-java-2019b-1.el7.noarch</span><br><span class="line">javapackages-tools-3.4.1-11.el7.noarch</span><br><span class="line">java-1.8.0-openjdk-headless-1.8.0.222.b10-0.el7_6.x86_64</span><br><span class="line">java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64</span><br><span class="line">javassist-3.16.1-10.el7.noarch</span><br><span class="line">java-1.8.0-openjdk-devel-1.8.0.222.b10-0.el7_6.x86_64</span><br></pre></td></tr></table></figure><p>复制</p><p>执行语句删除openjdk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-<span class="number">1.8</span><span class="number">.0</span>-openjdk-headless-<span class="number">1.8</span><span class="number">.0</span><span class="number">.222</span>.<span class="property">b10</span>-<span class="number">0.</span>el7_6.<span class="property">x86_64</span></span><br><span class="line">rpm -e --nodeps java-<span class="number">1.8</span><span class="number">.0</span>-openjdk-<span class="number">1.8</span><span class="number">.0</span><span class="number">.222</span>.<span class="property">b10</span>-<span class="number">0.</span>el7_6.<span class="property">x86_64</span></span><br><span class="line">rpm -e --nodeps java-<span class="number">1.8</span><span class="number">.0</span>-openjdk-devel-<span class="number">1.8</span><span class="number">.0</span><span class="number">.222</span>.<span class="property">b10</span>-<span class="number">0.</span>el7_6.<span class="property">x86_64</span></span><br></pre></td></tr></table></figure><p>复制</p><p>检查是否删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">-bash: /usr/bin/java: No such file or directory</span><br></pre></td></tr></table></figure><p>复制</p><h2 id="安装Oracle-Java-JDK-8">安装Oracle Java JDK 8</h2><p>从官网下载jdk-8u221-linux-x64.tar.gz。</p><p>下载后通过ftp上传到<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>。</p><p>创建目录，解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/java</span><br><span class="line">tar zvxf jdk-8u221-linux-x64.tar.gz -C /usr/java</span><br></pre></td></tr></table></figure><p>复制</p><p>环境配置，修改profile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="variable constant_">JAVA_HOME</span>=<span class="regexp">/usr/</span>java/jdk1<span class="number">.8</span><span class="number">.0_221</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span>=$JAVA_HOME/<span class="attr">bin</span>:$PATH</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">CLASSPATH</span>=.:$JAVA_HOME/lib/dt.<span class="property">jar</span>:$JAVA_HOME/lib/tools.<span class="property">jar</span></span><br></pre></td></tr></table></figure><p>复制</p><p>使环境变量生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>检查是否配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java version <span class="string">&quot;1.8.0_221&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_221-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</span><br></pre></td></tr></table></figure><p>复制</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在VMware上安装Centos7系统</title>
      <link href="/2022/04/19/%E5%9C%A8VMware%E4%B8%8A%E5%AE%89%E8%A3%85Centos7%E7%B3%BB%E7%BB%9F%E5%9C%A8VMware%E4%B8%8A%E5%AE%89%E8%A3%85Centos7%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/04/19/%E5%9C%A8VMware%E4%B8%8A%E5%AE%89%E8%A3%85Centos7%E7%B3%BB%E7%BB%9F%E5%9C%A8VMware%E4%B8%8A%E5%AE%89%E8%A3%85Centos7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本地虚拟机服务器，使用CentOs7，运维环境是<strong>宝塔面板</strong>。</p><h2 id="工具">工具</h2><ul><li><p>VMware Workstation Pro 15.5.5（虚拟机）</p></li><li><p>CentOs7（iso镜像）</p><p>阿里云镜像：<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a><br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712713.png" alt="image-20220419165325629"></p></li><li><p>Xshell（用于连接虚拟机，方便使用Linux命令，是一个远程工具，右键就可以复制粘贴，还可以拉滚动条。）</p></li></ul><hr><h2 id="虚拟机vmnet8-ip">虚拟机vmnet8 ip</h2><p><strong>虚拟机里面的虚拟网络需要设置一下</strong>，<strong>虚拟机里面的虚拟网络需要处理一下</strong>，<strong>虚拟机里面的虚拟网络需要编辑一下</strong>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712061.png" alt="Mm50BuAB58u6GHSRCrAxeBwY08ajBDwH.png"></p><p>下图标记2的地方，勾勾要去掉，去掉之后点击NAT设置，查看虚拟机的vmnet8 ip，把红框里的<strong>子网IP</strong>、<strong>子网掩码</strong>、<strong>默认网关</strong>用文本记下来，然后点击确定。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712865.png" alt="PEn1EY8Rp4CXs882PsaWz768yWBlF8Wk.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712146.png" alt="rLYAalNQwRaPAAxh3b7LkOGDdYfSVay2.png"></p><p>记住子网IP、子网掩码、网关</p><h2 id="创建虚拟机">创建虚拟机</h2><p>点击<code>创建新的虚拟机</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712049.png" alt="0.png"></p><p>点击<code>自定义</code>，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712808.png" alt="1.png"></p><p>选择虚拟机版本，我这里是15.5.5，下一步<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712070.png" alt="2.png"></p><p>点击<code>稍后安装操作系统</code>，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191712761.png" alt="3.png"></p><p>选择<code>Linux</code>操作系统，现在安装的是entOs7，所以版本选择<code>CentOs7 64位</code>，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191713052.png" alt="4.png"></p><p>虚拟机名称随意，可以中文，这里我写的是服务器ip名（可以重命名的），为了方便定位，不用我说都懂的啦，从左边栏就可以看出100、101、102没有102，哎？我跳过102了？我是把流程走一遍再码字的，码字的时候，服务器已经ok了，不过问题不大，下一步。。。。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191713668.png" alt="5.png"></p><p>默认（本站的核心是2个，但是我100、101都是1个核心，这里默认1个核心够用了），本地服务器，也就自己一个人访问，而且这里配置是跟本机电脑配置有关的，服务器一核心足矣（只要电脑带得动，给八核我也没意见），下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191713936.png" alt="6.png"></p><p>默认（本站的内存是1GB，但是我100、101都是2GB，这里默认1GB够用了），同上（<strong>如果在阿里云买服务器，我建议是1核心2GB内存哦</strong>），下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714588.png" alt="7.png"></p><p>点击<code>使用网络地址转换(NAT)</code>，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714018.png" alt="8.png"></p><p>默认，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714481.png" alt="9.png"></p><p>默认，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714407.png" alt="10.png"></p><p>默认，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714335.png" alt="11.png"></p><p>默认（磁盘大小自己改，20GB实际上够了，下面选项默认），下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714437.png" alt="12.png"></p><p>默认，下一步。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714655.png" alt="13.png"></p><p>点击<code>自定义硬件</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714920.png" alt="14.png"></p><p>点击<code>打印机</code>，然后点击<code>移除</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714673.png" alt="15.png"></p><p>跟着数字的步骤走（步骤3：选择下载好的CentOs7镜像，我个人是推荐放在服务器根目录下，看我图中的路径，这里不明白要留言哦）。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714326.png" alt="16.png"></p><p>点击<code>完成</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714239.png" alt="17.png"></p><hr><h2 id="安装CentOs7系统">安装CentOs7系统</h2><p>点击<code>开启此虚拟机</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714462.png" alt="18.png"></p><p>这里说一下，默认选中的是<code>Test this this media &amp; install CentOS 7</code>（白色字体是选中状态），按方向键↑然后回车（如果按键没效果，需要把鼠标点一下虚拟机显示屏）。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714864.png" alt="19.png"></p><p>中文在最下面，滚下去或者拉到下面才看到（下面的搜索<code>chinese</code>），点击<code>继续</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714708.png" alt="20.png"></p><p>这里看一下自己的日期和时间是不是<code>亚洲/上海 时区</code>，不是的话自己进去调一下（百度）。<br><img src="https://blog.langting.top/usr/uploads/2020/06/2155181254.png" alt="21.png"></p><p>点击<code>软件选择</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714484.png" alt="22.png"></p><p>把红框里的两个勾勾点上，完成。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714554.png" alt="23.png"></p><p>点击<code>安装位置</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714299.png" alt="24.png"></p><p>点击<code>我要配置分区</code>，完成。<br><img src="https://blog.langting.top/usr/uploads/2020/06/4292901772.png" alt="25.png"></p><p>点击<code>点这里自动创建他们</code>，完成。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191714322.png" alt="26.png"></p><p>默认，/boot（<strong>启动文件</strong>），swap（<strong>交换分区，类似windows虚拟内存</strong>。看内存总大小，如果内存足够大，这个空间就要设置很大，如果内存小于2G，那么这个空间设置成内存的2倍大小。），/（<strong>根分区</strong>），完成。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715634.png" alt="27.png"></p><p>点击<code>接受更改</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715050.png" alt="28.png"></p><p>点击<code>网络和主机名</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715373.png" alt="29.png"></p><p>打开<code>以太网</code>，修改主机名（也可以使用默认），然后点击应用（点完应用后看看以太网是不是关闭了，如果关闭了再点开），完成。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715616.png" alt="30.png"></p><p>点击<code>开始安装</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715811.png" alt="31.png"></p><p>点击<code>ROOT密码</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715529.png" alt="32.png"></p><p>设置密码，我这里设置<code>123456</code>（本机的，起个好记的就好），完成（点两次）。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715950.png" alt="33.png"></p><p>等待安装（根据自己的需求去创建用户吧，但是创建后<strong>可能</strong>某些操作需要root权限，不折腾就不要创了，昨晚搞CentOs8服务器差点崩溃，CentOs8是规定要创建用户的，CentOs7和CentOs8就跟windows7和windows10一样）。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715681.png" alt="34.png"></p><p>安装完毕，点击重启。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715879.png" alt="35.png"></p><p>选择第一个。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715084.png" alt="36.png"></p><p>我的用户名是<code>root</code>，密码<code>123456</code>。<br>输入用户名<code>root</code>，回车。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715081.png" alt="37.png"></p><p>输入密码<code>123456</code>（不可见的，输入就行了），回车。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715817.png" alt="38.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715567.png" alt="39.png"></p><hr><h2 id="配置服务器静态ip（需要配置服务器动态ip的自己百度一下）">配置服务器静态ip（需要配置服务器动态ip的自己百度一下）</h2><p>打开目录：<code>cd /etc/sysconfig/network-scripts/</code>（复制粘贴就好，这个复制粘贴有点麻烦，找不到的就手敲，正是这样才要用Xshell工具来远程，得先配置ip，忍一忍吧），回车。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715665.png" alt="40.png"></p><p>我这里显示的是ifcfg-ens33，这里要说一下，我百度过，有些是32，也有1667777，先用<code>cd /etc/sysconfig/network-scripts/</code>进入目录，然后<code>ll</code>显示列表（<code>ls</code>也可以显示列表，只显示列表名）。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715579.png" alt="41.png"></p><p>编辑ifcfg-ens33：<code>vi ifcfg-ens33</code>（vi：进入编辑模式，文件名别敲错。），回车。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715390.png" alt="42.png"></p><p>按 <strong>i</strong> 字母键进入编辑模式（如果不显示下图的，肯定是<code>vi ifcfg-ens33</code>输入错了，自己检查一下，退出vi方法：按Esc（注意左下角），输入<code>:q!</code>（不保存退出））。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715033.png" alt="43.png"></p><p>看图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#虚拟机IP相同，但是IPADDR后三位在3~240之间选择</span></span><br><span class="line">IPADDR=192.168.157.103</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.157.2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715855.png" alt="44.png"></p><p>保存并退出：按Esc键，然后输入<code>:wq</code>（必须小写），回车。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716011.png" alt="45.png"></p><p>重启网络：<code>systemctl restart network</code>，回车。<br>查看ip：<code>ip addr</code>， 回车。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191715505.png" alt="46.png"></p><h2 id="配置本地的网络（只需要配置一次）">配置本地的网络（只需要配置一次）</h2><p>这是本地访问虚拟机要配置的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#选择使用下面的IP地址,最后一位为 1 ，子网掩码自动生成</span></span><br><span class="line">IP=192.168.157.1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716004.png" alt="53.png"></p><h2 id="使用Xshell连接虚拟机服务器">使用Xshell连接虚拟机服务器</h2><p>新建会话，这里隧道要取消<code>转发X11连接到：</code><br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716695.png" alt="47.png"></p><p>新建会话，输入<code>IPADDR</code>名称<code>192.168.157.103</code>（输入名称后，下面的主机也是同步的。），然后点击连接。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716180.png" alt="48.png"></p><p>出现这个弹窗就说明99.99%成功了，如果没有就说明本地网络配置出错<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716984.png" alt="49.png"></p><p>输入用户名<code>root</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716597.png" alt="50.png"></p><p>输入用户名<code>123456</code>。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716408.png" alt="51.png"></p><p>okay。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716369.png" alt="52.png"></p><h2 id="安装宝塔面板">安装宝塔面板</h2><p>宝塔官网：<a href="https://www.bt.cn/">https://www.bt.cn/</a><br>宝塔Linux面板命令大全：<a href="https://www.bt.cn/btcode.html%EF%BC%88%E4%B8%80%E5%AE%9A%E8%A6%81%E5%A4%9A%E7%9C%8B%EF%BC%89">https://www.bt.cn/btcode.html（一定要多看）</a></p><p>这里标注几个常用的命令（本文章用到的）：<code>cd</code>、<code>clear</code>（清屏，也可以用Ctrl+L）、<code>ll</code>（当前列表，详细的展示列表），<code>ls</code>（当前列表，简洁的展示列表）、<code>vi</code> 文件名（编辑文件，按Esc：<code>:wq</code>保存并退出、<code>:q</code>（退出）、<code>:q!</code>强制不保存并退出）。</p><h3 id="安装">安装</h3><p>安装脚本：<code>yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</code><br>PS：<strong>此脚本从官方复制过来的时间为2020年6月19日，仅限CentOs系统，如果距离已久，请到官网复制</strong>。</p><p>右键随意复制粘贴，Xshell工具的好处（佛主：<a href="https://www.kancloud.cn/jiangguowu/kfjsdkfjskd/1076752%EF%BC%89%E3%80%82">https://www.kancloud.cn/jiangguowu/kfjsdkfjskd/1076752）。</a><br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716134.png" alt="54.png"></p><p><code>DO you want to install Bt Panel tothe /www directory now?(y/n):</code>（现在是否要将Bt面板安装到/www目录？（是/否）：）。<br>按y，回车。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716165.png" alt="55.png"></p><p>宝塔面板访问地址：<code>http://192.168.157.103:8888/7a81976f</code>，<code>119.137.3.117</code>换成<code>192.168.157.103</code>自己设置的服务器ip（别傻了，只有本地才能访问）。</p><p>username: <code>yq0g4uxd</code><br>password: <code>c937d4a9</code><br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716300.png" alt="56.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716243.png" alt="57.png"></p><p>点击<code>一键安装</code>（也可以不选择，然后自己去左边的软件商店自己选择安装）。<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716605.png" alt="58.png"></p><p>建议设置一下<strong>安全入口</strong>、<strong>面板用户</strong>、<strong>面板密码</strong>（只能设置8位数，为了方便，我强行使用命令行将密码设置为<code>123456</code>，命令：<code>cd /www/server/panel &amp;&amp; python tools.py panel 123456</code>，更多的宝塔命令请到宝塔Linux面板命令大全查看：<a href="https://blog.langting.top/usr/uploads/2020/06/1398140542.png">https://www.bt.cn/btcode.html</a>）<br><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204191716678.png" alt="59.png"></p><hr><h2 id="参考链接：">参考链接：</h2><ul><li><p>配置步骤：</p><ul><li><p><a href="https://www.cnblogs.com/langting/p/13167539.html">https://www.cnblogs.com/langting/p/13167539.html</a></p></li><li><p><a href="https://blog.langting.top/archives/117.html">https://blog.langting.top/archives/117.html</a></p></li></ul></li><li><p>虚拟机网络相关问题的解决</p><ul><li><a href="https://blog.csdn.net/weixin_44080445/article/details/110714332">https://blog.csdn.net/weixin_44080445/article/details/110714332</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Centos </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总览</title>
      <link href="/2022/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><p>CSDN总结：</p><ul><li><a href="https://blog.csdn.net/cooldragon/article/details/52164380">https://blog.csdn.net/cooldragon/article/details/52164380</a></li></ul><table><thead><tr><th style="text-align:center"><strong>范围</strong></th><th style="text-align:center"><strong>创建型</strong></th><th style="text-align:center"><strong>结构型</strong></th><th style="text-align:center">行为型</th></tr></thead><tbody><tr><td style="text-align:center"><strong>类</strong></td><td style="text-align:center">Factory Method（工厂方法）</td><td style="text-align:center">Adapter(类)（适配器）</td><td style="text-align:center">Interpreter（解释器）<br>Template Method（模版方法）</td></tr><tr><td style="text-align:center"><strong>对象</strong></td><td style="text-align:center">Abstract Factory（抽象工厂）<br>Builder（建造者）<br>Prototype（原型）<br>Singleton（单例）</td><td style="text-align:center">Adapter(对象)（适配器)<br>Bridge（桥接）<br>Composite（组合）<br>Decorator（装饰者）<br>Façade（外观）<br>Flyweight（享元）<br>Proxy（代理）</td><td style="text-align:center">Chain of Responsibility（职责链）<br>CoMmand（命令）<BR>Iterator（迭代器）<BR>Mediator（中介者）<BR>Memento（备忘录）<br>Observer（观察者）<br>State（状体）<BR>Strategy（策略）<br>Visitor（访问者）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记之Adapter（适配器）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BAdapter%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BAdapter%EF%BC%88%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Adapter（适配器）模式</h1><h2 id="意图">意图</h2><p>将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>注：适配器模式在详细设计阶段不需要考虑它，它是为了对现有系统或产品接口兼容时，也就是既成事实的情况下的<strong>补救措施</strong>。</p><h2 id="适用性">适用性</h2><ol><li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li></ol><ul><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li><li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ul><h2 id="结构">结构</h2><p><strong>类适配器模式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204021711585.png" alt=""></p><p><strong>对象适配器模式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204021712585.png" alt=""></p><h2 id="登场角色">登场角色</h2><ul><li><p>**Target (目标角色 对象，要用的接口) **</p><p>定义Client所需的方法。</p></li><li><p>**Client (使用场景 请求者) **</p><p>与符合Target接口的对象协同，使用Target角色定义的方法进行具体处理。</p></li><li><p>**Adaptee (被适配) **</p><p>定义一个已经存在的接角色，这个角色需要适配。</p></li><li><p><strong>Adapter (适配器，把Adaptee接口转换为Target可用的接口)</strong></p><p>对Adaptee的接口与Target接口进行适配</p></li></ul><h2 id="优点">优点</h2><ol><li><p>可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。</p></li><li><p>增加了类的透明性</p></li><li><p>提高了类的复用度</p></li><li><p>灵活性非常好</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记之Factory Method（工厂方法）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BFactory%EF%BC%88%E5%B7%A5%E5%8E%82%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BFactory%EF%BC%88%E5%B7%A5%E5%8E%82%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Factory Method（工厂方法）模式</h1><h2 id="意图-2">意图</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p><h2 id="适用性-2">适用性</h2><p>•  当一个类不知道它所必须创建的对象的类的时候。<br>•  当一个类希望由它的子类来指定它所创建的对象的时候。<br>•  当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><h2 id="结构-2">结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204061430619.png" alt=""></p><h2 id="登场角色-2">登场角色</h2><ul><li><p><strong>Product 产品</strong></p><p>定义工厂方法所创建的对象的接口。</p></li><li><p><strong>Creator 创建者</strong></p><p>声明工厂方法,该方法返回一个 Product类型的对象。 Creator也可以定义一个工厂方 法的缺省实现,它返回一个缺省的 ConcreteProduct对象。</p></li><li><p><strong>ConcreteProduct 具体的产品</strong></p><p>决定了具体的产品，实现Product接口。</p></li><li><p><strong>ConcreteCreator 具体的创建者</strong></p><p>负责生成具体的产品，重定义工厂方法以返回一个 ConcreteProduct实例。</p></li></ul><h2 id="优缺点">优缺点</h2><p><strong>优点：</strong><br>首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。</p><p>工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，可以使用产品子类替换产品父类。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记之Iterator（迭代器）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Iterator（迭代器）模式</h1><h2 id="意图-3">意图</h2><p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，即为遍历和实现可以分离开来。</p><h2 id="适用性-3">适用性</h2><ol><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。</li></ol><h2 id="结构-3">结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204021558441.png" alt="迭代器模式结构"></p><h2 id="登场角色-3">登场角色</h2><ul><li><p><strong>Iterator 迭代器</strong></p><p>负责定义访问和遍历元素的接口（API）。</p></li><li><p><strong>Concretelterator 具体的迭代器</strong></p><p>负责实现Iterator角色所定义的接口（API）。</p></li><li><p><strong>Aggregate 集合</strong></p><p>集合定义创建Iterator角色的接口，在示例程序中，由Aggregate接口扮演此角色，里面定义了Iterator方法。</p></li><li><p><strong>ConcreteAggregate 具体的集合</strong></p><p>负责实现Aggregate角色所定义的接口。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记之Template Method（模板方法）模式</title>
      <link href="/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BTemplate%EF%BC%88%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B9%8BTemplate%EF%BC%88%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size='6'>书本网盘链接😀</font></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye">https://pan.baidu.com/s/1KU0Ik8WTDn5fwBGvDd5dQw?pwd=rlye</a><br>提取码：rlye</p></blockquote><h1>Template Method（模板方法）模式</h1><h2 id="意图-4">意图</h2><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h2 id="适用性-4">适用性</h2><ul><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的 行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有 代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。</li></ul><h2 id="结构-4">结构</h2><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202204061409711.png" alt=""></p><h2 id="登场角色-4">登场角色</h2><ul><li><p>**AbstractClass(抽象类) **</p><p>负责实现模板方法，声明在模板方法中所使用到的抽象方法。这些抽象方法由子类ConcreteClass角色负责实现。</p></li><li><p>**ConcreteClass(具体类) **</p><p>负责具体实现AbstractClass角色中定义的抽象方法。</p></li></ul><h2 id="优点-2">优点</h2><ol><li><p>封装不变部分，扩展可变部分<br>把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。在悍马模型例子中，是不是就非常容易扩展？例如增加一个H3型号的悍马模型，很容易呀，增加一个子类，实现父类的基本方法就可以了。</p></li><li><p>提取公共部分代码，便于维护<br>我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！</p></li><li><p>行为由父类控制，子类实现<br>基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。</p></li></ol><h2 id="思考">思考</h2><p><strong>习题3-2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void diaplay()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractDisplay类中使用<code>final</code> 表示子类无法重写display方法。</p><p>不要重写模板方法</p><p><strong>习题3-4</strong></p><p>Java为什么不用接口代替抽象类？</p><p>因为此模式下AbstractClass角色必须实现部分处理流程。接口无法实现</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-084,085-单调栈-数组中的最大矩阵,最大矩阵</title>
      <link href="/2022/03/29/leetcode-42-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
      <url>/2022/03/29/leetcode-42-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p><p>​   ：<a href="https://leetcode-cn.com/problems/maximal-rectangle/">https://leetcode-cn.com/problems/maximal-rectangle/</a></p><p><strong>84. 解法一：暴力求解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为o(N^2)，提交结果超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="comment">//定义长度，返回值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>, n = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//确定宽</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//确定左边</span></span><br><span class="line">            <span class="keyword">for</span>(; left&gt;=<span class="number">0</span>; left--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[left] &lt; heights[i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确定右边</span></span><br><span class="line">            <span class="keyword">for</span>(; right&lt;n; right++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[right] &lt; heights[i])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算面积</span></span><br><span class="line">            area = Math.max(area,(heights[i] * (right - left -<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二：单调栈，用Deque数据结构</strong>（来自评论区大佬，太妙了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">       <span class="comment">// 这里为了代码简便，在柱体数组的头和尾加了两个高度为 0 的柱体。</span></span><br><span class="line">    <span class="comment">// arraycopy(源，起始，目标，目标起始，源长度)</span></span><br><span class="line">       <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">       System.arraycopy(heights, <span class="number">0</span>, tmp, <span class="number">1</span>, heights.length); </span><br><span class="line">       </span><br><span class="line">       Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line">           <span class="comment">// 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；</span></span><br><span class="line">           <span class="comment">// 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。</span></span><br><span class="line">           <span class="comment">// i是右边界</span></span><br><span class="line">           <span class="comment">// 因此以栈顶柱体为高的矩形的左右宽度边界就确定了，可以计算面积～</span></span><br><span class="line">           <span class="comment">//stack.peek()获得栈顶元素，stack.pop()获取栈顶元素并删除</span></span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; tmp[i] &lt; tmp[stack.peek()]) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> tmp[stack.pop()];</span><br><span class="line">               area = Math.max(area, (i - stack.peek() - <span class="number">1</span>) * h);   </span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> area;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>85. 解法</strong></p><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p>思路：转化为84中的求矩阵中的最大矩形，遍历，对每一行求高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//85-最大矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] heights = <span class="keyword">new</span> <span class="title class_">int</span>[row];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; col; i++)&#123;</span><br><span class="line">            <span class="comment">//遍历列，求高</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; row; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    heights[j] += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result,max(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//84</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] heights)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, temp, <span class="number">1</span>, heights.length);</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temp[i] &lt; temp[stack.peek()] )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> temp[stack.pop()];</span><br><span class="line">                area = Math.max(area,(i - stack.peek() - <span class="number">1</span>) * h);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配合Github Pages搭建个人博客</title>
      <link href="/2022/03/27/HI/"/>
      <url>/2022/03/27/HI/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>目前市面上有成熟的知识分享平台，例如CSDN、掘金等等，也可以被搜索引擎检索到。除此之外也可以自己搭建一个个人博客网站，主要使用的就是  <code>Hexo + GitPage</code>  的方式，本站主要使用 <code>GitHub Page + Hexo</code>搭建静态博客网站。</p><h2 id="GitHub-Pages-是什么？">GitHub Pages 是什么？</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//help.github.com/en/articles/what-is-github-pages">What is GitHub Pages? - GitHub Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h2 id="Hexo是什么？">Hexo是什么？</h2><ul><li>官网：<a href="https://hexo.io/zh-cn/">hexo.io</a></li></ul><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><h2 id="为什么使用Hexo-GitHub-Pages">为什么使用Hexo + GitHub Pages</h2><p><strong>优点：</strong> 主要是 Hexo 完全免费，静态，轻量快速，并且可以托管在GitHub，当然也可以托管在国内的Gitee里面，但是会麻烦一点。</p><p><strong>缺点：</strong> 在国内GitHub访问速度一般，前期搭建和发布文章有点点麻烦。</p><h1>搭建步骤</h1><h2 id="安装准备">安装准备</h2><p>在搭建博客之前，需要确认电脑上已经安装好了 Git 和 Node.js ，然后再安装Hexo。</p><ul><li><p>​<a href="https://nodejs.org/en/">Node.js 官网</a></p></li><li><p>​    <a href="https://git-scm.com/">Git 官网</a></p></li><li><p>​    <a href="https://blog.csdn.net/mukes/article/details/115693833">Git 安装教程</a></p></li><li><p>​<a href="https://blog.csdn.net/chanyeolchichi/article/details/121348541">Node.js 安装教程</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Node.js之后使用国内的淘宝镜像源加速，安装之后可以用 cnpm 代替 npm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="链接GitHub">链接GitHub</h2><p>需要一个<a href="https://github.com/">GitHub</a>账号，使用邮箱注册。</p><p><strong>配置GitHub账号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 配置用户名和邮箱</span><br><span class="line">git config --global user.name &quot;github的用户名&quot;</span><br><span class="line">git config --global user.email &quot;github的注册邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>创建SSH密钥</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成 ssh 密钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;github的注册邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>添加密匙：</strong></p><p>进入 <code>C:\Users\用户名\.ssh</code> 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329110048.png" alt="添加成功界面"></p><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329110555.png" alt="连接成功"></p><p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><h2 id="新建Github-Pages-仓库">新建Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329110815.png" alt="创建Pages"></p><p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="本地安装Hexo">本地安装Hexo</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 Hexo-Blog。<strong>打开该文件夹</strong>，右键 -&gt; Git Bash Here。</p><h3 id="安装-Hexo">安装 Hexo</h3><p>使用 npm 一键安装 Hexo 博客程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Hexo-初始化和本地预览">Hexo 初始化和本地预览</h3><p><strong>初始化并安装所需组件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init      <span class="comment"># 初始化</span></span><br><span class="line">cnpm install    <span class="comment"># 安装组件</span></span><br></pre></td></tr></table></figure><p>完成后依次输入下面命令，<strong>启动本地服务器进行预览</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo clean </span></span><br><span class="line"></span><br><span class="line">hexo g   <span class="comment"># 生成页面</span></span><br><span class="line">hexo s   <span class="comment"># 启动预览</span></span><br></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329112426.png" alt="访问成功"></p><p>**Tips：**如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 <code>hexo server -p 5000</code> 更改端口号后重试。</p><p>Hexo 博客文件夹目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/20220329112551.png" alt=""></p><h2 id="部署Hexo到GitHub-Pages">部署Hexo到GitHub Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仓库地址最好是ssh方式，也可以是http格式，可以在github仓库中查找到</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h2 id="绑定域名（待更新）">绑定域名（待更新）</h2><h2 id="开始使用">开始使用</h2><h3 id="发布文章">发布文章</h3><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 My New <a href="http://Post.md">Post.md</a> 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这两条命令。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo d   # 部署发布</span><br></pre></td></tr></table></figure><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="section">- Games</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure><h3 id="网站设置">网站设置</h3><p>包括网站名称、描述、作者、链接样式等，全部在网站目录下的 _config.yml 文件中，参考<a href="https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/configuration">官方文档</a>按需要编辑。</p><p>注意：冒号后要加一个空格！</p><h3 id="更换主题">更换主题</h3><p>在 <a href="https://link.zhihu.com/?target=https%3A//hexo.io/themes/">Themes | Hexo</a> 选择一个喜欢的主题，比如 <a href="https://link.zhihu.com/?target=http%3A//theme-next.iissnan.com/getting-started.html">NexT</a>，进入网站目录打开 Git Bash Here 下载主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后修改 _config.yml 中的 theme 为新主题名称 next，发布。（有的主题需要将 _config.yml 替换为主题自带的，参考主题说明。）</p><h3 id="常用命令">常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;name&quot;</span>       <span class="comment"># 新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;name&quot;</span>  <span class="comment"># 新建页面</span></span><br><span class="line">hexo g                <span class="comment"># 生成页面</span></span><br><span class="line">hexo d                <span class="comment"># 部署</span></span><br><span class="line">hexo g -d             <span class="comment"># 生成页面并部署</span></span><br><span class="line">hexo s                <span class="comment"># 本地预览</span></span><br><span class="line">hexo clean            <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line">hexo <span class="built_in">help</span>             <span class="comment"># 帮助</span></span><br></pre></td></tr></table></figure><h2 id="PicGo-Github-CDN-搭建博客图床">PicGo + Github + CDN 搭建博客图床</h2><h3 id="创建仓库">创建仓库</h3><p>新键一个图片仓库</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291231661.png" alt=""></p><p>填好相关信息</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291232207.png" alt=""></p><h3 id="获取token">获取token</h3><blockquote><p><strong>token</strong><br>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。 当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。我们通过token来确定GitHub仓库的位置。</p></blockquote><p>点击setting</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291233120.png" alt=""></p><p><code>Settings -&gt; Developer settings -&gt; Personal access tokens，最后点击 generate new token</code>；</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291233623.png" alt=""></p><p>点击生成token</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291234726.png" alt=""></p><p>保存好生成的token(仅显示一次)，因此最好存放到备忘录里面。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291234280.png" alt=""></p><h3 id="下载PicGo">下载PicGo</h3><p>进入picgo官网: <a href="https://picgo.github.io/PicGo-Doc/zh/">https://picgo.github.io/PicGo-Doc/zh/</a></p><p>点击免费下载，跳转到GitHub界面，选择对应系统的版本进行安装</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291237737.png" alt=""></p><h3 id="设置PicGo">设置PicGo</h3><p>选择GitHub图床，根据提示填写，<strong>保存图片的库可以更换，只需要把PicGo里面的仓库名对应改掉就行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291238463.png" alt=""></p><p>在picgo设置里面可以设置上传的快捷键，此外，最好打开时间戳重命名功能，防止图片名字重复</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291238772.png" alt=""></p><h3 id="CDN加速">CDN加速</h3><blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以<code>就近取得</code>所需的内容，<strong>提高用户访问网站的响应速度。</strong></p></blockquote><p>在这里，我们选择了快速免费公有的CDN-<strong>jsdelivr</strong></p><p>配置方法：</p><p>只需要在我们 PicGo 图床配置中添加如下自定义域名即可</p><p><code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code></p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291239301.png" alt=""></p><p>到这里，一个图床算是基本搭建好了。通过picgo上传图片，会在GitHub创建的仓库中保存。</p><h3 id="Markdown编辑器Typora的设置（可选）">Markdown编辑器Typora的设置（可选）</h3><p><strong>Markdown</strong></p><p>官网：<code>https://markdown.com.cn/</code></p><blockquote><p>Markdown是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。 markdown的优点：</p></blockquote><ul><li>专注于文字内容；</li><li>纯文本，易读易写，可以方便地纳入版本控制；</li><li>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。</li></ul><p><strong>Typora</strong></p><blockquote><p>ypora是一个专注于markdown语言的优秀编辑器。 官网：<code>https://typora.io/</code></p></blockquote><p>打开Typora的偏好设置，设置好红色方框里面的内容，便可以在Typora里面编写文章的同时上传图片到图床了。</p><p><img src="https://cdn.jsdelivr.net/gh/Kaillliu/blog-img/202203291241165.png" alt=""></p><h2 id="常见问题">常见问题</h2><h3 id="设置网站图标">设置网站图标</h3><p>进入 themes/主题 文件夹，打开 _config.yml 配置文件，找到 favicon 修改，一般格式为：<code>favicon: 图标地址</code>。（不同主题可能略有差别）</p><h3 id="修改并部署后没有效果">修改并部署后没有效果</h3><p>使用 <code>hexo clean</code> 清理后重新部署。</p><h3 id="开启-HTTPS-后访问网站显示连接不安全？">开启 HTTPS 后访问网站显示连接不安全？</h3><p>证书还未部署生效，等待一会儿，清除浏览器缓存再试。</p><h3 id="Hexo部署出现错误err-Error-Spawn-failed解决方式">Hexo部署出现错误err: Error: Spawn failed解决方式</h3><pre><code>https://blog.csdn.net/weixin_41256398/article/details/117994899</code></pre><h3 id="Github连接出现ssh-connect-to-host-github-com-port-22-Connection-timed-out-错误">Github连接出现ssh: connect to host <a href="http://github.com">github.com</a> port 22: Connection timed out 错误</h3><p>​<a href="https://blog.csdn.net/vosang/article/details/50499300">Github连接出现ssh: connect to host github.com port 22: Connection timed out 错误</a></p><p>​<a href="https://blog.csdn.net/msStev/article/details/109379342">git commit、merge 如何退出git bash vim编辑器</a></p><h1>参考资料</h1><ul><li><p><a href="https://easyhexo.com/">Easy Hexo</a> ：包括Hexo快速开始，推荐主题，插件使用等等</p></li><li><p><a href="https://butterfly.js.org/">Butterfly</a>：本站使用的主题</p></li><li><p>搭建教程：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></li><li><a href="https://blog.csdn.net/github_39655029/article/details/116485386">https://blog.csdn.net/github_39655029/article/details/116485386</a></li></ul></li><li><p>使用ssh连接Git仓库（Github)</p><ul><li><a href="https://www.jianshu.com/p/20089411571d">https://www.jianshu.com/p/20089411571d</a></li></ul></li><li><p>PicGo+GitHub图床搭建部分的参考</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/350598351">https://zhuanlan.zhihu.com/p/350598351</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/138012354">https://zhuanlan.zhihu.com/p/138012354</a></p></li></ul></li><li><p>Node.js 使用淘宝 NPM 镜像的相关说明</p><ul><li><a href="https://www.twle.cn/l/yufei/nodejs/nodejs-basic-cnpm.html">https://www.twle.cn/l/yufei/nodejs/nodejs-basic-cnpm.html</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
